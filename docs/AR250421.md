# Binary Search Tree: Iterators and Erase Logic

### Date: 2025-04-21

---

## Key Points

- `find` locates a node using binary search logic.
- Iterators traverse the BST in-order using `++` and `--` operators.
- `erase` supports deletion of:
  - Leaf nodes
  - Nodes with one child
  - Nodes with two children (replaced by inorder successor)

---

## Overview

This study note focuses on the implementation of `find`, iterator behavior, and the `erase` operation in a templated Binary Search Tree (BST). The BST manages memory explicitly, with pointer-based node structures and recursive logic for insertion and traversal.

---

## Find and Iterator Basics

```cpp
BST<int, int> bst;
bst.insert(MakePair(8, 0));
bst.insert(MakePair(4, 0));
bst.insert(MakePair(12, 0));

BST<int, int>::iterator iter = bst.find(8);
if (iter != bst.end()) {
    std::cout << (*iter).first << std::endl;
}
```

### In-Order Iterator Behavior
- `begin()` returns the leftmost (smallest) node.
- `end()` is a sentinel (null pointer).
- `++iter` traverses to the inorder successor.
- `--iter` (not fully implemented here) should traverse to the inorder predecessor.

---

## `erase` Operation

### 1. Deleting a Leaf Node
- If the node has no children, simply delete it.

```cpp
if (target->IsLeaf()) {
    // Detach from parent and delete
    delete target;
}
```

### 2. Deleting a Node with One Child
- Replace node with its only child.

```cpp
if (target->HasLChild())
    parent->arrPtr[LCHILD] = target->GetNode(LCHILD);
else
    parent->arrPtr[RCHILD] = target->GetNode(RCHILD);
```

### 3. Deleting a Node with Two Children
- Find the inorder successor (smallest in right subtree).
- Copy successor's value to current node.
- Recursively delete the successor.

```cpp
pSuccessor = GetInorderSuccessor(target);
target->pair = pSuccessor->pair;
erase(successor_iter);
```

---

## Code Demonstration

```cpp
BST<int, int> bst;
bst.insert(MakePair(8, 0));
bst.insert(MakePair(4, 0));
bst.insert(MakePair(12, 0));
bst.insert(MakePair(2, 0));
bst.insert(MakePair(10, 0));

BST<int, int>::iterator iter = bst.find(8);
if (iter != bst.end()) {
    iter = bst.erase(iter);  // safely returns iterator to next valid node
}
```

---

## Randomized Setup Example

```cpp
map<int, int> mapData;
srand(time(nullptr)); // Time as seed
int iRandom[10] = {};
for (int i = 0; i < 10; ++i) {
    iRandom[i] = (rand() % 100) + 1;
    mapData.insert(make_pair(iRandom[i], 0));
}
```

This ensures 10 random, non-repeating keys are inserted using `std::map`'s unique key behavior.

---

## Interview Questions

**Q: What is an inorder successor in BST?**  
A: The leftmost node in the right subtree of a given node.

**Q: How does `erase` handle node deletion with two children?**  
A: Replaces target node's value with that of its inorder successor, then deletes the successor.

**Q: Why is it important to reassign iterators after deletion?**  
A: Iterator becomes invalid after deletion; reassignment ensures safe traversal.

---

## Visual: BST Node Deletion

```
Initial BST
      8
     / \
    4   12
   /     \
  2      10

After deleting 8:
      10
     /  \
    4    12
   /
  2
```

---

## References 

- [BST.h]


Changed paths:
   M /C++/C++_56/BST.h
   M /C++/C++_56/이진탐색트리 삭제 1.cpp

1. 이진탐색트리 삭제 마무리
------------------------------------------------------------------------
r54 | AR56 | 2025-04-21 13:52:26 +0900 (월, 21 4 2025) | 5 lines
Changed paths:
   M /C++/C++_56/BST.h
   M /C++/C++_56/이진탐색트리 삭제 1.cpp

1. 이진탐색트리 삭제
  - 삭제할 노드가 단말노드인 경우
  - 삭제할 노드가 자식을 1개 보유하고 있는 경우
  - 삭제할 노드가 자식을 2개 가지고 있는 경우 진행 예정

------------------------------------------------------------------------
r53 | AR56 | 2025-04-21 12:52:03 +0900 (월, 21 4 2025) | 3 lines
Changed paths:
   M /C++/C++_56/BST.h
   M /C++/C++_56/C++_56.vcxproj
   M /C++/C++_56/C++_56.vcxproj.filters
   M /C++/C++_56/이진탐색트리 Find, iterator 구현하기.cpp
   A /C++/C++_56/이진탐색트리 삭제 1.cpp

1. 중위 후속자 찾기 과제풀이

2. 이진탐색트리 데이터 삭제 시작
