#  Data Types in C++ 

### Date: 2025-03-05

--- 

## 1. Overview of Programming Languages and Compilation Process

```cpp
// C++, C, Java, C#, Objective-C
//        |
//     Compiler
//        ↓
// Assembly Code → Binary (Machine Code)
```

Compilers convert high-level code into low-level assembly and binary code, enabling execution on a CPU.

---

## 2. Integer Data Types

Integer types store whole numbers in memory. The range depends on size (bytes).

```cpp
// Integer data types with their size (on most systems)
bool        b;   // 1 byte, true(1) / false(0)
char        c;   // 1 byte, -128 to 127 (signed), 0 to 255 (unsigned)
short       s;   // 2 bytes, -32,768 to 32,767
int         i;   // 4 bytes, -2,147,483,648 to 2,147,483,647
long        l;   // 4 bytes (same as int in most systems)
long long   ll;  // 8 bytes, -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
```

### Signed vs Unsigned

```cpp
signed char sc = -10;  // Can hold negative values
unsigned char uc = 255; // No negatives, 0 to 255
```

**Signed vs Unsigned Comparisons**

```cpp
int a = -1;
unsigned int b = 1;

if (a < b)
    std::cout << "a is less than b\n";  // Unexpected output!
else
    std::cout << "b is less than a\n";  // Prints this!

// When comparing signed and unsigned, 'a' becomes a large positive number.
```

To fix this, explicitly cast before comparing:

```cpp
if (static_cast<int>(b) > a)  // Correct comparison
```

---

## 3. Integer Representation and Two’s Complement

Binary Representation (2’s complement for negative numbers):

```cpp
signed char x = -1;  // -1 in binary: 1111 1111 (2’s complement)
unsigned char y = x; // Now interpreted as 255 (not -1!)
std::cout << (int)y;  // Output: 255
```

Signed and unsigned types interpret bits differently.

---

## 4. Floating-Point Data Types

Floating-point numbers store decimal values, but with precision limitations.

```cpp
float  f = 3.14f;  // 4 bytes, ~7 decimal digits precision
double d = 3.14;   // 8 bytes, ~15 decimal digits precision
```

### Floating-Point Precision Issues

```cpp
float x = 0.1f + 0.2f;
std::cout << (x == 0.3f);  // Output: 0, false
```

To fix this, use a small error margin (epsilon):

```cpp
if (fabs(x - 0.3f) < 1e-6)  // Correct floating-point comparison
```

---

## 5. Type Conversion (Implicit and Explicit Casting)

### Implicit Type Conversion

```cpp
int i = 3.14;  // Output: 3, truncation occurs
float f = 10;  // Converts int → float, no issue
```

### Explicit Type Conversion

```cpp
float f = (float)10 / 3;  // Ensures floating-point division (3.333...)
```

### Tricky Cases

```cpp
int i = 100000;
short s = i;   // Possible overflow if i > 32767
char c = i;    // Undefined if i > 127 or i < -128
```

Always check range compatibility when converting types.

---

## Summary

| Concept | Example | Key Point |
|---------|---------|-----------|
| Signed vs Unsigned | `int a = -1; unsigned int b = 1;` | Be cautious when comparing signed and unsigned. |
| Two’s Complement | `signed char c = -1; unsigned char uc = c;` | Signed and unsigned interpret bits differently. |
| Integer Truncation | `int x = 3.14;` | Decimal part is cut off, not rounded. |
| Floating-Point Precision | `float x = 0.1f + 0.2f;` | Due to rounding errors, `x != 0.3f`. |
| Type Conversion | `(float)10 / 3;` | Explicit casting prevents unintended truncation. |



