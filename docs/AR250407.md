# Heap and Dynamic Allocation in C++

### Date: 2025-03-10

---

## Key Points

- Use `new` and `delete` for type-safe memory allocation with constructor/destructor calls.
- C-style `malloc/free` does not call constructors or destructors.
- Arrays require `delete[]` instead of `delete` to properly call destructors for each element.
- Custom containers like `CArray<T>` mimic STL container behavior.
- Use `reserve()` to pre-allocate memory and `resize()` to fill with default values.
- STL `vector` offers efficient random access; `list` offers efficient insertion/deletion.

---

## Overview

Dynamic memory in C++ allows you to allocate memory on the heap, crucial when the size of data isn't known at compile time. The traditional C approach uses `malloc()` and `free()`, but this is unsafe for classes due to the absence of constructor and destructor calls.

Instead, C++ introduces `new` and `delete`, which allocate memory and properly construct and destruct objects.

```cpp
class MyClass {
private:
    int m_i;
public:
    MyClass() : m_i(0) { cout << "Constructor called" << endl; }
    ~MyClass() { cout << "Destructor called" << endl; }
};

int main() {
    MyClass* pObj = new MyClass;
    delete pObj;

    MyClass* pArr = new MyClass[10];
    delete[] pArr;
    return 0;
}
```

**Why `delete[]`?** When you use `new[]` to allocate an array, each element's destructor must be called individually during deallocation.

---

## Common Mistakes

### **Mixing `malloc/free` with C++ classes**
```cpp
MyClass* p = (MyClass*)malloc(sizeof(MyClass));
free(p); // Constructor/Destructor not called
```

### **Forgetting `delete[]` for arrays**
```cpp
MyClass* pArray = new MyClass[10];
delete pArray; // Incorrect
// Correct:
delete[] pArray;
```

### **Confusion between `reserve()` and `resize()`**
```cpp
vec.reserve(100); // Allocates space but does not initialize elements
vec.resize(100);  // Allocates and initializes elements
```

---

## Tricky Case: Templates & Custom Containers

A custom template-based container like `CArray<T>` must handle allocation, copying, and access safely:

```cpp
template <class T>
class CArray {
public:
    void push_back(const T& data);
    T& at(size_t index);
    void clear();
};
```

Usage with structs:
```cpp
struct MyStruct { int iarr[10]; };
CArray<MyStruct> arr;
MyStruct st = {};
arr.push_back(st);
```

Ensure you correctly manage memory and avoid shallow copying in your container implementation.

---

## STL Container Insights

### `vector`
- Random access: O(1)
- Efficient resizing with `reserve()` and `resize()`
- Elements stored contiguously

### `list`
- Doubly linked list: O(1) insertion/deletion
- No direct indexing: access is O(n)

```cpp
list<int> intList;
intList.push_back(10);
for (auto it = intList.begin(); it != intList.end(); ++it) {
    cout << *it << endl;
}
```

Use `vector` for fast access; `list` when frequent insertion/deletion is required.

---

## Interview Questions

**Q: What is the difference between `malloc` and `new` in C++?**  
A: `malloc` allocates raw memory and doesn't call constructors. `new` allocates memory and calls the constructor.

**Q: When should `delete[]` be used?**  
A: When the memory was allocated with `new[]`. It ensures destructors for all elements are called.

**Q: What’s the difference between `reserve()` and `resize()` in `std::vector`?**  
A: `reserve()` allocates memory without changing size. `resize()` changes the container's size and initializes new elements.

**Q: Why is mixing `malloc/free` with class types dangerous?**  
A: Because constructors and destructors won't be executed, leading to resource leaks or undefined behavior.

**Q: What happens if I use `delete` instead of `delete[]`?**  
A: Only the destructor of the first object is called, which causes resource leaks or undefined behavior.

---

## Code Demonstration

```cpp
vector<int> vecInt;
vecInt.resize(2000);
vecInt.push_back(10);
vecInt.clear();

vector<int> temp = vecInt;
vecInt.swap(temp);

int size = vecInt.size();
int capacity = vecInt.capacity();
```

```cpp
CArray<int> arr;
arr.push_back(10);
arr.push_back(20);
arr.push_back(30);
int val = arr[2];
arr[0] = 100;
```

---

## Visual: Memory Allocation Comparison

```
Heap Allocation          Constructor/Destructor
---------------         -----------------------
malloc/free             NO
new/delete              YES
new[]/delete[]          YES (for each element)
```

---

## References

- [CArray.h](codes/CArray.h)
- [new_delete.cpp](codes/new_delete.cpp)
- [vector_usgae.cpp](codes/vector_usage.cpp)
- [class_template.cpp](codes/class_template.cpp)

