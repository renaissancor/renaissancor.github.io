
# CPP Dynamic Array 

동적 배열 Dynamic Array Class 
동적 할당 New Delete CPP Dynamic Allocation 
탬플릿 Template 

## Template 

```c++
void SetData(int (&_Arr)[10])
{
    for(int i=0; i<Size; ++i)
    {
        _Arr[i] = i + 1; 
    }
}

int iArr[10] = {}; 
int jArr[20] = {}; 
SetData(iArr);
SetData(jArr); // ERROR 
```
Template Required case when Array Reference is input 

```c++
template<int Size>
void SetData(int (&_Arr)[Size])
{
    for(int i=0; i<Size; ++i)
    {
        _Arr[i] = i + 1; 
    }
}
```

However, each template generates new function per each different int size. 
Thus, those are all diffrent generatead functions, and not efficient. 

```c++
template<int Size>
void SetData(int *_Arr, int Size)
{
    for(int i=0; i<Size; ++i)
    {
        _Arr[i] = i + 1; 
    }
}
```
Recomomended to get input by pointer and size to be better like this. 

## New & Delete 

`Malloc` will 

```c++
// C Style Dynamic Allocation 
int* pData = (*int) malloc (sizeof(int)*2); 
free(pData);

// CPP Generator, Terminator and Dynamic Allocation 
MyClass my; 

```
If class is generated on the scope, automatically terminator is called at the end of scope

malloc(4) return void; 

일반적인 선언의 생성자 호출은 보장됨
MyClass my; 

생성자 호출이 보장이 되지 않음 



new 키워드 뒤에 MyClass 를 넣으면 
new 는 malloc + Class 생성자 호출 탬플릿 
new MyClass; 


// 마이 클래스 용도 주소 호출자 this 포인터 

new delete 라는 탬플릿을 이용하여 malloc free 와 생성자 소멸자 콜까지 함께 
객채 생성 소멸 시 생성자 소멸자 호출울 new delete 

Basic malloc and free dynamically allocate requested size and free the notified memory 
It is impossible to figure out how that space is currently used 
Thus when object is generated into the heap memory as a class type data unit 
Class generator and terminator call is NOT guaranteed 

Thus, to solve this new, delete template is required to the corresponding data type 
So that size gets dynamic allocation 

MyClass *pMy = (MyClass*)malloc(sizeof(MyClass)); 
free(pMy); 

MyClass * pNewMy = new MyClass; 
delete pNewMy; 

