# Thread Control 

## 1. 커널 모드 전환과 인터럽트의 비용 (The Heavy Toll of Mode Switch)

유저 레벨에서 단순히 코드를 실행하는 것보다 커널 모드로의 전환(Transition)이 무거운 이유는 시스템 전반에 미치는 **'여파(Side Effects)'** 때문입니다.

* **메모리 시야와 스택의 변화:** 커널 모드 진입 시 유저 스택에서 **커널 스택**으로 전환됩니다. 가상 메모리 테이블(CR3) 자체가 바뀌는 것은 아니지만, 커널 영역 포인터에 접근하게 되며 CPU의 파이프라인과 캐시가 유저 모드와는 다른 데이터로 채워지게 됩니다.
* **I/O의 병목:** `select`, `send`, `recv` 같은 소켓 API가 느린 근본적인 이유는 커널 전환 오버헤드와 더불어 내부의 거대한 판단 로직(예: 수만 번의 `cmp`) 때문입니다. 따라서 고성능 서버는 **호출 횟수 자체를 줄이는 설계**가 필수적입니다.
* **Interrupt의 우선순위:** 하드웨어 인터럽트(HW)는 소프트웨어 인터럽트(SW)보다 훨씬 무겁고 강력합니다. IDT(Interrupt Descriptor Table)를 통해 ISR이 실행될 때 동일하거나 낮은 레벨의 인터럽트는 차단되며, 이는 현재 실행 중인 쓰레드의 퀀텀(Quantum)을 보장해주지 않습니다.

---

## 2. 쓰레드 제어와 스케줄링 (Thread Control & Scheduling)

* **유저 쓰레드 vs 커널 쓰레드:**
* **커널 쓰레드:** OS가 스케줄링의 주체입니다. 우리가 만드는 대부분의 쓰레드입니다.
* **유저 쓰레드 (Fiber/Coroutine):** 유저 레벨에서만 존재하며 OS는 그 존재를 모릅니다. 따라서 수동으로 `Yield`(양보)를 해주지 않으면 다른 코루틴으로 넘어가지 않습니다.


* **Sleep(0) vs SwitchToThread:** * `Sleep(0)`은 우선순위가 같은 쓰레드에게만 양보하던 과거와 달리, 현재는 Ready 상태의 다른 쓰레드에게 퀀텀을 포기하고 제어권을 넘깁니다.
* `SwitchToThread`는 우선순위와 상관없이 실행 대기 중인 다른 쓰레드에게 기회를 줍니다. 두 함수 모두 **기아 현상(Starvation)** 방지와 관련이 있지만, 내부 구조는 OS 버전마다 모호한 부분이 있습니다.


* **우선순위의 의미:** CPU 사용률이 100%가 아닌 상황(예: 50%)에서 특정 쓰레드의 우선순위를 높이는 것은 큰 의미가 없습니다. 레디 큐가 비어있다면 우선순위와 상관없이 즉시 실행되기 때문입니다.

---

## 3. WinAPI와 CRT의 관계 (WinAPI vs C++ Runtime)

쓰레드를 생성할 때 `CreateThread` 대신 `_beginthreadex`를 써야 하는 결정적인 이유는 **데이터의 독립성**과 **정리(Cleanup)** 때문입니다.

* **공간 할당:** `strtok`, `rand`, `GetLastError` 등은 쓰레드마다 독립적인 저장 공간(TLS)이 필요합니다. `_beginthreadex`는 이를 위한 CRT 블록을 초기화합니다.
* **종료의 정석:** `ExitThread`나 `TerminateThread`는 절대 금물입니다. 이들은 **C++ 객체의 소멸자를 호출하지 않습니다.** * 가장 좋은 방법은 쓰레드 함수가 스스로 **`return`**하게 하는 것입니다. 그래야 컴파일러가 삽입한 지역 객체의 소멸자가 정상 작동합니다.
* `_endthreadex`는 CRT 자원을 정리하지만, 이 역시 강제 종료보다는 자연스러운 리턴이 권장됩니다.



---

## 4. 멀티쓰레드 디버깅과 재현 (Debugging & Reproducing)

* **오염된 데이터:** 쓰레드 10개를 동시에 만든다고 해서 10개가 "완벽하게 동시에" 시작되지는 않습니다. 미세한 시간차가 존재하므로, 경합(Race Condition)을 테스트할 때는 프로파일링 데이터가 오염될 수 있음을 인지해야 합니다.
* **상상 후 재현:** 멀티쓰레드 버그는 한 달에 한 번 발생할 수도 있습니다. 머리로 시나리오를 짜고, **`Sleep` 등을 이용해 인위적으로 타이밍을 맞춰 문제를 재현**한 뒤 수정해야 합니다. "고친 것 같다"는 상상만으로 패치를 내보내는 것은 위험합니다.

---

## 5. 답변: assert와 abort의 작동 방식

> **Q: assert로 디버깅할 때 내부적으로 abort를 호출하는데, 이게 CRT 정리 없이 그 자리에서 멈추나요?**

**A: 네, 맞습니다.** 1.  **즉시 중단:** `abort()`는 C++의 정상적인 종료 루틴(전역 객체 소멸자 호출, `atexit` 등록 함수 실행 등)을 **모두 무시**하고 프로세스를 즉시 종료시킵니다.
2.  **자원 정리 생략:** 쓰레드 스택의 지역 객체 소멸자도 호출되지 않습니다. 말 그대로 "현행범 체포" 시점의 메모리 상태를 그대로 남겨두기 위함입니다.
3.  **디버깅 목적:** 이는 오류가 발생한 지점의 콜 스택과 변수 값을 정확히 보존하여 개발자가 원인을 파악할 수 있게 하기 위한 의도적인 설계입니다.

