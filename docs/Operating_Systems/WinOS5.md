# [System Programming] 멀티스레드 제어와 동기화의 본질

## 1. GetLastError와 TLS (Thread Local Storage)

멀티스레드 환경에서 `strtok`, `rand`, `GetLastError`와 같은 함수들이 안전하게 동작할 수 있는 이유는 **TLS(Thread Local Storage)** 덕분입니다.

* **독립 공간의 확보:** `GetLastError`나 `WSAGetLastError`는 스레드마다 독립적인 저장 공간을 가집니다. A 스레드의 에러가 B 스레드에 영향을 주지 않아야 하기 때문입니다.
* **컴파일러와 OS의 협조:** * **API 방식:** 직접 호출을 통해 데이터를 얻어옵니다.
* **언어/컴파일러 방식:** 변수 선언 시 스레드별 인덱스를 부여하고, 스레드 생성 시 필요한 TLS 바이트만큼 OS와 협력하여 공간을 할당합니다.


* **PTD (Per-Thread Data):** CRT(C Runtime)는 스레드마다 PTD 구조체를 만들어 관리하며, 이를 통해 스레드 전용 데이터의 연속성을 보장합니다.

---

## 2. 왜 `_beginthreadex`인가? (Wrapping의 미학)

Windows API인 `CreateThread` 대신 CRT 함수인 `_beginthreadex`를 사용해야 하는 이유는 **초기화와 정리(Cleanup)** 때문입니다.

* **스레드 함수 래핑:** `_beginthreadex`는 우리가 만든 `ThreadMain`을 직접 실행하지 않습니다. 내부적으로 `_threadstartex`라는 래퍼 함수를 먼저 실행합니다.
* **자동 정리 루틴:** 1.  PTD 구조체 등 CRT 관련 리소스를 초기화합니다.
2.  사용자가 정의한 `ThreadMain`을 호출합니다.
3.  함수가 리턴되면 정리 코드를 실행하여 자원 누수를 방지합니다.
* **권장 사항:** 스레드 종료 시 `ExitThread`나 `TerminateThread`를 쓰지 말고, 반드시 **`return`**을 통해 자연스럽게 래퍼 함수의 정리 코드가 동작하게 해야 합니다.

---

## 3. 인터락(Interlocked) 연산과 메모리 경계

동기화의 가장 밑바닥에는 CPU 수준의 원자적 연산인 **Interlocked API**가 있습니다.

* **원자적 보장:** `InterlockedExchange` 등은 단순한 `mov`나 `if`문과 달리, 값을 읽고 쓰는 사이의 **원자성(Atomicity)**을 CPU 하드웨어 레벨에서 보장합니다.
* **정렬의 중요성 (Alignment):**
* 인터락 연산은 반드시 **메모리 경계(Boundary)**에 정렬되어야 합니다. (32비트는 4바이트, 64비트는 8바이트 경계)
* 경계에 맞지 않으면 CPU가 원자적 처리를 보장하지 않거나, 최신 아키텍처에서는 심각한 성능 저하 혹은 크래시를 유발합니다. 이를 위해 `_aligned_malloc` 등이 사용됩니다.


* **비용:** 인터락 연산은 CPU의 **비순차적 명령어 처리(Out-of-order execution)**와 파이프라이닝을 무효화합니다. 수백 개의 명령어를 버리고 새로 시작해야 하므로 일반 연산보다 비쌉니다.

---

## 4. 스핀락(Spinlock)과 유저/커널 모드 동기화

동기화 객체를 사용할 때의 전략적 선택에 관한 내용입니다.

### 스핀락 (Spinlock)

* **작동 방식:** `while`문을 돌며 인터락 연산으로 소유권을 얻을 때까지 무한 루프를 돕니다.
* **장점:** 컨텍스트 스위칭이 일어나지 않아 대기 시간이 매우 짧다면 가장 빠릅니다. 퀀텀을 포기하지 않고 즉시 실행을 이어가려는 "이기적인" 최적화 기법입니다.
* **단점:** 대기 시간이 길어지면 CPU 점유율만 잡아먹는 낭비가 발생합니다.

### 커널 동기화 객체

* **특징:** 소유권 획득 실패 시 스레드가 **Block(대기)** 상태로 전환되며 퀀텀을 포기합니다.
* **비용:** 커널 모드 전환 오버헤드가 발생하지만, CPU 리소스를 다른 스레드에게 양보하므로 시스템 전체 효율은 좋아집니다.

> **결론:** 현대 OS 커널도 내부적으로는 스핀락과 인터락을 섞어 씁니다. 하지만 유저 레벨에서는 아주 특수한 성능 최적화 상황이 아니라면 검증된 WinAPI 동기화 객체를 쓰는 것이 안전합니다.

---

## 5. 예외 처리와 서버 운영

* **현행범 체포:** 스레드 예외 발생 시 `abort()`나 `assert()`는 자원 정리 없이 그 자리에서 멈춥니다. 이는 오염된 데이터로 시스템이 더 망가지기 전에 당시의 메모리 상태(덤프)를 보존하기 위함입니다.
* **생성자 예외:** C++ 생성자에서 예외가 발생하면 소멸자가 호출되지 않을 수 있습니다. 초기화 실패 시의 대응 코드를 항상 염두에 두어야 합니다.
* **로그의 철학:** 모든 성공을 기록하기보다, "내 머릿속에서 예상 가능한 실패"와 "예상치 못한 예외"를 구분하여 로그를 남기는 전략이 필요합니다.

---

