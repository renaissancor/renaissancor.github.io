# RAII template try catch 

이 문서는 C++ 언어의 여러 핵심 개념들을 다룹니다. **식별자**, **문자열 매크로**, **스마트 포인터와 RAII**, **템플릿**, 그리고 **예외 처리**에 대한 내용을 상세하게 설명하고, 특히 실제 개발 환경에서의 경험과 조언을 포함하고 있습니다.

-----

## 1\. 식별자와 문자열 매크로

C++에서 \*\*식별자(identifier)\*\*는 변수, 함수, 클래스 등 프로그램 요소를 구분하기 위해 사용하는 이름입니다. 코드에서 식별자와 동일한 이름의 객체를 생성하고 문자열을 붙이는 방식은, 특히 로깅이나 디버깅 목적으로 객체의 이름을 문자열로 표현할 때 사용될 수 있습니다.

예를 들어, `프로파일 시작`과 같은 로그를 남길 때, 매크로를 활용하여 객체의 이름(식별자)을 자동으로 문자열로 변환하는 방식을 사용할 수 있습니다. 그러나 이 방식은 다음과 같은 문제점을 가질 수 있습니다:

  * **가독성 저하**: 매크로 내부에 식별자를 직접 넣는 방식은 코드를 이해하기 어렵게 만들 수 있습니다.
  * **유지보수 어려움**: 매크로 정의가 복잡해지면 디버깅이 힘들어지고, 예상치 못한 부작용이 발생할 수 있습니다.
  * **의미 전달 부족**: 태그 이름과 변수 이름을 따로 넣는 것이 더 명확할 수 있습니다. 예를 들어, `PROFILE_BEGIN("DB_QUERY", my_query_object);`와 같이 태그를 명시적으로 지정하는 것이 좋습니다.

결론적으로, 매크로를 사용하여 식별자를 문자열로 변환하는 것은 편리할 수 있지만, 코드의 명확성과 안정성을 위해 신중하게 접근해야 합니다.

-----

## 2\. RAII와 스마트 포인터

C++에서 메모리 관리는 매우 중요하며, **생 포인터(raw pointer)** 사용은 메모리 누수나 오류의 주요 원인이 됩니다. C++에서는 이러한 문제 해결을 위해 **RAII(Resource Acquisition Is Initialization)** 개념과 **스마트 포인터**를 적극적으로 활용합니다.

### 2.1 RAII (자원 획득은 초기화다)

**RAII**는 자원(메모리, 파일 핸들, 락 등)의 획득을 객체의 생성자에서 처리하고, 해제를 소멸자에서 처리하는 프로그래밍 기법입니다. 이를 통해 자원 관리를 자동화하고, 예외 발생 시에도 자원이 안전하게 해제되도록 보장합니다.

예를 들어, \*\*`lock_guard`\*\*는 RAII의 좋은 예시입니다. 생성자에서 뮤텍스(mutex)를 잠그고, 소멸자에서 자동으로 해제하여 개발자가 락 해제를 잊어버리는 실수를 방지합니다.

### 2.2 스마트 포인터

스마트 포인터는 RAII를 활용한 객체로, 동적 할당된 메모리를 소유하고 자동으로 해제하는 기능을 제공합니다.

  * **`shared_ptr`**: 여러 포인터가 동일한 메모리를 공유할 때 사용합니다. 참조 카운팅을 통해 모든 `shared_ptr`이 소멸될 때 메모리를 해제합니다.
  * **`unique_ptr`**: 단독으로 메모리 소유권을 가지며, 다른 `unique_ptr`에 소유권을 이전할 수 있습니다. `new/delete`를 대체하여 메모리 누수를 방지합니다.

일반적으로 C++에서 생 포인터 대신 스마트 포인터를 사용하면 코드의 안정성과 유지보수성이 크게 향상됩니다.

### 2.3 `new`/`delete` 재정의

`new`와 `delete` 연산자를 재정의하여 메모리 할당 방식을 커스터마이징할 수 있습니다.

  * **일반 `new` 재정의**: 전역적으로 `operator new`를 재정의하여 모든 `new` 호출에 대한 동작을 변경할 수 있습니다.
  * **`placement new`**: 이미 할당된 메모리 공간에 객체를 생성하는 특별한 형태의 `new`입니다. 메모리를 직접 제어해야 하는 임베디드 시스템 등에서 유용하게 사용될 수 있습니다.

`new`와 `delete`가 코드에 직접 노출되는 것은 위험하다고 여겨지지만, 스마트 포인터와 RAII 객체를 사용하면 이들을 직접 호출할 필요가 거의 없어집니다.

-----

## 3\. 템플릿 (Template)

**템플릿**은 C++의 강력한 기능 중 하나로, **타입에 구애받지 않는 일반적인 코드**를 작성할 수 있게 해줍니다. 함수나 클래스를 특정 타입에 종속시키지 않고, \*\*제너릭(generic)\*\*하게 만들 수 있습니다.

### 3.1 템플릿 함수

```cpp
template<typename T>
T Add(T num1, T num2) {
    return num1 + num2;
}
```

위와 같은 템플릿 함수를 작성하면, 컴파일러는 `Add<int>(1, 2)`와 같이 호출될 때, `int` 타입에 맞는 `Add` 함수를 자동으로 생성해 줍니다. 템플릿은 컴파일 단계에서 코드를 복사하고 붙여넣는 방식으로 동작합니다.

### 3.2 템플릿 클래스

```cpp
template<typename T, int len>
class SimpleArray {
private:
    T arr[len];
public:
    T& operator[] (int idx) { return arr[idx]; }
};
```

이처럼 클래스에도 템플릿을 적용할 수 있습니다. \*\*`SimpleArray<int, 5>`\*\*와 \*\*`SimpleArray<int, 7>`\*\*은 컴파일러가 완전히 다른 두 개의 클래스로 간주합니다. 이 때문에 템플릿 클래스 내부에 **`static` 멤버 변수**를 사용할 때는 각 템플릿 인스턴스마다 별도의 `static` 변수가 생성된다는 점을 유의해야 합니다.

### 3.3 템플릿 선언과 정의의 분리

템플릿은 컴파일 시점에 타입이 결정되므로, 일반적으로 **선언과 정의를 같은 헤더 파일(.h)에 함께** 작성하는 것이 일반적입니다. 정의부를 .cpp 파일로 분리하면, 컴파일러가 템플릿 코드를 인스턴스화할 수 없어 링커 오류가 발생하기 쉽습니다.

### 3.4 템플릿 특수화 (Specialization)

특정 타입에 대해 템플릿이 다르게 동작하도록 만들고 싶을 때 **템플릿 특수화**를 사용합니다.

```cpp
// 일반적인 템플릿 함수
template<typename T>
T Max(T a, T b) { return a > b ? a : b; }

// char* 타입에 대한 특수화
template<>
const char* Max(const char* a, const char* b) {
    return strlen(a) > strlen(b) ? a : b;
}
```

위 코드처럼 문자열 포인터(`const char*`)에 대한 `Max` 함수를 특수화하여 문자열 길이(`strlen`)를 기준으로 비교하도록 만들 수 있습니다.

-----

## 4\. C++ 예외 처리

C++의 예외 처리는 `try`, `catch`, `throw` 키워드를 사용합니다.

  * `try`: 예외가 발생할 수 있는 코드를 포함하는 블록입니다.
  * `throw`: 예외를 발생시키는 데 사용합니다.
  * `catch`: `try` 블록에서 발생한 예외를 처리하는 블록입니다.

### 4.1 `throw`와 `stack unwinding`

`throw`가 호출되면, C++ 런타임은 현재 스택 프레임을 순차적으로 \*\*해체(unwinding)\*\*하면서 `catch` 블록을 찾습니다. 이 과정에서 스택에 생성된 **지역 객체의 소멸자**가 모두 호출되어 자원이 안전하게 해제되도록 보장합니다. 이는 운영체제의 구조적 예외 처리(SEH)와 달리 C++ 언어 차원에서 제공되는 중요한 기능입니다.

### 4.2 `noexcept` (예외를 던지지 않는 함수)

\*\*`noexcept`\*\*는 함수가 예외를 던지지 않음을 컴파일러에게 명시적으로 알려주는 키워드입니다.

  * `noexcept`가 붙은 함수에서 예외가 발생하면, C++ 런타임은 `std::terminate()`를 호출하여 **즉시 프로그램을 종료**합니다.
  * 이 키워드를 사용하면 컴파일러가 더 효율적인 코드를 생성할 수 있습니다.
  * **소멸자에는 예외를 던지지 않는 것이 원칙**이므로, 명시적으로 `noexcept`를 붙이는 것이 좋습니다.

### 4.3 예외 처리의 실제 사용

C++ 예외 처리는 논쟁의 여지가 있는 주제입니다.

  * **찬성**: 로직적인 오류(예: 잘못된 입력)를 함수 반환값이 아닌 예외로 처리하면, 함수의 반환값을 오로지 성공/실패 여부에만 집중할 수 있어 코드가 더 명확해집니다.
  * **반대**: 예외를 남발하면 코드를 사용하는 개발자가 매번 `try-catch`로 예외를 처리해야 하므로 코드가 지저분해지고, 예외가 어디서 발생했는지 추적하기 어려워집니다.

일반적으로는 프로그램이 더 이상 정상적으로 진행될 수 없는 **치명적인 상황**에만 `throw`를 사용하는 것이 좋습니다. 예를 들어, 메모리 할당 실패(`bad_alloc`)와 같이 시스템이 곧 멈출 상황에만 예외를 던지고, 대부분의 로직 오류는 함수 반환값이나 `std::optional` 등을 통해 처리하는 것이 현대 C++의 추세입니다.
