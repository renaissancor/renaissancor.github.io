# 1. C 런타임 라이브러리와 실행 파일

Visual Studio에서 프로젝트를 빌드할 때, **C/C++ 런타임 라이브러리**를 어떻게 포함시킬지 선택할 수 있습니다. 이 라이브러리는 `printf`, `cin`, `cout`과 같은 C 및 C++ 표준 라이브러리 함수들의 코드를 포함합니다.

* `/MT` (다중 스레드) & `/MTd` (디버그): **정적 링크(Static Linking)** 방식입니다. 런타임 라이브러리 코드가 최종 실행 파일(`.exe`)에 직접 포함됩니다. 이 때문에 실행 파일의 크기가 커지지만(예: 48KB에서 1.3MB로), 다른 컴퓨터에서 추가적인 DLL 없이 실행 가능합니다.
* `/MD` (다중 스레드 DLL) & `/MDd` (디버그): **동적 링크(Dynamic Linking)** 방식입니다. 런타임 라이브러리 코드가 `.exe`에 포함되지 않고, 별도의 DLL 파일(예: `ucrtbased.dll`)에 존재합니다. 실행 파일의 크기는 작아지지만, 해당 DLL이 없으면 실행되지 않습니다.

#### **왜 DLL을 사용할까?**

DLL(Dynamic-Link Library)은 여러 프로그램이 공유할 수 있는 코드와 데이터를 담고 있는 파일입니다.

1.  **메모리 절약**: 여러 프로세스가 동일한 DLL을 사용하면, 운영체제는 해당 DLL을 메모리에 **한 번만 로드**하고 모든 프로세스가 이를 공유하게 합니다.
2.  **디스크 용량 절약**: 중복되는 런타임 라이브러리 코드가 각 실행 파일에 포함되지 않으므로, 디스크 공간을 효율적으로 사용할 수 있습니다.

이러한 이유로 마이크로소프트는 Visual C++로 개발된 프로그램들이 공통으로 사용하는 DLL들을 **"Visual C++ 재배포 가능 패키지(Redistributable Package)"**로 제공하여, 사용자들이 DLL을 쉽게 설치할 수 있도록 합니다.

---

### 2. 분산 시스템 설계의 목적과 전략

게임 서버를 설계할 때 **분산 시스템**을 고려하는 주된 목적은 크게 두 가지입니다.

1.  **성능 향상 (부하 분산)**: 하나의 서버가 모든 부하를 감당하지 않고, 여러 서버에 작업을 분산하여 처리량을 늘립니다.
2.  **안전성 향상 (고가용성)**: 하나의 서버가 실패하더라도 다른 서버가 계속 서비스를 제공하여 전체 시스템이 중단되는 것을 막습니다. (주로 금융, 통신 등 높은 가용성이 요구되는 분야에서 중요하며, 게임 서버에서는 비용 문제로 인해 드물게 적용됩니다.)

게임 서버에서 분산 설계를 적용하는 주요 방법은 다음과 같습니다.

#### **1. 지역별 분산 (Spatial Partitioning)**

가장 일반적인 분산 방법으로, **월드(World)를 여러 구역으로 나누어 각 서버가 특정 구역을 담당**합니다. 

* **오픈 월드**: 논리적으로 하나의 공간처럼 보이지만, 실제로는 플레이어가 지역 경계를 넘나들 때 서버 간 이동이 일어납니다. 이 때, 서버 간의 데이터 동기화 지연이 발생할 수 있습니다.
* **채널 분리**: 동일한 지역에 사용자가 너무 많이 몰릴 경우, 해당 지역을 여러 개의 "채널"로 분리하여 각 채널이 독립적인 서버에서 운영되도록 합니다. 이는 기술적 해결책보다 기획적인 해결책에 가깝습니다.

#### **2. 기능별 분산 (Functional Partitioning)**

특정 기능을 별도의 서버로 분리하여 부하를 분산하는 방식입니다.

* **예시**: 채팅 서버, 길드 서버, 경매장 서버 등을 메인 게임 서버와 분리합니다.
* **장점**: 특정 기능의 부하가 높아져도 다른 기능에 영향을 주지 않습니다.
* **단점**: 기능 간의 통신(네트워크 지연)이 발생할 수 있고, 로직이 복잡해집니다. 대부분의 게임 로직은 실시간 상호작용이 필수적이어서, 기능 분산의 이점이 크지 않은 경우가 많습니다.

---

### 3. 분산 시스템 설계의 발전

과거에는 하드웨어의 한계(CPU 코어 수, 메모리 용량, 네트워크 트래픽 등) 때문에 서버를 물리적으로 분산하는 것이 필수적이었습니다. 하지만 현대의 하드웨어는 과거의 서버 여러 대를 능가하는 성능을 가지고 있습니다.

* **현재의 추세**: 물리적 서버 분산보다 **단일 고성능 서버 내에서 멀티쓰레딩을 최적화**하는 방향으로 발전하고 있습니다.
* **핵심**: 여러 쓰레드가 데이터를 공유할 때 발생하는 동기화 문제를 최소화하는 **락-프리(Lock-free)** 또는 **데이터 중심 설계(Data-Oriented Design)**와 같은 기술이 중요해졌습니다.

따라서 최신 게임 서버는 **하나의 서버 프로세스(또는 소수의 프로세스) 내에서 최대한 효율적으로 멀티쓰레딩을 활용하는 설계**를 선호합니다. 분산 시스템은 필요에 따라 지역별 분산이나 기능별 분산을 최소한으로만 적용합니다.

---

### 4. 실행파일 변조 (Cracking)

실행 파일의 어셈블리 코드를 직접 수정하여 프로그램의 동작을 변경하는 것을 말합니다.

* **도구**: HxD와 같은 16진수 에디터와 디스어셈블러(Visual Studio의 디버깅 기능 포함)를 사용합니다.
* **방법**:
    1.  프로그램을 실행하고, Visual Studio의 "프로세스에 연결" 기능을 이용해 디버깅 세션을 시작합니다.
    2.  암호 입력 등 원하는 지점에서 프로그램을 일시 중지시키고, 어셈블리 코드를 분석합니다.
    3.  암호를 비교하는 `cmp` 명령어와 다음으로 이어지는 조건 점프(`jne` 등) 명령어를 찾습니다.
    4.  Hex 에디터로 `.exe` 파일을 열고, 해당 조건 점프 명령어를 **무조건 점프(`jmp`)** 명령어로 변경하여 암호 비교를 무력화합니다. 이때 명령어의 바이트 수가 동일해야 파일 구조가 깨지지 않습니다.

이런 변조는 대부분의 바이러스가 과거에 사용하던 방식입니다. 코드를 중간에 삽입하면 상대 주소(relative address)를 사용하는 다른 명령어들의 주소가 모두 밀려 프로그램이 작동하지 않게 되므로, 보통 실행 파일의 끝에 코드를 추가하고 `jmp` 명령어로 해당 코드를 호출하는 방식을 사용했습니다.

이러한 내용들이 게임 서버 개발과 실행 파일 분석에 대한 이해를 돕는 데 도움이 되었기를 바랍니다.