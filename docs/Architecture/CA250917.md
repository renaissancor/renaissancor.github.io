# Operator Overloading


## Impossible operator to overload 

| Operator           | Meaning                  |
| ------------------ | ------------------------ |
| `.`                | Member Access            |
| `.*`               | Member Pointer Access    |
| `::`               | Scope Resolution         |
| `?:`               | Ternary Conditional      |
| `sizeof`           | Object / Type Size       |
| `typeid`           | Runtime Type Information |
| `static_cast`      | Compile-time cast        |
| `dynamic_cast`     | Runtime cast (RTTI)      |
| `reinterpret_cast` | Bitwise cast             |
| `const_cast`       | Remove const/volatile    |

## Overload only for member function 

Few functions MUST be overloaded as class member functions. 
Because their operators are specific classes dependent. 

`=`      Assignment Operator 
`[]`     Array Access Operator 
`()`     Function Call Operator 
`->`     Arrow Operator 
`new`    Class Generation & Memory Allocation 
`delete` Class Termination & Memory Free 

## Expression `new`

When using the `new` expression, it is composed of two steps:
1. Memory allocation using `operator new(sizeof(T))`
2. Constructor call on the allocated memory

```cpp
T* p = new T(args...);
```

This is equivalent to the following:

```cpp
void* mem = operator new(sizeof(T)); 
T *ptr = static_cast<T*> mem; 
ptr->T::T(args...); 
```

```cpp 
operator new(ptr); // ptr = malloc(...); 
ptr->Entity(); // Class Generator Function
```

Suppose you want to reuse the same memory pool:

```cpp
class Entity; 
Entity *p1 = new Entity; 
delete p1; 
p1 = new Entity; 
delete p1; 
```

This code repeatedly allocates and frees memory,
causing unnecessary overhead.

## Placement `new` 

Instead, you can manually manage the memory
and reuse the same address by calling the destructor
and constructor directly.
This is called placement new.

```cpp
Entity *p = (Entity*) operator new (sizeof(Entity)); 
new(p) Entity(); // placement new, call Function Generator 
```

By using placement new,
you allocate and free memory only once,
while reusing the same memory block.

```cpp
class Entity; 
Entity *p1 = (Entity*) operator new(sizeof(Entity)); 
new(p1) Entity(); 
p1->~Entity(); 
new(p1) Entity(); 
p1->~Entity(); 
operator delete(p1); 
```

In game server contents programming, this might be implemented as following. 

```cpp 
ActorPool(size_t n) : capacity(n) {
    pool = static_cast<Actor*>(operator new(sizeof(Actor) * capacity));
}
~ActorPool() {
    for (Actor* actor : activeActors)
        actor->~Actor();
    operator delete(pool);
}
```

In experssion `new`, the `operator new(size_t)` works as calling `malloc(size_t)` internally, and can be overwritten! 
New operator overloading is possible! 

In expresssion `new`, the placement `new(ptr)` calls generator function by using that pointer with NO heap memory allocation 
Placement `new` does not allocate memory, but only call function to allocated space. 

Recursion problem when `operator new override`, if the `new` operator is called inside the generator function of the class. 
So, usage of low level memory allocator like `malloc()` is necessary. 

Memory pooling is basically allocating memory first and reusing it for a while. 
Used previously a lot in the past, nowadays still sometimes but not as much because of hardware performance increase. 

## Memory Leak Detector 

use macro function to overload `operator new(size_t)` and `operator delete` which basically do `malloc(size_t)` and `free` 
to record memory leak efficiently. 

## Memory Leak Track 


### 메모리 누수 확인 및 추적 기법 

메모리 누수는 프로그램의 성능을 저하시키고 불안정하게 만드는 주요 원인입니다. 누수를 효과적으로 추적하기 위해서는 다음의 방법을 사용할 수 있습니다.

#### 1. `new`, `delete` 연산자 오버로딩

전역적으로 `operator new`와 `operator delete`를 오버로딩하여 모든 메모리 할당/해제 요청을 가로챕니다.

* **`#define new` 매크로**:
    * `#define new new(__FILE__, __LINE__)`와 같이 매크로를 정의하여 `new`가 호출될 때 **`__FILE__`** (파일 이름)과 **`__LINE__`** (라인 번호) 매크로를 자동으로 인자로 전달합니다.
    * 이 매크로는 **컴파일 타임에 치환**되므로, 메모리 할당이 발생한 정확한 위치를 기록할 수 있습니다.
* **할당 정보 저장**:
    * `operator new` 내부에서 메모리 주소, 크기, 파일 이름, 라인 번호 등의 정보를 `std::map`이나 리스트와 같은 자료구조에 저장합니다.
    * `uintptr_t`와 같은 타입은 포인터 값을 정수형으로 안전하게 저장할 수 있어 유용합니다.
* **누수 확인**:
    * `delete` 연산자가 호출될 때, 저장된 할당 정보를 찾아서 제거합니다.
    * 프로그램이 종료될 때, 이 자료구조에 남아있는 모든 정보는 **메모리 누수**로 간주됩니다.

#### 2. 단계적 추적

모든 메모리 할당을 로깅하는 것은 성능 저하를 초래할 수 있습니다. 따라서 다음과 같이 단계적으로 추적하는 것이 효율적입니다.

1.  **전반적인 증상 확인**: 프로그램의 실행 시간 동안 **메모리 사용량의 지속적인 증가**를 관찰합니다.
2.  **타겟 선정**:
    * `new/delete` 카운팅 시스템을 도입하여 의심되는 특정 객체(`Player`, `Monster` 등)의 생성/소멸 횟수를 비교합니다.
    * 만약 생성 횟수와 소멸 횟수가 일치하지 않으면 해당 객체가 누수의 원인일 가능성이 높습니다.
3.  **정확한 위치 추적**:
    * `#define new` 매크로와 로깅 시스템을 활용하여 누수가 발생한 객체의 타입, 할당 시점, 그리고 코드 라인까지 찾아냅니다.

---

### `new/delete`와 `malloc/free`의 차이 🔄

`new/delete`와 `malloc/free`는 모두 동적으로 메모리를 할당하고 해제하는 기능을 하지만, 다음과 같은 중요한 차이점이 있습니다.

| 특징 | `new` / `delete` | `malloc` / `free` |
| :--- | :--- | :--- |
| **타입 안전성** | 타입 정보를 기반으로 작동 (타입이 정해짐) | `void*`를 반환하여 명시적인 타입 캐스팅 필요 |
| **생성자/소멸자** | 객체 생성 시 **생성자 호출**, 해제 시 **소멸자 호출** | 생성자/소멸자 호출 기능이 없음 |
| **오버로딩** | 연산자 오버로딩을 통해 재정의 가능 | 함수 재정의가 불가능 |
| **예외 처리** | 메모리 할당 실패 시 `std::bad_alloc` 예외 발생 | 메모리 할당 실패 시 `nullptr` 반환 |
| **언어** | C++ | C |

`new/delete`는 **객체 지향적인 메모리 관리**를 제공하는 반면, `malloc/free`는 **순수한 메모리 관리** 기능만을 수행합니다.

