### 연산자 오버로딩 (Operator Overloading)

연산자 오버로딩은 **클래스 타입의 객체에 대해 C++ 연산자를 재정의**하여 사용하는 기능입니다. 이를 통해 사용자 정의 타입에 대해서도 기본 타입처럼 연산자를 직관적으로 사용할 수 있습니다. 그러나 모든 연산자를 오버로딩할 수 있는 것은 아닙니다.

#### 오버로딩이 불가능한 연산자 🚫

다음 연산자들은 C++ 표준에 의해 오버로딩이 금지되어 있습니다. 이들은 언어의 핵심 문법적 기능에 해당하므로, 의미를 바꾸면 혼란을 초래하기 때문입니다.

* `.` (멤버 접근 연산자)
* `.*` (멤버 포인터 접근 연산자)
* `::` (범위 지정 연산자)
* `?:` (삼항 조건 연산자)
* `sizeof` (크기 계산 연산자)
* `typeid` (타입 정보 연산자)
* `static_cast`, `dynamic_cast`, `reinterpret_cast`, `const_cast` (타입 변환 연산자)

#### 멤버 함수 형태로만 오버로딩 가능한 연산자

일부 연산자는 **반드시 클래스의 멤버 함수로만 오버로딩**해야 합니다. 이는 해당 연산자가 특정 객체에 직접적으로 종속되기 때문입니다.

* `=` (대입 연산자)
* `[]` (배열 접근 연산자)
* `()` (함수 호출 연산자)
* `->` (화살표 연산자)
* `new`, `delete` (메모리 할당/해제 연산자)

---

### `new` 연산자의 내부 동작 🧠

C++의 `new` 연산자는 다음 두 가지 역할을 수행하는 복합적인 연산자입니다.

1.  **메모리 할당 (Operator `new`):**
    * `operator new(size_t)` 함수를 호출하여 필요한 크기만큼의 메모리 공간을 **힙(Heap)**에 할당합니다.
    * 이 함수는 C의 `malloc()`과 유사한 역할을 하며, 재정의가 가능합니다.
2.  **생성자 호출 (Placement `new`):**
    * 할당된 메모리 주소에 대해 **생성자**를 호출하여 객체를 초기화합니다.
    * `placement new`는 메모리 할당을 담당하지 않고, 이미 할당된 공간에 생성자만 호출하는 기능을 합니다.

**재귀적 호출 문제**: `operator new`를 재정의할 때, 내부에서 다시 `new`를 호출하면 재귀에 빠질 수 있습니다. 이를 방지하기 위해 **`malloc()`**과 같은 저수준 메모리 할당 함수를 사용해야 합니다.

현대의 서버 개발에서는 메모리 풀링 기법 대신 `new`와 `delete`를 자유롭게 사용하는 추세입니다. 이는 메모리 단편화 문제가 과거에 비해 줄었고, 오버로딩을 통해 메모리 할당 방식을 전역적으로 제어할 수 있기 때문입니다.

---

### 메모리 누수 확인 및 추적 기법 🕵️‍♂️

메모리 누수는 프로그램의 성능을 저하시키고 불안정하게 만드는 주요 원인입니다. 누수를 효과적으로 추적하기 위해서는 다음의 방법을 사용할 수 있습니다.

#### 1. `new`, `delete` 연산자 오버로딩

전역적으로 `operator new`와 `operator delete`를 오버로딩하여 모든 메모리 할당/해제 요청을 가로챕니다.

* **`#define new` 매크로**:
    * `#define new new(__FILE__, __LINE__)`와 같이 매크로를 정의하여 `new`가 호출될 때 **`__FILE__`** (파일 이름)과 **`__LINE__`** (라인 번호) 매크로를 자동으로 인자로 전달합니다.
    * 이 매크로는 **컴파일 타임에 치환**되므로, 메모리 할당이 발생한 정확한 위치를 기록할 수 있습니다.
* **할당 정보 저장**:
    * `operator new` 내부에서 메모리 주소, 크기, 파일 이름, 라인 번호 등의 정보를 `std::map`이나 리스트와 같은 자료구조에 저장합니다.
    * `uintptr_t`와 같은 타입은 포인터 값을 정수형으로 안전하게 저장할 수 있어 유용합니다.
* **누수 확인**:
    * `delete` 연산자가 호출될 때, 저장된 할당 정보를 찾아서 제거합니다.
    * 프로그램이 종료될 때, 이 자료구조에 남아있는 모든 정보는 **메모리 누수**로 간주됩니다.

#### 2. 단계적 추적

모든 메모리 할당을 로깅하는 것은 성능 저하를 초래할 수 있습니다. 따라서 다음과 같이 단계적으로 추적하는 것이 효율적입니다.

1.  **전반적인 증상 확인**: 프로그램의 실행 시간 동안 **메모리 사용량의 지속적인 증가**를 관찰합니다.
2.  **타겟 선정**:
    * `new/delete` 카운팅 시스템을 도입하여 의심되는 특정 객체(`Player`, `Monster` 등)의 생성/소멸 횟수를 비교합니다.
    * 만약 생성 횟수와 소멸 횟수가 일치하지 않으면 해당 객체가 누수의 원인일 가능성이 높습니다.
3.  **정확한 위치 추적**:
    * `#define new` 매크로와 로깅 시스템을 활용하여 누수가 발생한 객체의 타입, 할당 시점, 그리고 코드 라인까지 찾아냅니다.

---

### `new/delete`와 `malloc/free`의 차이 🔄

`new/delete`와 `malloc/free`는 모두 동적으로 메모리를 할당하고 해제하는 기능을 하지만, 다음과 같은 중요한 차이점이 있습니다.

| 특징 | `new` / `delete` | `malloc` / `free` |
| :--- | :--- | :--- |
| **타입 안전성** | 타입 정보를 기반으로 작동 (타입이 정해짐) | `void*`를 반환하여 명시적인 타입 캐스팅 필요 |
| **생성자/소멸자** | 객체 생성 시 **생성자 호출**, 해제 시 **소멸자 호출** | 생성자/소멸자 호출 기능이 없음 |
| **오버로딩** | 연산자 오버로딩을 통해 재정의 가능 | 함수 재정의가 불가능 |
| **예외 처리** | 메모리 할당 실패 시 `std::bad_alloc` 예외 발생 | 메모리 할당 실패 시 `nullptr` 반환 |
| **언어** | C++ | C |

`new/delete`는 **객체 지향적인 메모리 관리**를 제공하는 반면, `malloc/free`는 **순수한 메모리 관리** 기능만을 수행합니다.

