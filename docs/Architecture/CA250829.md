### 1. 컨텐츠와 코드의 분리: 데이터 중심 설계

게임 개발에서 **스테이지, 적군, 아이템** 등의 컨텐츠 정보는 코드로 하드코딩하면 안 됩니다. 이렇게 되면 컨텐츠를 수정하거나 추가할 때마다 코드를 변경하고 다시 컴파일해야 하기 때문입니다. 이는 비효율적이며, 기획자나 디자이너의 작업 흐름을 방해합니다.

* **해결책**: 모든 컨텐츠 정보를 **외부 데이터 파일**로 분리하여 관리합니다.
    * **스테이지 정보**: `StageInfo.txt`와 같은 파일에 전체 스테이지의 개수와 각 스테이지 파일의 이름을 저장합니다.
    * **개별 스테이지 데이터**: `Stage1.txt`, `Stage2.txt`와 같이 각 파일에 적군의 좌표, 종류, 패턴 등의 상세 정보를 기록합니다.
    * **적군 정보**: `EnemyInfo.txt` 파일에 적군 번호, 체력, 속도, 이동 패턴 등 상세 스펙을 저장합니다.

이를 통해 **코드를 수정하지 않고도** 스테이지를 무제한으로 추가하거나, 게임의 난이도를 조절할 수 있습니다. 

### 2. 게임 루프와 프레임 제어

게임은 일반적으로 **게임 루프(Game Loop)**라는 무한 반복문을 통해 실행됩니다. 이 루프는 한 프레임(Frame) 동안의 **로직(Logic)**, **렌더링(Rendering)**, 그리고 **프레임 제어(Frame Control)**를 처리합니다.

* **로직**: 게임 내 모든 객체의 상태를 업데이트합니다. (예: 캐릭터 이동, 총알 발사, 충돌 처리)
* **렌더링**: 현재 게임 상태를 화면에 그립니다.
* **프레임 제어**: 루프가 너무 빠르게 돌지 않도록 속도를 조절합니다.

#### **프레임 제어의 중요성**

게임을 항상 일정한 속도로 실행하기 위해 **프레임(Frame)**을 제어하는 것이 중요합니다.
* **FPS(Frames Per Second) 측정**: `timeGetTime()`과 같은 함수를 사용하여 매 초마다 몇 프레임이 처리되었는지 계산합니다.
* **슬립(Sleep)과 프레임 오차**: `Sleep()` 함수는 CPU를 쉬게 하여 프레임 속도를 조절하지만, OS 스케줄링의 불확실성으로 인해 정확한 시간만큼 쉬지 않고 더 오래 쉴 수 있습니다. 이 오차가 누적되면 게임이 점점 느려질 수 있습니다.

#### **프레임 의존 vs. 시간 의존 로직**

* **프레임 의존 로직**: 로직이 프레임 수에 직접적으로 의존하는 방식입니다. (예: 매 프레임마다 캐릭터를 10픽셀씩 이동) 프레임이 일정하지 않으면 게임 속도가 달라집니다. 2D 게임에 주로 사용됩니다.
* **시간 의존 로직**: 프레임 수와 관계없이 실제 **경과된 시간**을 기준으로 로직을 처리하는 방식입니다. (예: `경과 시간 * 속도`만큼 캐릭터 이동) 3D 게임의 물리 시뮬레이션에 주로 사용되며, 컴퓨터 성능에 따라 프레임이 달라져도 게임 속도는 일정하게 유지됩니다.

#### **로직과 렌더링 분리**

* 성능이 낮은 컴퓨터에서는 렌더링에 많은 시간이 소요되어 프레임이 떨어질 수 있습니다. 이럴 경우, **렌더링을 건너뛰고** 로직만 여러 번 처리하여 게임 속도를 유지하는 방법을 사용할 수 있습니다. 이렇게 하면 사용자는 화면이 끊기는 것처럼 보일 수 있지만, 게임 로직 자체는 정상적인 속도로 진행됩니다.

### 3. 프로젝트 관리 및 개발 환경

* **파일 구조**: 소스코드(`.cpp`, `.h`), 프로젝트 파일(`.sln`, `.vcxproj`)을 제외한 **중간 빌드 파일(`exe` 등)**은 압축 파일에 포함하지 않도록 주의해야 합니다.
* **디버깅 설정**: VS2022에서 `.vs` 폴더를 포함하여 불필요한 파일이 생성되지 않도록 프로젝트 설정을 관리할 수 있습니다.
* **함수 분리**: 모든 코드를 `main` 함수에 넣지 말고, 씬(Title, Game, GameOver)이나 기능별(적군, 총알 등)로 `.cpp`와 `.h` 파일로 분리하여 관리하는 것이 좋습니다.
* **`exit()` 함수 사용 금지**: `exit()` 함수는 프로그램의 강제 종료를 유발하여 예상치 못한 문제를 일으킬 수 있습니다. 대신 `return`을 사용하여 `main` 함수가 자연스럽게 종료되도록 코드를 작성해야 합니다.