# CPU Cache Memory Simulator 


Cache Architecture 

- Cache Line  = $2^6 = 64$ Bytes 
- Cache Index = $2^6 = 64$  Sets 
- Cache Ways  = (Cache Size) / (Cache Line Size X Sets Num)

Address Composition 

Page Offset = $2^{12} = 4$ KB. 

Virtual Memory to Physical Memory Conversion is through 
**MMU** (Memory Management Unit) and **TLB** 
(Tranlation Lookaside Buffer) is a cache used for 
Mapping Virtual Address to Physical RAM Address. 

Cache Hit Simulator 


### Reasons of Cache Miss and Solution 

Same index collision. 
For instance, every element with 4KB distance will collide. 

Also, too much access to different Cache Lines, 
or variable access not considering spacial locality so much that 
data is not continuous. 

This can be solved by 
decreasing index collision, memory location adjustment 
struct replacement by using `alignas(size_t bytes)`. 

Data Oriented Design (DOD), placing close data nearby, so that it is 
more computer efficient in cache access. 
It is opposite of Object Oriented Programming (OOP) that is human friendly. 

CPU popeline and asynchronous command processing 

CPU Pipeline 5 Steps 
Fetch Decode Execute Write Commit 

Superscalar 
Process several commands simultaneously 
Run 8 instead of 5 steps simultaneously in CPU. 

Out of Order Execution (OoOE) (비순차적 명령어 처리)
CPU execute commands different order of the input 

### Cache Write Policy 

Write Back 

Write on Cache First, than later write on RAM When address is removed from Cache. 

Write Through 

Write on Cache and simultaneously Write on RAM too. 

Modern CPU 
Instruction Cache -> Write Through 
Data Cache -> Write Back 

L1 L2 are Core dependent. 
L3 is shared for Intel, while independent and linked by circuits in AMD 
Cache Synchronization is done by **MESI** Cache Protocol 

- M Modified : Data Changed, not same as RAM 
- E Exclusive : Only in Cache, Same as RAM 
- S Shared : Several Caches accessing, Same as RAM 
- I Invalid : Not valid, not used 

MESI status unit is Cache Line 64 Bytes. 
When multiple cores cache same address, synchronization process happens. 
When Shared Cache Line is Modified by one Core of CPU, 

1. Shared Cache Line is accessed by one CPU Core 
2. Cache Line in Shared State Change into Exclusive State 
3. Other Cache Line Loaded onto other CPU Core L1 L2 Cache became Invalid 
4. Cache is finally written from Core to L3, so turn into Shared State after Writing 

## Simulate Cache Memory 

Calculate Cache Hit and Miss Rates 

Default Info

Modern CPU Cache Memory Status 

Cache Line Size: 64 Bytes 

L1 Inst Cache Size per Core : 32 KB X 8 Ways 
L1 Data Cache Size per Core : 32 KB X 8 Ways 

Testing Environment Check 

Since OS might have context switching, 100% Cache Hit Rate is not possible.
However, Cache Miss Rate 100% is possible. 

```cpp 
#include <iostream>
#include <windows.h>
#include <intrin.h>

using namespace std;

constexpr UINT WAYS_NUM = 8; // 8 ways 
constexpr UINT LINE_SIZE = 64; // 64 bytes 
struct CacheLine 
{
    uintptr_t ptr[WAYS_NUM] = { 0, }; // Pointer 
    __int64 stamp[WAYS_NUM] = { 0, }; // Time Stamp 

    BOOL hit (uintptr_t addr)
    {
        UINT lowest_idx = 0;
        for (UINT i = 0; i < WAYS_NUM; ++i)
        {
            if ((ptr[i] >> 6) == (addr >> 6))
            {
                stamp[i] = __rdtsc(); 
                return TRUE; 
            } 
            else if (stamp[i] < stamp[lowest_idx])
            {   // Less recently used, smallest timestamp 
                lowest_idx = i; 
            }
        }
        ptr  [lowest_idx] = addr; 
        stamp[lowest_idx] = __rdtsc(); 
        return FALSE; 
	}
}; 
```

Based on this Cache Simulator, 
LRU (Least Recently Used) Cache Algorithm Usage is optimized. 
Time measurement was based on `__rdtsc()` value that return `__int64`. 
This function is perfect to measure passed time in process. 

```cpp

class Cache
{
private: 
    CacheLine cache[LINE_SIZE];
    UINT  hit_count[LINE_SIZE] = { 0, }; 
    UINT miss_count[LINE_SIZE] = { 0, }; 

	Cache(const Cache&) = delete; // No copy constructor
	Cache& operator=(const Cache&) = delete; // No assignment operator
    Cache () = default; 
    ~Cache() = default; 

public: 
    static Cache& getInstance()
    {
        static Cache instance;
        return instance;
	}

    void check(uintptr_t addr)
    {
        UINT index = (addr >> 6) & 0x3f; 
        if (cache[index].hit(addr)) hit_count[index]++;
        else miss_count[index]++;         
    }
}; 
```

Cache Simulator was implemented by Singleton Design Pattern.  
Test result is following. 

```shell 
   n =      16, n^2  =     256
Hits =     244, Miss =      12, Ratio = 95.312500
Hits =     256, Miss =       0, Ratio = 100.000000
   n =      32, n^2  =    1024
Hits =    1257, Miss =      23, Ratio = 98.203125
Hits =    1024, Miss =       0, Ratio = 100.000000
   n =      64, n^2  =    4096
Hits =    5057, Miss =      63, Ratio = 98.769531
Hits =    4096, Miss =       0, Ratio = 100.000000
   n =     128, n^2  =   16384
Hits =   20208, Miss =     272, Ratio = 98.671875
Hits =   16384, Miss =       0, Ratio = 100.000000
   n =     192, n^2  =   36864
Hits =   52850, Miss =     398, Ratio = 99.252556
Hits =   36533, Miss =     331, Ratio = 99.102104
   n =     256, n^2  =   65536
Hits =  101261, Miss =    1139, Ratio = 98.887695
Hits =   64463, Miss =    1073, Ratio = 98.362732
   n =     320, n^2  =  102400
Hits =  165332, Miss =    2604, Ratio = 98.449409
Hits =   96800, Miss =    5600, Ratio = 94.531250
   n =     384, n^2  =  147456
Hits =  241949, Miss =    7907, Ratio = 96.835381
Hits =  121809, Miss =   25647, Ratio = 82.607018
   n =     448, n^2  =  200704
Hits =  319356, Miss =   28804, Ratio = 91.726791
Hits =   35647, Miss =  165057, Ratio = 17.760981
   n =     512, n^2  =  262144
Hits =  293706, Miss =  169142, Ratio = 63.456253
Hits =  105603, Miss =  156541, Ratio = 40.284348
   n =     640, n^2  =  409600
Hits =  508715, Miss =  163029, Ratio = 75.730484
Hits =   64839, Miss =  344761, Ratio = 15.829834
   n =     768, n^2  =  589824
Hits =  645327, Miss =  354097, Ratio = 64.569893
Hits =   14187, Miss =  575637, Ratio =  2.405294
   n =     896, n^2  =  802816
Hits =  804318, Miss =  588322, Ratio = 57.754913
Hits =       0, Miss =  802816, Ratio =  0.000000
   n =     960, n^2  =  921600
Hits =  907056, Miss =  817360, Ratio = 52.600765
Hits =     930, Miss =  920670, Ratio =  0.100911
   n =    1024, n^2  = 1048576
Hits = 1032967, Miss =  937209, Ratio = 52.430191
Hits =    6024, Miss = 1042552, Ratio =  0.574493
   n =    1088, n^2  = 1183744
Hits = 1171108, Miss = 1061212, Ratio = 52.461475
Hits =       0, Miss = 1183744, Ratio =  0.000000
   n =    2048, n^2  = 4194304
Hits = 4128429, Miss = 1249619, Ratio = 76.764450
Hits =   37269, Miss = 4157035, Ratio =  0.888562
   n =    4096, n^2  = 16777216
Hits = 16551401, Miss = 4420119, Ratio = 78.923233
Hits =   64309, Miss = 16712907, Ratio =  0.383312
   n =    8192, n^2  = 67108864
Hits =66121214, Miss = 17764866, Ratio = 78.822632
Hits =  109299, Miss = 66999565, Ratio =  0.162868
```


