# C++ params, inline, OOP, etc 

**`auto`** is a C++11 keyword that allows the compiler to automatically deduce the type of a variable from its initializer. It's a convenience that reduces verbose type declarations.

For example, instead of writing:

```cpp
std::vector<int> numbers = {1, 2, 3};
std::vector<int>::iterator it = numbers.begin();
```

You can write:

```cpp
std::vector<int> numbers = {1, 2, 3};
auto it = numbers.begin(); // The compiler deduces 'it' is of type std::vector<int>::iterator
```

While `auto` can make code cleaner, overusing it can make the code less readable, especially when the type is not obvious from the context.

-----

### Function Overloading vs. Overriding

**Function Overloading** occurs when you have multiple functions with the **same name** but different **parameter lists** in the same scope. The compiler decides which function to call based on the number and type of the arguments you provide. The return type is **not** considered for overloading.

```cpp
void print(int i) {
    std::cout << "Printing integer: " << i << std::endl;
}

void print(double f) {
    std::cout << "Printing float: " << f << std::endl;
}

void print(std::string s) {
    std::cout << "Printing string: " << s << std::endl;
}

// Example usage:
print(10);        // Calls print(int)
print(3.14);      // Calls print(double)
print("hello");   // Calls print(std::string)
```

**Function Overriding** is a concept in inheritance where a derived class provides a specific implementation for a function that is already defined in its base class. This typically involves using the `virtual` keyword.

-----

### Default Parameters

A default parameter is a value that a function parameter will take if no argument is specified for that parameter when the function is called.

**Crucially, default parameters are handled at compile time.** The compiler substitutes the default value into the function call, so at runtime, the function always receives a complete set of arguments.

```cpp
int MyFuncOne(int num = 7) { 
    return num + 1; 
}

// Example usage:
MyFuncOne();     // The compiler replaces this with MyFuncOne(7)
MyFuncOne(10);   // The provided argument '10' is used
```

The note about `MyFuncOne()` being called and the function not being able to tell if an argument was passed is correct from a runtime perspective. The default parameter is a **compile-time convenience**, not a runtime choice.

-----

### Inline Functions and Optimization

The `inline` keyword is a **hint** to the compiler to replace the function call with the function's body directly at the point of the call. This can eliminate the overhead of a function call, potentially improving performance.

However, the compiler is not obligated to obey the `inline` keyword. Whether a function is inlined depends heavily on the **compiler's optimization settings**.

  * **Optimization On:** When optimization is enabled (`/O2` in MSVC, `-O2` in GCC), the compiler will automatically decide which functions to inline, often ignoring your explicit `inline` keyword if it deems it's not beneficial.
  * **Optimization Off:** When optimization is turned off (`/Od` in MSVC, `-O0` in GCC), the compiler will generally **not** inline functions, even if you've marked them as `inline`.
  * **Forcing Inlining:** Some compilers offer options to force inlining for functions marked with `inline`, even without full optimization. This is a specific setting you can configure.

The observation that C++ standard library code (like STL) is often designed with `inline` functions is accurate. This is because these functions are often very small (e.g., `vector::size()`) and the overhead of a function call would be significant. However, without optimization, even these functions will not be inlined, leading to slower performance.

-----

### `new`, `delete`, and Memory Management

The relationship between `new`/`delete` and `malloc`/`free` is complex. In C++, `new` and `delete` are operators that handle memory allocation and deallocation.

  * `new int;`
  * `delete p1;`

These operators internally call `malloc` and `free` for raw memory allocation. The key difference is that `new` and `delete` are **object-aware**. When you use `new` for a class object, it not only allocates memory but also calls the object's **constructor**. Similarly, `delete` calls the object's **destructor** before freeing the memory.

The special `delete[]` operator is used to deallocate an array of objects. It's crucial because it iterates through the array and calls the destructor for **each object** before freeing the memory block.

**Incorrect `new`/`delete` usage:**

The notes mention a curious case:

```cpp
int *p1 = new int;
int *p2 = new int[10];

delete [] p1; // Incorrect, 'p1' is not an array
delete p2;    // Incorrect, 'p2' is an array
```

This is **undefined behavior**. While it might *seem* to work on some compilers in specific cases, it's not guaranteed. `delete p2` is particularly dangerous for objects, as it will only call the destructor for the **first element** of the array, leading to resource leaks.

-----

### Encapsulation and Getters/Setters

**Encapsulation** is an object-oriented principle where an object's internal state (its member variables) is hidden from the outside world. Access is controlled through public methods. This prevents external code from putting the object into an inconsistent state.

The notes correctly identify a common pitfall: using simple `get_x()` and `set_x()` methods for every private member often **breaks encapsulation**.

A better approach is to provide methods that describe the **actions** the object can perform.

**Example of a poorly encapsulated `Player` class:**

```cpp
class Player {
private:
    int m_hp;
public:
    int GetHP() { return m_hp; }
    void SetHP(int hp) { m_hp = hp; }
};

// Bad usage: External code controls the logic
Player player;
player.SetHP(player.GetHP() - 10);
```

In this example, the logic for handling damage is **outside** the `Player` class. The `Player` object is just a passive data container.

**Example of a well-encapsulated `Player` class:**

```cpp
class Player {
private:
    int m_hp;
public:
    void TakeDamage(int damage) {
        if (damage > 0) {
            m_hp -= damage;
            // Add internal logic, like checking for death or playing a sound
            if (m_hp <= 0) {
                // Handle death
            }
        }
    }
    bool IsAlive() const {
        return m_hp > 0;
    }
};

// Good usage: The Player object handles its own state change
Player player;
player.TakeDamage(10);
if (player.IsAlive()) {
    // Continue game
}
```

Here, `TakeDamage()` is an action the `Player` object itself performs. The logic is kept within the class, making the code more robust and easier to maintain. The note's point is spot on: if you find yourself writing simple Get/Set functions, you might be treating your class like a `struct` and not fully leveraging object-oriented design.

-----

### Member Initializer List

The **member initializer list** is the preferred way to initialize member variables of a class. It's used in the constructor's definition, before the constructor's body.

**Why use it?**

1.  **Efficiency:** It directly initializes the members. Without it, the member variables are first default-constructed (or left uninitialized for primitive types) and then assigned a value in the constructor body. The initializer list avoids this two-step process.
2.  **Required for `const` members and references:** You **must** use an initializer list for `const` member variables and reference members, as they cannot be assigned a value after they are created.

<!-- end list -->

```cpp
class MyClass {
private:
    int m_value;
    const int m_constant;

public:
    // Using initializer list (preferred)
    MyClass(int val) : m_value(val), m_constant(10) {
        // Body is empty or for additional logic
    }

    // Using assignment (inefficient, and won't work for const/references)
    MyClass(int val) {
        m_value = val;
        // m_constant = 10; // Error: cannot assign to a const variable
    }
};
```

-----

### `const` in Function Declarations

The `const` keyword at the end of a member function declaration (e.g., `int GetX() const;`) is a promise to the compiler that the function will **not modify** any of the object's member variables.

This is extremely useful for two main reasons:

1.  **Safety:** It acts as a compile-time check to prevent accidental modification of an object's state.
2.  **Readability:** It clearly communicates to other developers that the function is an "accessor" or "inspector" that only reads data, not writes to it.
3.  **Use with `const` objects:** You can only call `const` member functions on a `const` object.

<!-- end list -->

```cpp
class Player {
private:
    int m_x;
public:
    int GetX() const {
        // m_x = 100; // Compile Error: cannot modify a member in a const function
        return m_x;
    }
};

void PrintPlayerPosition(const Player& player) {
    // Only const member functions can be called on a const reference
    std::cout << "Player X: " << player.GetX() << std::endl;
}
```

This is also why it's good practice to use `const` references (`const MyClass&`) when passing objects to functions if the function only needs to read the object's data. This avoids the cost of copying the entire object and provides a guarantee that the object won't be modified.