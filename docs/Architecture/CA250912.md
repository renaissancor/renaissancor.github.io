### 1. 전역/정적 변수와 메모리

**전역 변수**는 프로그램이 시작될 때 OS로부터 할당받는 메모리 영역인 `.data`나 `.bss`에 위치하며, **0으로 자동 초기화**됩니다. OS는 보안상의 이유로 새롭게 할당되는 메모리 페이지를 0으로 채우는 정책을 사용하기 때문입니다.

**지역 정적 변수**(`static`)는 해당 변수가 선언된 함수가 **최초로 호출될 때 생성**됩니다. `static int x = GetTickCount();`와 같이 런타임에 초기화되는 경우, 이 초기화 코드는 오직 한 번만 실행되도록 컴파일러가 보장합니다.

**객체 소멸자**의 경우, 전역 객체와 지역 정적 객체는 `main` 함수가 종료될 때 소멸자가 호출됩니다. C++ 컴파일러는 이 기능을 구현하기 위해 내부적으로 C 표준 라이브러리의 `atexit()` 함수를 활용하여, 종료 시 호출할 소멸자 함수 포인터들을 등록합니다.

---

### 2. 비트 필드와 패딩

비트 필드는 구조체나 공용체 내에서 멤버 변수의 메모리 할당을 비트 단위로 제어하는 기능입니다. 이를 통해 메모리를 절약할 수 있지만, CPU 성능을 고려한 메모리 **패딩(Padding)** 규칙은 무시됩니다.

---

### 3. 멀티쓰레드 환경과 동기화

**싱글톤** 패턴은 전역적으로 유일한 객체를 보장하지만, 멀티쓰레드 환경에서는 여러 쓰레드가 동시에 접근하여 객체가 여러 개 생성될 수 있는 문제가 발생합니다. 이를 방지하기 위해 **뮤텍스(Mutex)**를 사용한 락(Lock)이 필요합니다.

**Modern C++**에서는 이러한 문제를 해결하기 위해 `std::call_once`라는 기능을 제공합니다. 이 함수를 사용하면 여러 쓰레드에서 동시에 호출하더라도 특정 코드가 **단 한 번만 실행되도록** 언어 차원에서 보장합니다.

`mutable` 키워드는 `const` 멤버 함수 내에서 특정 멤버 변수를 수정할 수 있게 해줍니다. 예를 들어, `const` 멤버 함수에서 객체의 데이터를 변경할 수는 없지만, 동기화 락을 관리하는 변수에는 `mutable`을 붙여 락을 걸고 해제할 수 있습니다.

---

### 4. 성능 측정: 프로파일러

**프로파일러**는 프로그램의 성능 병목 지점을 찾기 위한 필수적인 도구입니다.

* **시간 측정 함수**: Windows 환경에서는 `QueryPerformanceCounter()`를 사용하여 나노초(nanosecond) 단위의 고해상도 시간을 측정할 수 있습니다. 시스템마다 다른 주파수(Frequency)는 `QueryPerformanceFrequency()`를 통해 얻을 수 있습니다.
    `시간(초) = (종료 시점 틱 - 시작 시점 틱) / 주파수`
    
* **데이터 관리**: 프로파일러는 단순히 시간만 측정하는 것이 아니라, 여러 번의 측정 데이터를 수집하여 통계적으로 분석합니다.
    * **평균값**: 여러 샘플을 통해 안정적인 평균값을 얻는 것이 중요합니다.
    * **최소/최대(Min/Max) 값**: 최초 실행 시 발생하는 **페이지 폴트**나 **캐시 미스**와 같은 예외적인 상황으로 인해 측정값이 크게 튀는 것을 **이상치(Outlier)**라고 합니다. 이러한 값들을 제거하고 평균을 계산해야 더 정확한 성능을 알 수 있습니다.
* **프로파일러 오버헤드**: 프로파일러 코드 자체가 성능 저하의 원인이 될 수 있습니다. 따라서 조건부 컴파일(`#ifdef`)을 사용하여 릴리즈 빌드에서는 프로파일러 코드를 포함하지 않는 것이 좋습니다.

---

### 5. 메모리 관리 기법

프로그램 초반에는 느리더라도, 접속자가 많은 시점에 빠르게 동작하도록 설계하는 것이 중요합니다.

* **메모리 풀(Memory Pool)**: 필요한 메모리를 미리 대량으로 할당해두고, 필요할 때마다 블록을 꺼내 쓰는 방식입니다. 초기 할당 시 오버헤드가 있지만, 이후에는 동적 할당/해제에 비해 매우 빠릅니다.
* **프리 리스트(Free List)**: 객체를 해제할 때 메모리를 OS에 반환하지 않고, '사용 가능한' 리스트에 추가하여 재사용하는 방식입니다. 초기 할당 오버헤드가 풀에 비해 적습니다.

이러한 기법들은 프로그램의 성능을 예측 가능하게 만들고, 갑작스러운 부하 증가에도 안정적인 성능을 유지하는 데 도움을 줍니다.