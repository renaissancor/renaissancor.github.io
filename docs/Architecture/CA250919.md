# operator `new` overload, header, class inheritance 

### 메모리 할당 추적 및 제어

**`new` 연산자 재정의**를 통해 동적으로 메모리를 할당하는 코드 라인을 추적할 수 있습니다. `operator new`를 오버로딩하여 메모리 할당 시점에 파일명, 라인 번호 등을 기록하는 방식입니다.

\*\*`#ifndef`, `#define`, `#endif`\*\*와 같은 전처리기 매크로를 활용해 특정 디버그 모드에서만 이러한 추적 기능을 활성화할 수 있습니다. 예를 들어, 디버그 빌드 시에만 `operator new`를 재정의하는 코드가 포함되도록 하여 릴리스 빌드의 성능 저하를 막을 수 있습니다.

### `operator new` 오버로딩

`operator new`를 오버로딩하여 메모리 누수를 감지하거나, 특정 로깅 시스템과 통합할 수 있습니다. 이 과정에서 `__FILE__`과 `__LINE__` 매크로를 사용하여 메모리가 할당된 소스 코드의 위치를 확보할 수 있습니다.

```cpp
// Macro based function new redefine by macro 
#define new new(__FILE__, __LINE__)

// operator new overloading 
void* operator new(size_t size, const char* file, int line) {
    // Memory Allocation and Free Log Record 
    // ex) std::cout << "Memory allocated at " << file << ":" << line << std::endl;
    return malloc(size);
}
```

이 방식을 사용하면 특정 라인에서 `new` 연산자가 호출될 때마다 추적 정보를 출력하거나 저장할 수 있습니다.

-----

### 헤더 파일 관리 전략

\*\*전방 선언(Forward Declaration)\*\*은 헤더 파일의 의존성을 줄이는 핵심 방법입니다. 전방 선언을 사용하면 클래스나 함수의 선언부만 알면 되므로, 불필요한 헤더를 포함할 필요가 없어집니다.

  * **`#include`는 필요한 최소한으로**: 헤더 파일을 불필요하게 많이 포함하면 컴파일 시간이 길어지고, 헤더 파일 간의 복잡한 의존성으로 인해 유지보수가 어려워집니다. 필요한 클래스의 선언만 전방 선언하고, 실제 정의가 필요한 `.cpp` 파일에서만 해당 헤더를 `include`하는 것이 좋습니다.
  * **헤더 파일에 헤더를 포함하지 않는 연습**: 학습 단계에서는 헤더 파일에서 다른 헤더 파일을 포함하지 않는 것을 목표로 하는 것이 좋습니다. 이는 헤더 파일이 수정될 때마다 이를 포함하는 모든 `.cpp` 파일이 다시 컴파일되는 \*\*`rebuild`\*\*를 방지하는 데 도움이 됩니다.
  * **사용자용 헤더와 내부 구현용 헤더 분리**: 어떤 클래스의 기능을 외부에서 사용하도록 의도하지 않았다면, 해당 함수나 멤버 변수를 선언부에 포함시키지 않는 것이 좋습니다. 이를 위해 내부 구현용 헤더와 사용자용 헤더를 분리하는 디자인 패턴을 사용할 수도 있습니다.

### 클래스 설계와 상속

클래스 설계에서 **`is-a`** 관계와 **`has-a`** 관계를 명확하게 구분하는 것이 중요합니다.

  * **`is-a` (상속)**: 부모 클래스의 모든 특성을 물려받아 **본질적으로 동일한 종류**임을 나타냅니다. (예: **`경찰`** `is-a` **`사람`**)
  * **`has-a` (포함)**: 클래스가 다른 클래스의 객체를 **멤버 변수로 소유**함을 나타냅니다. (예: **`경찰`** `has-a` **`총`**)

**상속은 기능의 업그레이드나 다형성을 위한 목적**으로 사용되어야 합니다. 단순히 기능을 활용하기 위함이라면 상속보다는 포함(멤버 변수로 소유) 관계를 사용하는 것이 더 바람직합니다. 잘못된 상속 설계는 객체 지향 원칙에 위배되며, 코드의 유연성을 떨어뜨립니다.

### 생성자와 소멸자의 호출 순서

클래스 상속 관계에서 생성자와 소멸자는 정해진 순서로 호출됩니다.

  * **생성자**: 부모 클래스부터 자식 클래스 순으로 호출됩니다.
      * `A`를 상속받은 `B` 클래스, `B`를 상속받은 `C` 클래스가 있을 때, `C` 객체를 생성하면 **`A` → `B` → `C`** 순서로 생성자가 호출됩니다. 자식 클래스의 생성자는 자신의 기능을 수행하기 전에 반드시 부모 클래스의 생성자를 먼저 호출합니다.
  * **소멸자**: 생성자와 반대로 자식 클래스부터 부모 클래스 순으로 호출됩니다.
      * **`C` → `B` → `A`** 순서로 소멸자가 호출됩니다. 이 순서는 **`RAII`** 원칙을 효과적으로 구현하는 데 중요합니다.

이러한 규칙 덕분에 기본 생성자나 소멸자가 명시적으로 정의되지 않았더라도, 상속 관계에 있는 클래스는 부모 클래스의 생성자/소멸자를 호출해야 하므로 컴파일러가 암시적으로 생성해 줍니다.