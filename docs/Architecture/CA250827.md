### 1. IPC 통신과 키보드 입력

IPC(Inter-Process Communication)는 여러 프로세스 간에 데이터를 교환하는 메커니즘을 의미하며, 게임 서버 개발에서는 자주 사용되지 않습니다. 서버는 보통 네트워크를 통해 클라이언트와 통신합니다.

키보드 입력의 경우, Windows 환경에서는 `GetAsyncKeyState` 함수를 사용하여 키 상태를 확인합니다. 이 함수는 키가 눌린 순간을 감지하는 **최상위 비트(0x8000)**와 이전 호출 이후 눌린 상태를 유지하는 **최하위 비트** 정보를 반환합니다. 게임의 경우, **렌더링**과 **로직**이 한 프레임을 구성하는데, 렌더링은 시간이 오래 걸려 키 입력이 씹힐 수 있습니다. 따라서 **키가 눌렸는지 여부(값이 0이 아닌지)**를 확인하는 것이 더 안정적입니다.

---

### 2. 프로그래밍 패러다임: 객체지향 vs. 절차지향

* **객체지향(Object-Oriented Programming, OOP)**: **인간 중심**의 사고방식으로, 현실 세계의 객체를 모델링하여 코드를 구성합니다. `class`, `public`, `private` 등의 키워드를 사용하며, **캡슐화(encapsulation)**, **상속(inheritance)**, **다형성(polymorphism)** 등의 특징을 가집니다.
    * **장점**: 코드 재사용성이 높고, 유지보수가 용이하며, 가독성이 좋습니다.
    * **단점**: 초기에 완벽한 설계가 필요하며, 잦은 요구사항 변경에 취약합니다. 특히 게임 컨텐츠처럼 변화가 잦은 분야에서는 객체지향 설계가 무너지기 쉽습니다.

* **절차지향(Procedural Programming)**: **CPU 중심**의 사고방식으로, 위에서 아래로 순차적으로 명령을 실행합니다. `main` 함수에서 시작하여 함수들을 호출하는 방식입니다.
    * **장점**: 디버깅이 쉽고, 로직의 흐름을 한눈에 파악하기 용이합니다.
    * **단점**: 코드 중복이 많아지기 쉽고, 재사용성이 떨어집니다.

게임 서버 개발에서는 **안정성**과 **예측 가능한 성능**이 가장 중요하며, 컨텐츠 추가 및 변경이 잦으므로 **절차지향적 특징**이 강한 코드가 더 선호되기도 합니다.

---

### 3. 게임 서버 개발 관점

* **성능과 메모리**: 클라이언트와 달리, 서버는 메모리 사용량을 엄격하게 관리할 필요가 적습니다. 미리 충분한 공간을 확보하여 동적 할당에 드는 오버헤드를 줄이는 것이 중요합니다. **`std::vector`**와 같은 **배열 기반 컨테이너**는 **`std::list`**보다 순회 성능이 월등히 뛰어나므로, 동시 접속자가 많은 상황에서 훨씬 더 효율적입니다. 
* **안정성과 예측 가능성**: 서버는 예측 불가능한 성능 저하를 일으키는 알고리즘보다는 **일관된 성능**을 제공하는 알고리즘을 선호합니다. 최악의 경우에도 일정한 성능을 보장하는 것이 중요합니다.
* **컨텐츠와 코드 분리**: 게임의 **스테이지, 맵 구성, 아이템 배치 등**은 코드로 하드코딩하지 않고 **외부 데이터 파일**로 분리해야 합니다. 이를 통해 기획자나 디자이너가 직접 컨텐츠를 수정하고 추가할 수 있으며, 개발자는 핵심 엔진 로직에 집중할 수 있습니다.

---

### 4. 과제 수행 팁

* **함수 분리**: `main` 함수에 모든 로직을 넣지 말고, **타이틀, 게임, 게임 오버**와 같은 **씬(Scene)** 별로 함수를 분리하세요.
* **전역 변수**: 컨텐츠 로직을 구현할 때, 전역 변수를 사용하는 것이 함수 호출 시 매개변수를 일일이 전달하는 것보다 효율적일 수 있습니다. 다만, 변수 관리의 어려움에 주의해야 합니다.
* **메모리 관리**: `malloc`이나 `new`를 통해 동적 할당에 실패했을 경우, 즉시 `exit()` 함수를 호출하는 것은 서버의 안정성을 해칠 수 있습니다. 대신 **예외 처리**를 통해 적절한 방식으로 문제를 해결하거나, `return`을 통해 `main` 함수가 안전하게 종료되도록 유도해야 합니다.
* **라이브러리화**: 네트워크 코드와 같은 핵심 기능은 **DLL**과 같은 라이브러리 형태로 분리하여 재사용성과 유지보수성을 높이는 것이 일반적입니다.