# 1\. 비동기 I/O와 `Overlapped I/O`

**비동기 I/O**는 I/O 작업이 완료될 때까지 프로그램의 실행을 멈추지 않고, 다른 작업을 계속 진행할 수 있게 해주는 방식입니다. `Overlapped I/O`는 Windows에서 제공하는 비동기 I/O의 한 형태로, 함수 호출이 즉시 반환(return)되어 프로그램이 블록되지 않습니다.

  * **동기 I/O**: `ReadFile()`과 같은 함수를 호출하면 I/O가 완료될 때까지 함수가 반환되지 않고 대기합니다.
  * **비동기 I/O (`Overlapped I/O`)**: `ReadFile()`을 호출하면 즉시 반환되고, I/O 작업은 백그라운드에서 진행됩니다. 작업이 완료되면 운영체제가 알림(notification)을 보냅니다.
  * **Completion Routine**: `Overlapped I/O`의 완료 알림을 받는 방법 중 하나입니다. I/O 작업이 완료되면, 운영체제는 미리 등록된 콜백 함수(Completion Routine)를 호출합니다.

\*\*코루틴(CoRoutine)\*\*은 `Overlapped I/O`의 **Completion Routine**과 다릅니다. 코루틴은 하나의 함수 내에서 실행을 일시 중지하고 재개할 수 있는 프로그래밍 개념입니다.

-----

### 2\. 메모리 할당: `VirtualAlloc` vs `HeapAlloc`

  * `VirtualAlloc`: **운영체제 수준의 가상 메모리**를 할당하는 Windows API 함수입니다. 주로 대용량 메모리 블록을 할당하거나, 메모리 보호 속성을 세밀하게 제어할 때 사용합니다. 할당과 커밋(commit)을 분리할 수 있어 유연합니다.
  * `HeapAlloc`: C++ `new`나 C의 `malloc`과 유사하게 \*\*프로세스 힙(Heap)\*\*에서 메모리를 할당하는 Windows API 함수입니다. 일반적으로 작은 크기의 메모리를 동적으로 할당하고 해제할 때 사용하며, 사용하기 간편합니다.

-----

### 3\. C++ 캐스팅

C++은 \*\*타입 안전성(Type Safety)\*\*을 높이기 위해 명확한 캐스팅 연산자들을 제공합니다.

  * `static_cast`: **컴파일 타임**에 타입을 변환하며, 기본 타입 간 변환(예: `int`를 `double`로)이나 부모-자식 클래스 간의 **안전한** 포인터 변환에 사용됩니다.
  * `dynamic_cast`: **런타임**에 타입을 변환하며, 주로 다형성을 이용한 부모-자식 클래스 포인터 변환에 사용합니다. 변환에 실패하면 `nullptr`를 반환하므로, 안전하게 다운캐스팅할 수 있습니다.

-----

### 4\. 멀티쓰레딩과 캐시 일관성(Cache Coherency)

멀티코어 시스템에서 각 코어는 자신만의 캐시(L1, L2)를 가집니다. 여러 쓰레드가 동일한 메모리 주소에 접근할 때 **캐시 일관성 문제**가 발생할 수 있습니다. 이를 관리하기 위해 **MESI 프로토콜**이 사용됩니다.

  * **M (Modified)**: 해당 캐시 라인이 수정되었고, 메인 메모리(RAM)와 내용이 다릅니다.
  * **E (Exclusive)**: 해당 캐시 라인이 한 코어에만 있고, 메인 메모리와 내용이 같습니다.
  * **S (Shared)**: 해당 캐시 라인이 여러 코어에 있고, 메인 메모리와 내용이 같습니다.
  * **I (Invalid)**: 해당 캐시 라인이 무효화되어 더 이상 유효한 데이터가 아닙니다.

**제공된 코드 분석**:

이 코드는 **두 변수 `x`와 `y`가 동일한 캐시 라인에 있을 때** (`alignas(64)`가 없다고 가정), 한 쓰레드가 `x`를 수정하면 다른 쓰레드의 `y`에 대한 캐시가 무효화되어 성능이 저하되는 현상을 시뮬레이션합니다.

1.  `testa()` 함수는 `g_point.x`를 계속 수정(Write)합니다.
2.  `testr()` 함수는 `g_point.y`를 계속 읽습니다(Read).
3.  `g_point.x`와 `g_point.y`는 `struct Point` 내에 인접하게 선언되어 있어 **하나의 64바이트 캐시 라인**에 들어갈 확률이 높습니다.
4.  `testa()`가 `g_point.x`를 수정하면, 해당 캐시 라인은 **`M(Modified)` 상태**가 됩니다.
5.  이때 `testr()`가 `g_point.y`를 읽으려 하면, 해당 캐시 라인이 **`I(Invalid)` 상태**가 되어 `testr()`는 캐시 미스(Cache Miss)를 겪게 됩니다.
6.  `testr()`은 L3 캐시나 메인 메모리에서 데이터를 다시 가져와야 하므로, **읽기 작업임에도 불구하고 성능 저하**가 발생합니다.

**코드 개선 및 설명**:

제공된 코드의 `alignas(64)`와 `padding`은 변수 `x`와 `y`를 서로 다른 캐시 라인에 강제로 분리하는 역할을 합니다. 이렇게 하면 `x`의 수정이 `y`에 영향을 주지 않아 `testr()`의 성능이 떨어지지 않는 것을 확인할 수 있습니다.

```cpp
// 가독성을 위해 코드 구조와 변수명을 명확하게 수정합니다.
#include <iostream>
#include <windows.h>
#include <process.h>
#include <chrono>

// alignas(64)를 사용해 x와 y가 다른 캐시 라인에 위치하도록 강제합니다.
struct Point {
    volatile int x;
    alignas(64) volatile int y;
};

Point g_point; // 전역 변수

// 쓰기 전용 쓰레드
static unsigned int __stdcall WriteThread(void*) {
    // CPU 1번 코어에 할당 (2진수 0010)
    SetThreadAffinityMask(GetCurrentThread(), 0x2);

    auto start_time = std::chrono::high_resolution_clock::now();
    
    // 2^20 번 루프를 2^8번 반복
    const size_t outer_loop = 2 << 8;
    const size_t inner_loop = 2 << 20;

    for (size_t i = 0; i < outer_loop; ++i) {
        auto inner_start = std::chrono::high_resolution_clock::now();
        for (size_t j = 0; j < inner_loop; ++j) {
            g_point.x++;
        }
        auto inner_end = std::chrono::high_resolution_clock::now();
        double elapsed_ms = std::chrono::duration<double, std::milli>(inner_end - inner_start).count();
        printf("쓰기(X) 쓰레드: 내부 루프 %.3f ms 소요\n", elapsed_ms);
    }

    auto end_time = std::chrono::high_resolution_clock::now();
    double total_ms = std::chrono::duration<double, std::milli>(end_time - start_time).count();
    printf("쓰기(X) 쓰레드 총 경과 시간: %.3f ms\n", total_ms);
    return 0;
}

// 읽기 전용 쓰레드
static unsigned int __stdcall ReadThread(void*) {
    // CPU 3번 코어에 할당 (2진수 1000)
    // 참고: CPU 0, 1은 Hyper-Threading으로 묶여있을 수 있어 
    // 0x1 (CPU 0), 0x8 (CPU 3)와 같이 떨어뜨려야 정확한 측정이 가능합니다.
    SetThreadAffinityMask(GetCurrentThread(), 0x8); 
    
    auto start_time = std::chrono::high_resolution_clock::now();
    volatile int dummy = 0;
    
    const size_t outer_loop = 2 << 8;
    const size_t inner_loop = 2 << 20;

    for (size_t i = 0; i < outer_loop; ++i) {
        auto inner_start = std::chrono::high_resolution_clock::now();
        for (size_t j = 0; j < inner_loop; ++j) {
            dummy += g_point.y;
        }
        auto inner_end = std::chrono::high_resolution_clock::now();
        double elapsed_ms = std::chrono::duration<double, std::milli>(inner_end - inner_start).count();
        printf("읽기(Y) 쓰레드: 내부 루프 %.3f ms 소요\n", elapsed_ms);
    }
    
    auto end_time = std::chrono::high_resolution_clock::now();
    double total_ms = std::chrono::duration<double, std::milli>(end_time - start_time).count();
    printf("읽기(Y) 쓰레드 총 경과 시간: %.3f ms\n", total_ms);
    return 0;
}

int main() {
    HANDLE hThreads[2];
    hThreads[0] = (HANDLE)_beginthreadex(NULL, 0, &WriteThread, NULL, 0, NULL);
    hThreads[1] = (HANDLE)_beginthreadex(NULL, 0, &ReadThread, NULL, 0, NULL);

    if (hThreads[0] == NULL || hThreads[1] == NULL) {
        printf("Error creating threads: %d\n", GetLastError());
        return 1;
    }

    WaitForMultipleObjects(2, hThreads, TRUE, INFINITE);
    CloseHandle(hThreads[0]);
    CloseHandle(hThreads[1]);

    std::cout << "\n----------------------------------------\n";
    std::cout << "변수 주소 확인:\n";
    std::cout << "g_point.x 주소: " << &g_point.x << std::endl;
    std::cout << "g_point.y 주소: " << &g_point.y << std::endl;
    return 0;
}
```

**수정된 코드의 핵심 변경사항**:

  * **함수명과 변수명**: `testa`와 `testr`을 각각 `WriteThread`와 `ReadThread`로 변경하여 역할이 명확해졌습니다. `dwStart`, `dwEnd` 등도 `start_time`과 같이 C++ 표준 `chrono` 라이브러리를 사용하도록 수정했습니다.
  * **CPU 할당**: `SetThreadAffinityMask`를 통해 쓰레드가 다른 코어에 할당되도록 명시했습니다. `0x2`는 CPU 1번, `0x8`은 CPU 3번을 나타냅니다. 하이퍼쓰레딩이 적용된 코어는 같은 물리적 코어를 공유할 수 있어 성능 측정에 영향을 줄 수 있으므로, `0x1` (CPU 0)와 `0x8` (CPU 3)처럼 물리적으로 분리된 코어에 할당하는 것이 좋습니다.
  * **시간 측정**: `QueryPerformanceCounter`를 사용하여 정밀한 시간을 측정합니다. 코드의 가독성을 높이기 위해 C++11 표준 `chrono`를 사용하는 것이 더 권장됩니다.
  * **`volatile` 키워드**: 컴파일러가 최적화를 위해 변수의 읽기/쓰기 순서를 변경하거나 캐시에 저장된 값만 사용하지 못하도록, `g_point.x`와 `g_point.y`에 `volatile` 키워드를 추가했습니다.

이 코드를 실행하고, `alignas(64)`를 제거한 후 다시 실행해보면 성능 차이를 직접 확인할 수 있습니다. 전자의 경우 두 쓰레드의 성능이 거의 비슷하게 나오지만, 후자의 경우 `ReadThread`의 성능이 현저히 떨어지는 것을 보게 될 겁니다. 이 현상은 **같은 캐시 라인에 대한 쓰기 작업이 다른 쓰레드의 읽기 작업을 무효화(Invalid)시키기 때문에 발생**합니다.

-----

### 5\. `SleepEx`와 `Alertable`

`SleepEx()` 함수는 단순히 지정된 시간만큼 쓰레드를 재우는 `Sleep()`과는 다릅니다. `SleepEx`는 두 번째 인자로 `bAlertable`을 받으며, 이 인자가 `TRUE`일 경우 쓰레드가 대기 상태인 동안 `APC(Asynchronous Procedure Call)`가 큐에 들어오면 즉시 깨어날 수 있습니다. **`Overlapped I/O`의 Completion Routine이 바로 이 `APC`를 이용합니다.** `SleepEx()`는 I/O 작업의 완료를 기다리면서 대기하는 데 유용합니다.