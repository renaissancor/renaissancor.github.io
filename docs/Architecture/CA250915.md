# Template, Try Catch 

이 문서는 C++ 언어의 심층적인 개념들을 다룹니다. **함수 프로파일러 제작 기법**, **문자열 처리의 안정성 문제**, 그리고 **`new/delete` 연산자와 `placement new`의 동작 원리**에 대한 내용을 상세하게 설명하고, 특히 실제 개발 환경에서의 경험과 조언을 포함하고 있습니다.

-----

### 1\. 함수 프로파일러 제작 기법 📊

함수 프로파일러는 프로그램의 성능을 측정하고 병목 현상을 파악하는 데 필수적인 도구입니다. 정밀한 통계를 얻기 위해서는 측정 데이터를 최대한 가공하지 않고 원본 그대로 기록하는 것이 중요합니다.

#### **오프라인 분석 방식**

  * **측정 데이터 기록**: `QueryPerformanceCounter`로 기록된 시작 시간과 종료 시간을 `long long` 타입으로 변환 없이 그대로 저장합니다.
  * **파일 포맷**:
      * **단일 파일**: 함수명, 호출 인덱스, 틱을 하나의 거대한 CSV 파일에 저장합니다.
      * **함수별 파일**: 각 함수별로 별도의 CSV 파일을 생성하고, 호출 인덱스와 틱만 저장합니다.
  * **분석**: 기록된 CSV 파일을 Python의 `Matplotlib` 등 외부 툴을 사용하여 시각적으로 분석합니다. 이 방식은 **정확한 분석**이 가능하지만, **실시간 모니터링은 불가능**합니다.

#### **실시간 모니터링 방식**

  * **전용 스레드**: 실시간 모니터링을 위해서는 별도의 스레드를 생성하여 측정 데이터를 주기적으로 분석하는 것이 일반적입니다.
  * **분석 로직**: C++로 작성된 분석 로직은 제한된 데이터 내에서 실시간으로 연산을 수행해야 합니다. 이 과정에서 발생하는 연산 부하는 서버 성능에 영향을 줄 수 있습니다.
  * **데이터 저장**: **시작 시간과 종료 시간**을 함께 저장하여, 함수 간의 \*\*락 관계(동기화)\*\*를 포함한 시간 흐름을 파악할 수 있도록 데이터를 구성합니다.

#### **멀티스레드 환경의 프로파일링**

멀티스레드 환경에서는 **공유 자원 동기화**가 성능에 큰 영향을 미칩니다. 프로파일러는 락이 걸린 상태(`blocked`), 준비 상태(`ready`) 등을 기록하여 **동기화 중첩 상태**를 파악하는 데 유용합니다. `std::atomic`과 같은 원자적(atomic) 연산을 활용한 동기화 기법은 성능 최적화에 필수적이지만, 초기에는 운영체제(WinAPI)의 원시적인 동기화 API를 먼저 이해하는 것이 좋습니다.

-----

### 2\. 문자열 처리의 안정성: \_s 함수와 UTF-16/UTF-8

C/C++ 표준에서 정의되지 않은 동작(`undefined behavior`)은 프로그램의 예측 불가능한 오류를 야기합니다. 예를 들어, 64비트 정수를 64비트 이상 시프트하는 것 등이 있습니다. 이러한 문제를 피하기 위한 노력이 문자열 처리 API에서 특히 두드러집니다.

#### **\_s (Safe) 함수**

`_s`가 붙은 함수(예: `sprintf_s`)는 버퍼 오버플로우를 방지하기 위해 **버퍼의 크기를 인자로 받습니다**. 버퍼가 넘치면 예외를 발생시키거나 오류 코드를 반환하여 프로그램이 오작동하기 전에 즉시 종료되도록 합니다.

  * **장점**: 버퍼 오버플로우로 인한 메모리 오염을 막아 프로그램의 안정성을 높입니다.
  * **단점**: Microsoft Visual C++ 환경에서 주로 사용되는 **비표준 확장**입니다. Linux의 GCC 컴파일러 등에서는 지원되지 않아 이식성이 떨어집니다.

#### **문자 인코딩: UTF-16 vs. UTF-8**

  * **Windows 환경**: Windows는 내부적으로 **UTF-16**을 사용합니다. 따라서 `wchar_t`를 사용하는 것이 효율적입니다.
  * **Linux/웹 환경**: **UTF-8**이 더 효율적이며, 널리 사용되는 표준입니다.
  * **네트워크 통신**: 네트워크 패킷을 보낼 때, 영어가 많은 경우에는 UTF-8이 효율적입니다. 하지만 한글과 같이 아시아 언어는 UTF-16이 더 효율적일 수 있습니다.

안전한 로그 시스템과 같이 오류가 절대 발생해서는 안 되는 부분에서는 `_s` 함수를 사용하여 버퍼 오버플로우를 즉시 감지하고 프로그램을 종료시키는 것이 장기적으로 더 나은 선택일 수 있습니다.

-----

### 3\. `new/delete` 연산자와 `placement new`의 동작 원리

C++의 `new`와 `delete`는 단순한 메모리 할당/해제 함수가 아닙니다. 이들은 객체의 생성자와 소멸자 호출을 담당하는 복합적인 연산자입니다.

#### **배열과 단일 객체의 `delete` 차이**

  * `new CTest;`로 생성된 단일 객체는 `delete p;`로 해제합니다.
  * `new CTest[10];`으로 생성된 배열 객체는 `delete[] p;`로 해제합니다.
  * **소멸자 유무**: 클래스에 **소멸자**가 정의되어 있을 때 `delete`와 `delete[]`의 차이가 발생합니다.
      * `delete p;`는 소멸자를 한 번만 호출합니다.
      * `delete[] p;`는 배열의 모든 요소에 대해 소멸자를 호출합니다. 이때, C++ 런타임은 `new[]`를 통해 할당된 메모리 맨 앞 4바이트(또는 8바이트)에 **배열의 크기를 숨겨놓고** 이 정보를 이용해 소멸자를 반복적으로 호출합니다.
  * **잘못된 `delete` 사용**: 만약 `new[]`로 할당된 배열을 `delete`로 해제하거나, 그 반대로 하면 **미정의 동작**이 발생합니다. 소멸자 호출 횟수가 잘못되거나, 할당된 메모리 주소가 잘못되어 힙 메모리 오류가 발생할 수 있습니다.

#### **`placement new`**

`placement new`는 이미 할당된 메모리 공간에 객체의 **생성자만 호출**하여 객체를 초기화하는 특별한 연산자입니다.

```cpp
#include <new>
#include <iostream>

char buffer[100]; // 이미 할당된 메모리 공간

// placement new를 사용하여 buffer에 CTest 객체 생성
CTest* p = new(buffer) CTest(); 
```

  * **사용 목적**:
      * **메모리 재사용**: 메모리 풀과 같이 미리 할당된 공간을 재활용할 때 유용합니다.
      * **오버헤드 제거**: `new/delete`의 메모리 할당/해제 오버헤드를 피하고 싶을 때 사용합니다.
      * **수동 초기화**: 소멸자를 수동으로 호출한 후 해당 공간을 다시 초기화하고 싶을 때 사용합니다. (예: `p->~CTest();` 후 `new(p) CTest();`)

`placement new`는 메모리 할당을 담당하지 않고 **생성자 호출만** 담당하기 때문에, 메모리 관리를 직접 해야 합니다. 이 기법은 특히 고성능이 요구되는 게임 엔진이나 임베디드 시스템에서 자주 활용됩니다.