### 캐시 일관성 프로토콜 (Cache Coherence Protocol)

**MESI(Modified, Exclusive, Shared, Invalid) 프로토콜**은 멀티 코어 시스템에서 캐시 간 데이터 일관성을 유지하기 위한 핵심 프로토콜입니다.

* **Modify 상태**: 특정 코어의 캐시 라인이 수정되었으며, 해당 데이터가 **RAM의 데이터와 불일치**하는 상태입니다.
* **다른 코어의 요청**: 만약 다른 코어가 `Modify` 상태의 캐시 라인을 읽거나 쓰려고 요청하면, `Modify` 상태를 소유한 코어는 해당 캐시 라인의 데이터를 **Write Back(램에 다시 쓰기)** 해야 합니다.
* **RAM 쓰기**: 추측하신 대로, `Write Back` 시에는 데이터가 **RAM까지 반드시 쓰여지고** 신호가 오고 나서야 다른 코어의 요청을 처리할 수 있습니다. 이는 시스템의 데이터 일관성을 보장하기 위함이며, 이 과정에서 발생하는 **지연(latency)** 때문에 속도 저하가 발생합니다.

---

### C++에서의 다형성과 캐스팅

**다형성(Polymorphism)**은 하나의 인터페이스나 부모 클래스 포인터로 여러 다른 자식 클래스 객체를 다룰 수 있는 객체 지향의 핵심 원칙입니다.

* **`dynamic_cast`**: 이 연산자는 **런타임에** 객체의 실제 타입을 확인하여 다운캐스팅(부모 클래스 포인터에서 자식 클래스 포인터로 변환)을 수행합니다. 다형성이 깨진 코드(부모 포인터로 자식의 고유 기능을 호출해야 하는 경우)에서 주로 사용됩니다.
* **다형성의 한계**: 게임 개발과 같은 분야에서는 모든 객체에 다형성을 엄격하게 적용하기 어렵습니다. 예를 들어, `GameObject` 클래스를 상속받은 `Player` 객체가 `Sword` 아이템을 장착할 때, `GameObject` 포인터를 통해 `Player`만의 고유한 멤버 함수(`EquipSword`)를 호출해야 하는 경우가 발생합니다. 이럴 때 `dynamic_cast`를 통해 객체의 실제 타입을 확인하고 기능을 호출할 수밖에 없습니다.
* **컴파일 타임 캐스팅**:
    * **`static_cast`**: 컴파일 타임에 타입 변환을 수행하며, 주로 상속 관계에 있는 클래스 간의 변환이나 기본 자료형 변환에 사용됩니다. `dynamic_cast`와 달리 런타임 검사가 없어 더 빠르지만, 안전성이 낮습니다.
    * **`reinterpret_cast`**: 가장 위험한 캐스팅으로, 메모리 주소만 그대로 유지한 채 타입을 강제로 변경합니다. C의 강제 캐스팅과 유사하며, 특정 비트 패턴을 다룰 때 외에는 사용하지 않는 것이 좋습니다.
    * **`const_cast`**: 객체의 상수성(`const`)을 제거하는 데 사용됩니다. `const`로 선언된 객체를 `const`가 아닌 함수에 전달해야 할 때와 같이 예외적인 상황에만 사용해야 합니다.

---

### 디자인 패턴 (Design Pattern) 🎨

디자인 패턴은 소프트웨어 개발에서 특정 문제에 대한 **재사용 가능한 해결책**입니다. 게임 개발에 모든 디자인 패턴을 적용하기는 어렵지만, 몇몇 유용한 패턴은 실무에서 자주 사용됩니다.

#### 1. 싱글톤 패턴 (Singleton Pattern)

클래스의 인스턴스가 프로그램 전체에 **오직 하나만 존재**하도록 보장하는 패턴입니다. 데이터 관리자, 리소스 관리자 등 전역적으로 접근해야 하는 객체에 유용합니다.

* **장점**:
    * 전역 변수처럼 쉽게 접근할 수 있습니다.
    * 객체가 처음 사용될 때 생성되므로 **지연 초기화(Lazy Initialization)**가 가능합니다.
* **단점**:
    * 전역 상태를 만들기 때문에 객체 간 의존성을 숨겨 코드를 복잡하게 만듭니다.
    * 객체의 파괴 시점을 제어하기 어렵습니다. 특히 다른 전역 변수나 싱글톤 객체가 파괴된 후에도 해당 객체를 사용하려고 하면 문제가 발생할 수 있습니다.

#### 2. 옵저버 패턴 (Observer Pattern)

객체 간의 **일대다(One-to-many) 의존성**을 정의하여, 한 객체의 상태가 변경되면 의존하는 모든 객체에 자동으로 알림이 가도록 하는 패턴입니다.

* **폴링(Polling) 방식**: 데이터가 필요한 객체가 주기적으로 생산자에게 데이터를 요청하는 방식입니다. 데이터 유실이 발생할 수 있고, 불필요한 연산이 많습니다.
* **이벤트 방식 (옵저버 패턴)**: 데이터 생산자가 데이터가 준비되었을 때, 등록된 모든 옵저버 객체에 알림을 보내는 방식입니다. 생산자는 옵저버의 구체적인 타입을 알 필요 없이 느슨한 결합(Loose Coupling)을 유지합니다.

#### 3. 커맨드 패턴 (Command Pattern)

요청을 객체로 캡슐화하여 요청의 매개변수화, 로깅, 실행 취소 등을 가능하게 하는 패턴입니다.

* **비동기 처리**: 작업량이 많은 로직을 다른 스레드에 위임할 때, **메시지 큐(Message Queue)**를 사용하여 요청을 전달합니다. 이때, 요청 자체를 하나의 **`Command` 객체**로 캡슐화합니다.
* **장점**:
    * 작업 요청자와 처리자를 분리하여 코드의 유연성을 높입니다.
    * 새로운 커맨드를 추가할 때 기존 코드를 수정할 필요가 없어 유지보수가 용이합니다.

커맨드 패턴은 `switch-case`문으로 모든 작업을 처리하는 방식보다 훨씬 구조적이고 확장성이 뛰어납니다.