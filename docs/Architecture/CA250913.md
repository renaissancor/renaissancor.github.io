# Profiler 

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <windows.h>
#include "Profiler.hpp" // Your profiler header

// Logs data using the vector-based approach
void LogTimeVector(const std::string& func_name, long long elapsed_time) {
    Profiler::Manager::GetInstance().AddProfileVector(func_name, elapsed_time);
}

// Logs data using the hash map-based approach
void LogTimeHashMap(const std::string& func_name, long long elapsed_time) {
    Profiler::Manager::GetInstance().AddProfileHashMap(func_name, elapsed_time);
}

// A generic benchmark function to test both methods
void RunBenchmark(int num_functions, int num_calls_per_function) {
    std::cout << "--- Benchmarking with " << num_functions << " functions and " << num_calls_per_function << " calls each ---\n";

    // --- Test with Vector-based Logging ---
    LARGE_INTEGER start_time, end_time;
    QueryPerformanceCounter(&start_time);
    for (int i = 0; i < num_calls_per_function; ++i) {
        for (int j = 0; j < num_functions; ++j) {
            std::string func_name = "func" + std::to_string(j);
            LogTimeVector(func_name, 123456); // Dummy elapsed time
        }
    }
    QueryPerformanceCounter(&end_time);
    long long vector_elapsed_ticks = end_time.QuadPart - start_time.QuadPart;

    // Clear data for the next test
    Profiler::Manager::GetInstance().ClearData();

    // --- Test with Hash Map-based Logging ---
    QueryPerformanceCounter(&start_time);
    for (int i = 0; i < num_calls_per_function; ++i) {
        for (int j = 0; j < num_functions; ++j) {
            std::string func_name = "func" + std::to_string(j);
            LogTimeHashMap(func_name, 123456);
        }
    }
    QueryPerformanceCounter(&end_time);
    long long hashmap_elapsed_ticks = end_time.QuadPart - start_time.QuadPart;

    std::cout << "Vector Time  : " << vector_elapsed_ticks << " ticks\n";
    std::cout << "Hash Map Time: " << hashmap_elapsed_ticks << " ticks\n\n";
}

int main() {
    // Profiler::InitProfiler() is called by the Manager's constructor
    // You can also call it manually if you don't use the Manager class

    RunBenchmark(1, 1000);

    RunBenchmark(2, 1000);

    RunBenchmark(5, 1000);

    RunBenchmark(1, 10000);

    // Test with small number of functions
    RunBenchmark(10, 1000);

    // Test with a medium number of functions
    RunBenchmark(100, 1000);


    return 0;
}
```

Consequence 

```txt
--- Benchmarking with 1 functions and 1000 calls each ---
Vector Time  : 3002 ticks
Hash Map Time: 2502 ticks

--- Benchmarking with 2 functions and 1000 calls each ---
Vector Time  : 6267 ticks
Hash Map Time: 6564 ticks

--- Benchmarking with 3 functions and 1000 calls each ---
Vector Time  : 8222 ticks
Hash Map Time: 5515 ticks

--- Benchmarking with 4 functions and 1000 calls each ---
Vector Time  : 10906 ticks
Hash Map Time: 10050 ticks

--- Benchmarking with 5 functions and 1000 calls each ---
Vector Time  : 10265 ticks
Hash Map Time: 8779 ticks

--- Benchmarking with 1 functions and 10000 calls each ---
Vector Time  : 14546 ticks
Hash Map Time: 19948 ticks

--- Benchmarking with 10 functions and 1000 calls each ---
Vector Time  : 22580 ticks
Hash Map Time: 17126 ticks

--- Benchmarking with 100 functions and 1000 calls each ---
Vector Time  : 874430 ticks
Hash Map Time: 182758 ticks
```

Shows that clearly hash table is more efficient in larger index than vector. 
Even if the case is small, performance difference seems nearly neglectable, 
and sometimes hash table is even faster than vector based algorithm. 