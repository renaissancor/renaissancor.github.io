# 1\. 메모리 관리: 힙(Heap)과 페이지(Page)

메모리 할당의 기본 단위는 \*\*페이지(Page)\*\*이며, Windows 시스템에서 페이지의 기본 크기는 **4KB**입니다. `VirtualAlloc` 함수는 이 페이지 단위로 메모리를 할당합니다. 하지만 4KB보다 작은 메모리를 자주 할당하면 메모리 낭비가 심해지죠.

  * \*\*힙(Heap)\*\*은 이러한 메모리 낭비를 줄이기 위해 페이지를 더 작은 단위로 쪼개어 관리하는 영역입니다.
  * `HeapCreate()`: **프로세스 전용 힙**을 생성하는 Windows API 함수입니다. `malloc`이나 `new`는 기본 힙(Default Heap)을 사용하지만, `HeapCreate`를 사용하면 개발자가 직접 힙을 생성하고 관리할 수 있습니다.
  * `HeapAlloc()`: 생성된 힙에서 메모리를 할당합니다.
  * `HeapFree()`: 할당된 메모리를 해제합니다.
  * `HeapDestroy()`: 생성된 힙 전체를 파괴하고 메모리를 운영체제에 반환합니다.

결론적으로, **힙도 결국 `VirtualAlloc`에 의존하여 페이지 단위로 메모리를 확보**한 후, 이를 더 작은 단위로 쪼개어 효율적으로 관리하는 것입니다.

-----

### 2\. 고정밀 타이머와 `timeBeginPeriod`

Windows에서 \*\*시간은 하드웨어 인터럽트(Hardware Interrupt)\*\*를 통해 관리됩니다. 특히 \*\*타이머 인터럽트(Timer Interrupt)\*\*는 일정 주기(기본 15.625ms)로 발생하여 운영체제(OS)가 시간을 갱신하고 쓰레드 스케줄링을 할 수 있도록 해줍니다.

  * `GetTickCount()`: OS가 갱신한 시간을 가져오는 함수로, 최소 해상도가 15.625ms입니다.
  * `timeGetTime()`: `timeapi.h`에 선언된 함수로, `timeBeginPeriod()`로 해상도를 조절하여 더 정밀한 시간을 얻을 수 있습니다.

**`timeBeginPeriod(1)`** 함수는 **시스템의 최소 타이머 해상도를 1ms로 변경**하는 역할을 합니다. 이렇게 하면 `Sleep()`이나 `WaitFor...` 계열의 대기 함수들이 더 정밀하게 동작할 수 있습니다.

**`timeBeginPeriod(1)`의 중요성:**

  * `Sleep(1)`을 호출해도 기본 해상도가 15.625ms이므로 실제로는 15ms 이상 대기하게 됩니다.
  * 게임 서버와 같이 프레임 단위(60 FPS = 약 16.7ms)로 로직을 처리하는 경우, `timeBeginPeriod(1)`을 사용해야 정확한 프레임 제어가 가능합니다.
  * 이 함수는 시스템 전체에 영향을 미치므로, 사용 후에는 반드시 `timeEndPeriod()`를 호출하여 원래 해상도로 되돌려야 합니다.

<!-- end list -->

```cpp
#include <iostream>
#include <windows.h>
#include <mmsystem.h> // timeBeginPeriod, timeEndPeriod 헤더

#pragma comment(lib, "winmm.lib") // 라이브러리 링크

void TimerExample() {
    // 1ms 해상도 요청
    timeBeginPeriod(1);
    
    ULONGLONG startTime = GetTickCount64();
    Sleep(10); // 10ms 대기
    ULONGLONG endTime = GetTickCount64();

    std::cout << "timeBeginPeriod(1) 설정 후 Sleep(10) 경과 시간: " << endTime - startTime << "ms" << std::endl;

    // 원래 해상도로 되돌림
    timeEndPeriod(1);
    
    startTime = GetTickCount64();
    Sleep(10); // 10ms 대기
    endTime = GetTickCount64();

    std::cout << "timeBeginPeriod(1) 설정 해제 후 Sleep(10) 경과 시간: " << endTime - startTime << "ms" << std::endl;
}

int main() {
    TimerExample();
    return 0;
}
```

-----

### 3\. 고해상도 타이머: `QueryPerformanceCounter` vs `std::chrono`

`QueryPerformanceCounter`는 **가장 높은 해상도**를 제공하는 Windows API 함수입니다. `QueryPerformanceFrequency()`와 함께 사용하여 CPU 클럭 기반의 정밀한 시간 측정을 가능하게 합니다.

  * **사용 방법**:
    1.  `QueryPerformanceFrequency()`로 1초당 틱(tick) 수를 구합니다.
    2.  `QueryPerformanceCounter()`를 호출하여 시작 시간을 기록합니다.
    3.  `QueryPerformanceCounter()`를 다시 호출하여 종료 시간을 기록합니다.
    4.  두 시간의 차이를 1초당 틱 수로 나누면 경과 시간을 초 단위로 구할 수 있습니다.

**C++11 이후로는 `std::chrono`를 사용하는 것이 더 권장됩니다.** `std::chrono`는 플랫폼에 독립적인 표준 라이브러리로, Windows에서는 내부적으로 `QueryPerformanceCounter`를 래핑하여 사용합니다. 이는 이식성(Portability)을 높여줍니다.

```cpp
#include <iostream>
#include <chrono>

void ChronoExample() {
    auto start = std::chrono::high_resolution_clock::now();
    // 측정할 코드
    for(volatile int i = 0; i < 10000000; ++i);
    auto end = std::chrono::high_resolution_clock::now();

    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    std::cout << "std::chrono 경과 시간: " << duration.count() << " 마이크로초" << std::endl;
}

int main() {
    ChronoExample();
    return 0;
}
```

-----

### 4\. 실행파일 분석 및 크래킹

**디버깅**은 실행 중인 프로세스의 내부 상태를 확인하는 과정입니다. Visual Studio의 **프로세스에 연결(Attach to Process)** 기능을 사용하면 이미 실행 중인 `.exe` 파일에 디버거를 붙여서 내부 코드를 분석할 수 있습니다.

`pdb` 파일은 실행파일과 소스 코드 사이의 매핑 정보를 담고 있어 디버깅을 용이하게 합니다.

**실행파일 크래킹**:

1.  **Hex 에디터 사용**: HxD와 같은 16진수 에디터를 사용해 `.exe` 파일을 직접 엽니다.
2.  **어셈블리 코드 분석**: 실행파일의 어셈블리 코드를 확인하여 조건 분기문(예: `jmp`, `jne`)의 주소를 파악합니다.
3.  **코드 수정**: `jne` (같지 않으면 점프)와 같은 명령어를 `jmp` (무조건 점프)로 변경하여 원하는 로직을 강제합니다.

이러한 분석은 어셈블리 명령어가 \*\*상대 주소(relative address)\*\*를 사용한다는 점을 이해해야 합니다. `call`이나 `jmp` 명령어는 특정 함수나 코드 블록의 절대 주소가 아니라, \*\*현재 명령어의 위치를 기준으로 점프할 오프셋(offset)\*\*을 가집니다. 따라서 명령어의 길이나 위치가 변경되면 모든 상대 주소를 다시 계산해야 하므로 매우 조심해야 합니다.