## C++ 런타임 라이브러리 및 DLL

* **런타임 라이브러리**: C/C++ 코드를 컴파일하면 언어의 기본 기능을 수행하는 런타임 라이브러리 코드가 함께 포함됩니다. 이는 파일 입출력(`cin`, `cout`), 메모리 관리(`new`, `delete`) 등 기본적인 기능을 제공합니다.
* **정적 라이브러리(Static Library)**: 빌드 시 런타임 라이브러리 코드를 실행 파일(`.exe`)에 직접 포함하는 방식입니다.
    * **장점**: 실행 파일 하나만으로 독립적인 실행이 가능해 배포가 용이합니다.
    * **단점**:
        * **파일 크기 증가**: 실행 파일의 크기가 커집니다.
        * **메모리 낭비**: 여러 프로그램이 동일한 런타임 라이브러리를 사용해도 각 프로그램이 메모리에 별도의 복사본을 로드하므로 메모리 낭비가 발생합니다.
* **동적 라이브러리(DLL, Dynamic Linked Library)**: 런타임 라이브러리 코드를 `.dll` 파일로 분리하고, 실행 시점에 동적으로 연결하는 방식입니다.
    * **장점**:
        * **파일 크기 감소**: 실행 파일의 크기가 작아집니다.
        * **메모리 절약**: 여러 프로세스가 동일한 DLL을 공유하므로 메모리를 효율적으로 사용할 수 있습니다.
    * **단점**: 실행하려는 컴퓨터에 해당 DLL이 없으면 실행되지 않습니다. 이를 해결하기 위해 **Visual Studio 재배포 패키지**가 제공됩니다. 

---

## 게임 서버 분산 설계

* **분산 시스템의 목적**:
    1.  **성능 향상**: 여러 컴퓨터나 프로세스가 작업을 분담하여 전체적인 처리량을 늘립니다.
    2.  **안전성 향상**: 하나의 시스템이 장애가 나더라도 다른 시스템이 서비스를 계속하여 서비스의 가용성(Availability)을 높입니다.

* **게임 서버 분산 방식**:
    * **논리적 분산 vs. 물리적 분산**: 서버를 논리적인 프로세스로 분리하거나(동일 컴퓨터 내), 물리적으로 다른 컴퓨터에 분산할 수 있습니다.
    * **지역별 분산**:
        * 오픈 월드 게임과 같이 넓은 맵을 여러 서버로 분할하여 각 서버가 특정 지역을 담당합니다.
        * 유저가 맵의 경계를 넘어가면 다른 서버로 이동(핸드오버)하는 방식입니다.
        * 서버 간 통신이 발생할 수 있지만, 일반적으로 실시간 상호작용은 어렵고 느슨한 동기화만 이루어집니다.
    * **기능별 분산**:
        * 채팅, 길드, 몬스터 AI 등 특정 기능을 분리하여 전용 서버에서 처리하는 방식입니다.
        * 게임 서버의 부하를 줄일 수 있지만, 비동기 처리를 위한 복잡한 설계가 필요합니다.
        * `Overlapped I/O`와 같이 네트워크 통신을 비동기적으로 처리하는 기술이 필요합니다.

* **현대 게임 서버의 특징**:
    * **하드웨어 발전**: 과거에는 CPU 코어 수, 메모리 용량, 네트워크 대역폭의 한계로 분산 서버 설계가 필수적이었지만, 지금은 하드웨어 성능이 크게 향상되어 한 대의 서버로 더 많은 사용자를 수용할 수 있습니다.
    * **싱글 스레드 한계**: 대부분의 게임 서버 로직은 실시간 상호작용으로 인해 공유 자원을 많이 사용하므로, 멀티스레드 병렬 처리가 어렵습니다. 이로 인해 CPU 코어의 잠재력을 100% 활용하기 어렵습니다.
    * **단일 서버의 효율성**: 가능하면 단일 서버 컴퓨터에서 모든 것을 처리하는 것이 관리와 개발의 복잡성 측면에서 가장 효율적입니다.
    * **채널 시스템**: 동시 접속자 수(동접)가 한 서버의 한계를 초과할 때, 동일한 월드를 여러 개 복제하여 운영하는 방식입니다. 이는 기술적인 한계를 극복하기 위한 기획적인 해결책입니다.