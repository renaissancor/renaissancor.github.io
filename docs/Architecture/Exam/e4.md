저번 문제들에 대한 답변 잘 봤습니다. 1, 3, 4번은 정답이 맞습니다. 하지만 2번과 5번 문제에서 아쉬운 부분이 있네요. 2번의 정답은 a가 아니라 c입니다. 최적화 컴파일러가 오류를 사전에 예측하여 무시하기 때문에 덤프에 정보가 남지 않는다는 것이 가장 적절한 설명입니다. 또한, 5번의 경우 `unsigned char`라면 255(`0xFF`)가 맞습니다. 보수법은 부호 있는 정수(signed)에서만 적용되기 때문이죠.

아쉽지만, 다음에 더 좋은 기회가 있을 거예요. 이번에는 다음 챕터의 내용들을 바탕으로 퀴즈를 내겠습니다. 기존에 다루었던 용어와 개념을 중심으로 문제를 만들었으니 편안하게 풀어보세요.

---

### **정리된 퀴즈**

다음은 250714 수업 내용을 바탕으로 핵심 개념을 확인하는 문제입니다.

1.  **CISC 대 RISC**에 관련된 문제입니다. 현대 CPU 아키텍처는 **CISC(Complex Instruction Set Computer)**와 **RISC(Reduced Instruction Set Computer)** 두 가지로 나뉩니다. 다음 중 **x86-64 아키텍처**와 가장 관련이 깊은 것은 무엇인가요?
    a) 명령어 길이가 고정되어 있어 단순하고 전력 효율이 높습니다.
    b) 명령어 세트가 복잡하고 다양하며, 명령어 길이가 가변적입니다.
    c) 마이크로프로세서가 아닌 마이크로컨트롤러에 주로 사용됩니다.
    d) ARM 아키텍처의 주된 특징으로, 모바일 기기에 주로 탑재됩니다.

2.  **보수(Complement)**에 관련된 문제입니다. 컴퓨터가 **2의 보수법**을 사용하는 주된 이유로 가장 적절한 것은 무엇인가요?
    a) 복잡한 뺄셈 연산을 덧셈 연산으로 간단하게 처리하기 위함입니다.
    b) 음수와 양수의 범위를 동일하게 만들어 연산의 정확성을 높이기 위함입니다.
    c) `0`의 표현을 하나로 통일하여 메모리 낭비를 막기 위함입니다.
    d) 10진수와 이진수 간 변환을 효율적으로 처리하기 위함입니다.

3.  **오버플로우**에 관련된 문제입니다. `signed char a = 127;`일 때, `a = a + 1;`을 하면 `a`의 값은 **`-128`**이 됩니다. 이 현상과 관련이 깊은 것은 무엇인가요?
    a) 부호 비트가 양수에서 음수로 변경되면서 가장 낮은 값으로 순환하기 때문입니다.
    b) C/C++ 표준에서 오버플로우가 발생할 경우, 값의 범위를 벗어나지 않도록 강제하기 때문입니다.
    c) 컴파일러가 오버플로우를 감지하고 자동으로 값을 재조정하기 때문입니다.
    d) `char` 타입은 오버플로우가 발생하면 항상 `-1`로 초기화되는 규칙이 있기 때문입니다.

4.  **C/C++ 타입**에 관련된 문제입니다. 64비트 윈도우 환경에서 `long` 타입의 변수와 `long long` 타입의 변수를 선언할 때, 이 둘의 크기가 달라지는 이유와 가장 관련이 깊은 것은 무엇인가요?
    a) 64비트 시스템의 **데이터 모델**이 컴파일러마다 다르기 때문입니다.
    b) **OS**와 **컴파일러**가 `long`의 크기를 32비트(4바이트)로, `long long`의 크기를 64비트(8바이트)로 다르게 정의했기 때문입니다.
    c) **C++11 표준**에서 `long`과 `long long`의 크기를 다르게 명시했기 때문입니다.
    d) 64비트 CPU의 레지스터 구조가 `long`과 `long long`의 크기를 다르게 처리하기 때문입니다.

---
**정답 및 해설**

1.  **정답: b)** x86-64는 CISC 아키텍처에 속합니다. CISC는 복잡하고 다양한 명령어 세트를 가지고 있어 하나의 명령어로 여러 작업을 수행할 수 있습니다. 명령어의 길이도 가변적이어서, 명령어를 해석하는 과정이 복잡합니다.

2.  **정답: a)** 2의 보수법을 사용하는 가장 큰 이유는 컴퓨터가 덧셈만을 사용하여 뺄셈을 효율적으로 처리하기 위함입니다. `A - B` 연산을 `A + (-B)`로 바꾸고, `-B`를 2의 보수로 변환하여 덧셈을 수행하면 하드웨어적으로 훨씬 간단하고 빠르게 연산할 수 있습니다.

3.  **정답: a)** `signed char`는 8비트를 사용하며, 최상위 비트는 부호를 나타냅니다. `127`은 이진수로 `01111111`이며, 여기에 1을 더하면 `10000000`이 됩니다. 2의 보수법에서 이 값은 `-128`을 의미합니다. 즉, 양수의 최댓값에서 1을 더하면 부호 비트가 바뀌면서 음수의 최솟값으로 **순환**하는 것입니다.

4.  **정답: b)** 64비트 윈도우 환경은 **LLP64 데이터 모델**을 따릅니다. 이 모델은 OS와 컴파일러가 `long` 타입을 32비트로, `long long` 타입을 64비트로 정의했습니다. 따라서 `long`은 4바이트, `long long`은 8바이트 크기를 가집니다. 이는 리눅스와 macOS의 **LP64 데이터 모델**과 다른 점입니다. 