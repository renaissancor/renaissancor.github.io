# 메모리 관리 및 성능 최적화

## 스레드 풀과 스레드 상태
* **스레드 풀:** 미리 여러 개의 스레드를 만들어 놓고 필요할 때 사용하고, 작업이 끝나면 파괴하지 않고 다시 풀에 넣어 재사용하는 방식입니다. 스레드 생성과 파괴에 드는 오버헤드를 줄여 성능을 향상시키는 데 목적이 있습니다.
* **스레드 블로킹:** 스레드가 작업을 하다가 잠시 쉬는 상태를 의미합니다. CPU를 사용하지 않고 대기하는 상태로, I/O 작업이나 동기화 등을 기다릴 때 발생합니다.

---

## 재귀 함수와 반복문(스택/큐)
재귀 함수는 코드가 간결하고 가독성이 좋지만, 함수 호출 스택을 많이 사용하고 함수 호출 자체에 오버헤드가 발생할 수 있습니다. 반면, 스택이나 큐를 사용한 반복문은 함수 호출 오버헤드가 적어 성능 면에서 유리합니다.

* **재귀 함수의 예외 처리:** 함수를 호출하기 전에 예외 처리를 하면 불필요한 함수 호출을 줄일 수 있어 성능 향상에 도움이 됩니다.
* **현업에서의 우선순위:** 일반적으로 **가독성**과 **유지보수**가 성능보다 우선시됩니다. 버그가 적고 이해하기 쉬운 코드를 지향합니다. 다만, 성능이 중요하게 요구되는 특정 구간(예: 게임 엔진, 고성능 컴퓨팅 등)에서는 성능 최적화가 1순위가 될 수 있습니다.

---

## 성능 측정 방법
정확한 CPU 성능 측정을 위해서는 1밀리초(ms)보다 더 정밀한 **마이크로초(μs)** 또는 **나노초(ns)** 단위의 측정이 필요합니다.

* **WINAPI 함수:**
    * `GetTickCount()`: 시스템이 시작된 후 경과된 시간을 1ms 단위로 반환합니다. 갱신 주기는 보통 10~16ms이므로 정밀한 측정에는 적합하지 않습니다.
    * `QueryPerformanceCounter()`: CPU의 고성능 카운터를 사용하여 매우 정밀한 시간 측정을 할 수 있습니다.

* **정확한 측정을 위한 유의사항:**
    * **외부 영향:** 운영체제의 멀티태스킹으로 인해 측정값에 편차가 발생할 수 있습니다.
    * **샘플링:** 정확한 값을 얻기 위해 수십만, 수백만 번 반복하여 측정하고 **평균값**을 구하는 것이 현실적인 방법입니다.
    * **측정 대상:** 전체 소요 시간(`총 시간 / 횟수`)을 측정하여 한 번의 연산 시간을 구하는 방법이 효과적입니다.

**과제:** 재귀 버전과 스택/큐 버전의 성능을 직접 측정하여 비교하고, 예상과 다르다면 그 이유를 분석하고 최적화 방안을 모색해야 합니다.

---

## 메모리 관리 관련 개념

### 구조체 패딩
CPU가 메모리에 접근할 때 효율을 높이기 위해 컴파일러가 구조체 멤버 사이에 **바이트를 채워 넣는** 현상입니다. 

### 공용체(Union)
하나의 메모리 공간을 여러 멤버 변수가 **공유**하는 자료구조입니다. 가장 큰 멤버 변수의 크기만큼 메모리가 할당됩니다. 주로 메모리를 절약하거나, 같은 메모리를 다른 형식으로 해석할 때 사용됩니다.

### 비트필드(Bitfield)
구조체 멤버 변수의 크기를 **비트 단위**로 지정하는 방법입니다. 메모리 절약에 효과적이지만, 코드가 직관적이지 않아 비트 연산자를 직접 사용하는 경우가 더 흔합니다.

### Typedef
자료형에 새로운 이름을 부여하는 키워드입니다. WINAPI에서 `DWORD`, `BOOL` 등 언어에 독립적인 자료형을 정의하는 데 사용됩니다. 가독성 향상과 이식성 확보를 위해 사용되지만, C++에서는 가급적 표준 자료형을 사용하는 것이 좋습니다.

---

## 동적 할당과 메모리

### 동적 할당 함수
* `malloc`, `calloc`, `realloc`: C언어의 동적 할당 함수들입니다. `calloc`은 할당된 메모리를 0으로 초기화하는데, 이 과정이 비효율적이므로 꼭 필요한 경우가 아니면 `malloc`을 사용하고, 초기화가 필요하면 `memset`이나 특정 값만 설정하는 것이 좋습니다.
* `realloc`: 기존 메모리 블록의 크기를 변경하는 함수입니다. 실제로는 **새로운 메모리 공간을 할당**하고 기존 데이터를 복사한 후 이전 메모리를 해제합니다.

### 메모리 오류
* **메모리 해제 오류:** `malloc`으로 할당받은 포인터의 시작점이 아닌 곳을 `free`하면 힙 에러가 발생합니다.
* **댕글링 포인터(Dangling Pointer):** `free`로 메모리를 해제한 후에도 해당 포인터가 메모리 주소를 가리키고 있는 상태를 말합니다. 이 포인터로 접근하면 예상치 못한 오류가 발생할 수 있습니다.

---

## 가상 메모리 시스템

CPU는 **가상 메모리** 개념을 통해 실제 물리 메모리(RAM)를 효율적으로 관리합니다.

* **페이지(Page):** 운영체제가 메모리를 관리하는 최소 단위입니다. 일반적으로 **4KB** 크기입니다. 동적 할당 시 1바이트를 요청하더라도 최소 4KB 페이지가 할당됩니다.
* **힙(Heap):** 가상 메모리 공간에서 페이지를 나누어 사용하고 재활용성을 높여 메모리를 효율적으로 관리하는 개념입니다.
* **메모리 누수 판단:** 메모리 누수 여부는 **커밋 크기**를 통해 확인해야 합니다. 커밋 크기는 프로세스가 운영체제에 할당받은 가상 메모리 양을 의미하며, 이 수치가 지속적으로 늘어나면 메모리 누수를 의심할 수 있습니다. 활성 메모리(물리 메모리에 상주하는 양)는 운영체제가 사용하지 않는 메모리를 디스크로 옮기면 줄어들 수 있으므로 누수의 지표가 되기 어렵습니다.