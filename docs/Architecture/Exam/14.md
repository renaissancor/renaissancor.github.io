## 메모리 할당과 타이머 해상도

### 가상 메모리 할당 (VirtualAlloc)

* **`VirtualAlloc`**: 운영체제 수준에서 메모리를 관리하는 가장 기본적인 WinAPI 함수입니다. **페이지 단위(4KB)**로 메모리를 할당하거나 해제합니다.
* **낭비 문제**: 4KB보다 작은 메모리(예: 1바이트)를 할당할 때도 4KB 전체를 할당해야 하므로 메모리 낭비가 심합니다.
* **힙(Heap)의 역할**: `malloc`이나 `new`와 같은 함수는 `VirtualAlloc`에 의존하여 동작합니다. 힙 관리자는 4KB 단위로 할당된 가상 메모리 공간을 더 작은 블록으로 나누어 효율적으로 관리합니다.
* **힙 생성**: `HeapCreate`, `HeapAlloc`, `HeapFree`, `HeapDestroy` 등의 함수를 사용하여 별도의 힙을 생성하고 관리할 수 있습니다.

---

### 타이머 해상도와 대기 함수

* **하드웨어 인터럽트**: CPU가 예측할 수 없는 순간에 발생하는 외부 신호입니다. 시간(Timer)은 0번 타이머 인터럽트를 통해 OS가 인식합니다.
* **타이머 해상도**: OS가 시간을 인식하는 최소 단위입니다. Windows의 기본 타이머 해상도는 **15.625ms**입니다.
* **`timeBeginPeriod()`**: 이 함수를 사용하여 타이머 해상도를 더 정밀하게 설정할 수 있습니다. 예를 들어, `timeBeginPeriod(1)`을 호출하면 해상도를 **1ms**로 낮출 수 있습니다. 이는 대기 함수(`Sleep`, `WaitForSingleObject` 등)의 정확도를 높이지만, 시스템 성능 저하를 일으킬 수 있습니다.
* **`timeEndPeriod()`**: `timeBeginPeriod()`로 변경한 타이머 해상도를 원래대로 되돌리는 함수입니다.
定 `timeBeginPeriod`와 쌍으로 호출하여 시스템 리소스를 효율적으로 관리해야 합니다.
* **대기 함수**: CPU를 계속 사용하지 않고 특정 시간 동안 스레드를 블로킹(Blocking) 상태로 만들어 CPU 점유율을 낮추는 함수입니다. `Sleep` 함수는 타이머 해상도에 따라 실제 대기 시간이 달라질 수 있습니다.

---

### 성능 측정과 최적화

* **시간 측정 함수**:
    * `GetTickCount()`: 시스템 부팅 후 경과된 시간을 15.625ms 단위로 반환합니다. `GetTickCount64()`는 오버플로우 문제가 없어 장시간 동작하는 서버에 적합합니다.
    * `timeGetTime()`: `timeBeginPeriod`로 설정한 해상도를 따라 시간을 반환합니다.
    * `QueryPerformanceCounter()`: CPU의 고성능 카운터를 사용하여 매우 정밀한 시간을 측정합니다.
    * `std::chrono`: C++ 표준 라이브러리로, 플랫폼에 관계없이 높은 정밀도의 타이머를 제공합니다.
* **성능 분석**:
    * **뺑뺑이 루프 방지**: 대기 함수 없이 무한 루프를 돌면 CPU를 100% 점유하여 전력 소모와 발열을 유발하고, 다른 프로그램의 성능에 악영향을 줍니다.
    * **FPS와 타이머**: 게임 프레임 제어는 `timeBeginPeriod()`로 타이머 해상도를 낮춰 정확한 프레임 간격을 유지하는 방식으로 이루어집니다. 예를 들어, 60FPS를 목표로 할 때 1프레임 간격(16.6ms)을 정확하게 맞추기 위해 타이머 해상도를 1ms로 설정합니다.

---

### 실행파일 분석 및 크래킹

* **디버거 사용**: Visual Studio의 디버거(Ctrl+Alt+P)를 사용하여 실행 중인 프로세스에 연결하면, 소스 코드가 없어도 어셈블리어와 메모리를 볼 수 있습니다.
* **실행파일 수정**:
    1.  **Hex Editor**: **HxD**와 같은 16진수 에디터를 사용하여 실행파일(`.exe`)을 직접 열고 수정합니다.
    2.  **어셈블리어 분석**: 디스어셈블러를 통해 실행파일의 어셈블리 코드를 분석하여 특정 로직(예: 비밀번호 검증)을 찾습니다. `call`, `jmp`, `je` 등의 명령어는 **상대 주소**를 사용하므로 명령어의 위치를 변경하면 코드가 엉망이 될 수 있습니다.
    3.  **크래킹**: 비밀번호 검증 루틴의 `jne`(같지 않으면 점프) 명령어를 `je`(같으면 점프)로 수정하여 항상 통과하도록 로직을 변경합니다.

* **과제**:
    * **과제 1**: 주어진 실행파일 2개의 어셈블리어 분석을 통해 특정 계산식이나 로직을 파악하세요.
    * **과제 2**: 비밀번호를 입력받는 실행파일을 수정하여, 입력값과 상관없이 항상 비밀번호 검증이 통과하도록 만들어 보세요.