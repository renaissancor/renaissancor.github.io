# 핵심 요약: 운영체제, 컴파일러 및 어셈블리 

### 1. 운영체제와 스레드

* **PCB/TCB**: 운영체제의 CPU 자원(하드웨어적 스레드) 할당은 항상 소프트웨어 스레드 단위로 이루어집니다.
* **스택 메모리**: 스택은 함수 호출 시 지역 변수를 저장하며, `esp`(스택 포인터)를 조정하여 공간을 확보합니다.
    * `esp`를 이용한 공간 확보는 오직 지역 변수와 컴파일러가 자체적으로 필요하다고 판단하는 정보에만 사용됩니다.
* **스택 오버플로우**: 스택의 기본 크기(Windows 기준 1MB)를 초과하면 발생합니다.

***

### 2. 컴파일러와 링커

* **컴파일 과정**: 소스 코드는 **전처리 → 컴파일(어셈블리어 변환) → 링킹** 과정을 거쳐 실행 파일이 됩니다. 이 단계들을 이해하면 에러의 원인(전처리, 컴파일, 링킹 에러)을 파악하는 데 도움이 됩니다.
* **컴파일 언어 vs. 스크립트 언어**:
    * **컴파일 언어(C/C++)**: 기계어로 변환되어 독립적으로 실행되는 파일(.bin)을 생성합니다.
    * **스크립트 언어(JavaScript, Python 등)**: 가상 머신(VM)이나 인터프리터 위에서 한 줄씩 실행됩니다.

***

### 3. 어셈블리어 심화

* **레지스터**: CPU 내부에 있는 고속 메모리로, 연산은 레지스터에 있는 값으로만 가능합니다.
    * `ebp`(베이스 포인터): 현재 스택 프레임의 시작 주소
    * `esp`(스택 포인터): 현재 스택의 최상단 주소
    * `ecx`: 반복문 카운터
    * `eax`, `esi`, `edi`: 범용 레지스터
* **`rep stos`**: `ecx`에 있는 횟수만큼 `edi` 주소를 `eax` 값으로 채우는 반복문 명령어입니다.
* **메모리 값**: 디버그 모드에서는 초기화되지 않은 메모리 공간이 `0xcccccccc` (스택) 또는 `0xdddddddd` (힙)와 같은 특정 값으로 채워져 디버깅을 돕습니다.

***

### 4. 메모리 구조와 변수

* **메모리 영역**: 프로그램은 **코드(Code), 읽기 전용(Read-only), 데이터(Data), 스택(Stack), 힙(Heap)** 영역으로 나뉩니다.
* **전역 변수**:
    * **초기화된 전역 변수**: 컴파일 시점에 실행 파일(.exe) 내에 포함됩니다. 실행 파일의 크기가 커집니다.
    * **초기화되지 않은 전역 변수**: 런타임에 프로그램이 시작될 때 생성됩니다.
* **`const` 키워드**:
    * **지역 변수**: 스택에 할당되며, `const`는 **언어적 차원**의 제약입니다. 포인터 강제 캐스팅으로 값을 변경할 수 있습니다.
    * **전역 변수**: 읽기 전용(Read-only) 영역에 저장되어 물리적으로 쓰기가 불가능하므로, 포인터로 값을 변경하려 하면 **쓰기 액세스 위반** 에러가 발생합니다.
* **`volatile` 키워드**:
    * 컴파일러의 **최적화를 막는** 역할을 합니다.
    * 주로 멀티스레드 환경이나 하드웨어 직접 제어 시 사용합니다.
    * 일반적으로 알려진 "캐시를 무시하고 램에 직접 접근하게 한다"는 설명은 오해의 소지가 있습니다. `volatile`은 언어적 키워드일 뿐, OS나 시스템 수준의 메모리 접근 제어를 의미하지 않습니다.

***

### 5. 디버깅 기법

* **Visual Studio 디버거**:
    * **`F5`**: 디버그 시작
    * **`F9`**: 브레이크 포인트 설정
    * **`F10`**: 한 줄씩 실행 (소스 코드 기준)
    * **`F11`**: 함수 내부 진입
    * **디스어셈블리 창(`Ctrl + Alt + D`)**: 소스 코드를 어셈블리어로 변환하여 보여줍니다.
    * **메모리 창**: 메모리 주소의 실제 값을 바이트 단위로 확인할 수 있습니다.
    * **호출 스택**: 함수가 호출된 경로를 추적하여 에러 발생 위치를 파악할 수 있습니다.
* **예측하며 디버깅**: 디버깅을 통해 코드가 어떻게 작동하는지 **예측**하고, 예측이 맞는지 확인하는 훈련이 필요합니다.

***

### 6. 기타 개념

* **엔디언(Endian)**: 메모리에 데이터를 저장하는 순서.
    * **빅 엔디언(Big Endian)**: 큰 단위부터 저장 (네트워크 표준)
    * **리틀 엔디언(Little Endian)**: 작은 단위부터 저장 (대부분의 PC)
* **CISC vs. RISC**: 명령어 세트의 복잡성 차이. `x86`은 CISC 방식이라 명령어 길이가 가변적이어서 디버깅 시 역방향으로 코드를 읽을 때 꼬일 수 있습니다.
* **`extern`**: 다른 소스 파일에 정의된 변수나 함수를 사용하기 위해 선언하는 키워드입니다.