# 핵심 요약: 컴파일러, 스택, 디버깅 

## 1. 컴파일러와 스크립트 언어

* **컴파일러의 역할**: 기본적인 컴파일 과정(전처리, 컴파일, 링킹)을 이해하는 것이 중요합니다. 오류 발생 시 어느 단계에서 문제가 발생했는지 판단하는 데 도움이 됩니다.
* **스크립트 언어**: 게임 개발 등에서 방대한 양의 로직을 효율적으로 구현하기 위해 **스크립트 언어(Scriptor)**가 사용됩니다. 이는 사실상 **인터프리터 언어**로, 코드를 한 줄씩 실행하며 프로그램에 의존하여 작동합니다.
    * **예시**: JavaScript, C# (.NET 프레임워크), Java (JVM), Lua 등.
* **스크립트 언어의 이점**: 프로그래머가 C/C++로 복잡한 로직을 모두 짜는 대신, 기획자가 이해하기 쉬운 스크립트 언어로 게임 콘텐츠(대사, 이벤트 등)를 쉽게 만들 수 있도록 합니다.
* **주의**: 직접 스크립트 언어를 만드는 것은 재미있을 수 있으나, 현재로서는 **불필요**하며 권장되지 않습니다.

---

## 2. 스택 메모리 관리 및 지역 변수

* **`esp` (Stack Pointer)**: 지역 변수 할당을 위해 사용됩니다. `esp` 값을 줄여(빼기 연산) 공간을 확보하며, 이는 지역 변수 및 컴파일러가 필요하다고 판단하는 정보(예: 임시 변수)를 저장하는 데 쓰입니다.
* **지역 변수**: 함수 진입 시 스택에 공간이 **일괄 확보**됩니다. 변수 선언 시점과 관계없이 함수 시작 시점에 필요한 총 공간이 결정됩니다.
    * **예시**: `int a = 0; int b; b = 0;` 와 같이 선언만 하는 경우, 실제 메모리 공간 확보는 함수 진입 시 한 번에 이루어집니다. 조건문 안에서의 변수 선언도 마찬가지입니다.
* **포인터와 스택**: 포인터를 사용하는 경우, 컴파일러는 스택 프레임 주변에 추가적인 공간을 확보하여 **안전장치**를 마련할 수 있습니다. 이는 변수 침범을 방지하고 디버깅을 용이하게 합니다. (예: `0xcccccccc`로 메모리 초기화)

---

## 3. 레지스터 사용 및 복원

* **범용 레지스터**: `eax`, `ecx`와 같은 범용 레지스터는 자유롭게 사용할 수 있습니다.
* **스택 프레임 관련 레지스터**: `ebp`와 `esp`는 함수의 스택 프레임을 관리하므로, 함수 종료 시 **반드시 복원**되어야 합니다.
* **다른 레지스터 복원**: `eax`와 같은 다른 레지스터의 경우, 일반적으로 함수 종료 후 복원할 필요가 없습니다. 컴파일러는 최적화를 위해 레지스터 값을 유지하거나 재사용합니다.
* **`push`/`pop`**: `push`는 스택에 값을 넣고 `esp`를 줄이며, `pop`은 스택에서 값을 빼고 `esp`를 늘립니다.
* **스택 정리 방식**: 함수 종료 시 스택을 정리하는 방식은 두 가지입니다.
    1.  `add esp, [크기]` 명령어로 확보했던 공간을 되돌립니다.
    2.  `mov esp, ebp` 명령어로 `esp`를 `ebp` 값으로 되돌립니다.

---

## 4. 어셈블리어 디버깅

* **디버깅 도구**: Visual Studio의 **디스어셈블리 창**, **메모리 창**, **호출 스택**, **조사식** 등을 활용합니다.
* **핵심 목표**: 코드를 실행하기 전에 **결과를 예측**하고, 실행 후 예측이 맞는지 확인하는 것입니다. 단순히 눈으로 값을 읽는 것을 넘어, 각 단계별 레지스터와 메모리 값의 변화를 예측할 수 있어야 합니다.
* **메모리 창**: 레지스터 값(`ebp`, `esp` 등)을 입력하여 해당 메모리 주소의 값을 확인할 수 있습니다.
* **`0xcccccccc`**: 디버그 모드에서 초기화되지 않은 스택 메모리 영역을 나타내는 값입니다.
* **`0xdddddddd`**: 동적 할당 시 `malloc`의 초기값입니다.
* **Endianness**:
    * **Big Endian**: 데이터의 가장 큰 바이트가 가장 낮은 메모리 주소에 저장됩니다. (네트워크 장비 등)
    * **Little Endian**: 데이터의 가장 작은 바이트가 가장 낮은 메모리 주소에 저장됩니다. (대부분의 PC 시스템)
* **디버깅 시 주의사항**:
    * `esp` 값 위의 메모리는 쓰레기값일 가능성이 높습니다.
    * 함수 호출 스택이 깨지면(Stack Frame 오염), 디버깅이 어려워집니다. 이때는 어셈블리 디버깅을 통해 역추적해야 합니다.
    * `jne esperror`와 같은 코드는 `esp` 또는 `ebp`가 비정상적인 경우 오류 처리 함수로 분기하는 안전장치입니다.

---

## 5. 기타

* **Word 크기**: CPU 워드(Word)는 일반적으로 2바이트를 의미하지만, CPU 아키텍처에 따라 처리 단위가 다를 수 있습니다 (32비트 CPU는 4바이트, 64비트 CPU는 8바이트).
* **Segment 방식**: 과거 16비트 환경에서 메모리 주소 확장을 위해 사용된 방식입니다. 현대적인 32비트/64비트 환경에서는 페이징 방식으로 대체되었지만, 하위 호환성이나 특정 용도로 여전히 사용될 수 있습니다.
* **UTF-8 vs. CHAR**: UTF-8은 가변 길이 문자 인코딩이며, CHAR는 일반적으로 1바이트를 나타냅니다.

이 내용을 바탕으로 어셈블리 코드 분석 능력을 키우고, 디버깅 시 문제 해결 능력을 향상시키시길 바랍니다. 💪