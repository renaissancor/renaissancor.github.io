## 데드락(Deadlock)의 4가지 조건

**데드락**은 둘 이상의 스레드가 서로가 점유하고 있는 자원을 얻기 위해 영원히 기다리는 상태입니다. 데드락이 발생하려면 다음 네 가지 조건이 동시에 충족되어야 합니다.

1.  **상호 배제 (Mutual Exclusion)**: 한 번에 한 스레드만이 자원을 사용할 수 있습니다.
2.  **점유와 대기 (Hold and Wait)**: 자원을 이미 점유하고 있는 스레드가 다른 스레드가 점유하고 있는 자원을 얻기 위해 대기합니다.
3.  **비선점 (No Preemption)**: 자원을 강제로 뺏을 수 없고, 점유하고 있는 스레드의 작업이 끝나야만 자원이 해제됩니다.
4.  **원형 대기 (Circular Wait)**: 각 스레드가 다음 스레드가 요청하는 자원을 점유하고 있는 형태로, 자원 요청이 원을 이루어 순환하는 상태입니다.

---

## 유저 레벨 스레드와 커널 레벨 스레드

* **커널 레벨 스레드**: OS 커널이 직접 관리하고 스케줄링하는 스레드입니다. **`CreateThread`**나 **`_beginthreadex`**로 생성되는 스레드가 이에 해당합니다. 병렬 처리가 가능하며, 멀티코어 환경에서 진정한 동시성을 활용할 수 있습니다.
* **유저 레벨 스레드**: 라이브러리(런타임) 수준에서 관리되는 경량 스레드입니다. 커널에는 하나의 스레드로 인식됩니다. **`C#`의 코루틴**이나 **`C++20`의 코루틴**이 대표적입니다.
    * **장점**: 커널 컨텍스트 스위칭 오버헤드가 없어 가볍고 빠릅니다.
    * **단점**: 한 프로세스 내에서 **직렬적(Sequential)으로 처리**되어 진정한 병렬 처리가 불가능합니다. IO 작업과 같은 블로킹 작업이 발생했을 때 다른 작업을 수행하도록 번갈아 가며 실행하는 **비동기 처리**에 주로 사용됩니다. 

---

## 파일 입출력 (File I/O)

### C 언어 기반 I/O

* **함수**: `fopen`, `fread`, `fwrite`, `fclose` 등의 함수를 사용합니다.
* **작업 디렉터리**: `fopen()`으로 파일을 열 때 상대 경로는 실행 파일이 위치한 경로를 기준으로 합니다.
* **텍스트 모드 vs. 바이너리 모드**:
    * **텍스트 모드**: **`\n` (개행 문자)**를 **`\r\n` (CRLF)**으로 자동 변환하는 등 OS에 맞는 줄바꿈 처리를 해줍니다.
    * **바이너리 모드**: 데이터를 있는 그대로(Raw) 읽고 씁니다. 게임 데이터와 같이 순수한 바이트 단위의 처리가 필요할 때 사용됩니다.
* **버퍼링**: `fopen`, `fread`, `fwrite` 함수는 성능 최적화를 위해 **4KB 크기의 버퍼**를 사용합니다.
    * `fwrite` 함수를 호출해도 데이터는 즉시 디스크에 저장되지 않고, 먼저 C 런타임 라이브러리의 버퍼에 쌓입니다.
    * 버퍼가 가득 차거나, `fclose()`나 `fflush()` 함수를 호출해야 비로소 OS에 전달되어 디스크에 쓰여집니다.
    * `fflush()` 함수는 버퍼의 내용을 디스크로 강제로 밀어내는(flush) 역할을 합니다.
    * **파일 캐시**: 운영체제도 `Read`나 `Write` 작업 시 **파일 캐시(RAM)**를 사용하여 디스크 접근 횟수를 최소화합니다.

### 효율적인 파일 I/O 전략

* **최소화**: 파일 I/O는 CPU 연산에 비해 매우 느리므로, 파일을 자주 열고 닫는 대신 한 번에 통째로 읽어 **메모리**에 올려놓고 작업하는 것이 효율적입니다.
* **파일 크기 확인**: `fseek()`와 `ftell()`을 사용해 파일 크기를 얻어오고, 메모리를 동적 할당한 후 `fread()`로 파일을 한 번에 읽는 방식이 보편적입니다.
    * `fseek(pFile, 0, SEEK_END)`: 파일 포인터를 파일의 끝으로 이동시킵니다.
    * `ftell(pFile)`: 파일 포인터의 현재 위치(파일 크기)를 반환합니다.
    * `rewind()` 또는 `fseek(pFile, 0, SEEK_SET)`: 파일 포인터를 다시 파일의 시작 위치로 돌려놓습니다.

---

### 과제

* **XOR 기반 파일 암호화/복호화 프로그램**:
    * **기능**: 파일의 내용을 XOR 연산을 이용해 암호화하거나 복호화합니다.
    * **설계**:
        1.  사용자에게 파일명을 입력받아 **바이너리 모드**로 파일을 엽니다.
        2.  `fseek()`와 `ftell()`을 사용해 파일 크기를 얻고, 해당 크기만큼 메모리를 동적 할당합니다.
        3.  `fread()`로 파일을 통째로 메모리에 올립니다.
        4.  메모리 상의 데이터에 대해 XOR 연산을 수행합니다.
        5.  `fwrite()`로 암호화/복호화된 데이터를 다시 파일에 덮어씁니다.
* **파일 무결성 검사**:
    * **헤더(Header)**: 모든 파일은 고유한 헤더를 가집니다(예: `.exe`는 'MZ', `.jpg`는 'JFIF'). 이를 통해 파일 형식을 판별할 수 있습니다.
    * **무결성 검증**: 파일을 암호화할 때 **원본 데이터의 해시값**을 헤더에 함께 저장합니다. 복호화 후 해시를 다시 계산하여 저장된 해시값과 비교함으로써 복호화 성공 여부를 판단할 수 있습니다.