채점 결과 잘 확인했습니다. 1, 2, 4, 5번은 정답이 맞습니다. 3번 문제의 경우, 오버플로우가 발생할 때 부호 비트가 바뀌면서 최소값으로 순환하는 현상은 `signed char`의 특성 중 하나입니다. 다음번에는 더 상세한 해설을 포함하여 헷갈리는 부분을 해소해 드리도록 할게요.

자, 이제 새로운 내용으로 퀴즈를 시작하겠습니다. 이번에도 지난 수업 내용들을 바탕으로 헷갈릴 수 있는 부분을 문제로 구성해 봤습니다.

---

### **정리된 퀴즈**

다음은 250718 수업 내용을 바탕으로 핵심 개념을 확인하는 문제들입니다.

1.  **매크로 함수**에 관련된 문제입니다. C/C++에서 여러 줄의 코드를 포함하는 매크로 함수를 정의할 때, **`do { ... } while (0)`** 문을 사용하는 주된 이유는 무엇인가요?
    a) 매크로를 사용할 때 컴파일러가 추가적인 최적화를 적용하도록 유도하기 위함입니다.
    b) 매크로 내부에 정의된 변수의 스코프를 제한하여 지역 변수 충돌을 방지하기 위함입니다.
    c) 매크로 호출 뒤에 세미콜론(`;`)을 붙일 때 문법 오류가 발생하지 않도록 하기 위함입니다.
    d) 매크로를 사용하는 동안 프로그램의 성능을 향상시키기 위함입니다.

2.  **함수 호출 방식**에 관련된 문제입니다. Visual Studio 디버그 모드에서 `Test()` 함수를 호출할 때, 어셈블리 코드 상에서 **두 번의 점프**(`call` 후 `jmp`)를 거쳐 함수 본체로 이동하는 경우가 있습니다. 이러한 방식의 주된 목적은 무엇인가요?
    a) 함수 호출 시 스택 오버플로우를 방지하기 위함입니다.
    b) 함수 포인터와 메모리 주소를 분리하여 보안을 강화하기 위함입니다.
    c) 증분 링크(Incremental Linking)를 통해 재컴파일 시간을 단축하기 위함입니다.
    d) 다른 DLL에 있는 함수를 호출할 때 발생하는 문제를 해결하기 위함입니다.

3.  **호출 규약(Calling Convention)**에 관련된 문제입니다. C/C++에서 `__stdcall` 호출 규약을 사용하는 함수는 `__cdecl` 호출 규약에 비해 어떤 장점을 가질 수 있나요?
    a) 함수를 호출하는 쪽에서 스택을 정리하므로, 함수의 가변 인자(Variable Arguments)를 처리하기에 용이합니다.
    b) 함수를 호출당하는 쪽(피호출자)에서 스택을 정리하므로, 호출하는 쪽의 어셈블리 코드 양이 줄어들어 실행 파일 크기가 줄어들 수 있습니다.
    c) 모든 아키텍처에서 동일한 방식으로 동작하여 이식성이 뛰어납니다.
    d) 모든 매개변수를 CPU 레지스터를 통해 전달하므로, 스택 접근이 줄어들어 성능이 더 빠릅니다.

4.  **`call` 명령어**에 관련된 문제입니다. 어셈블리의 `call` 명령어는 단순히 함수의 주소로 점프하는 것 외에, **`ret`** 명령어를 통해 원래 위치로 돌아오기 위해 필수적으로 수행하는 작업이 있습니다. 이 작업은 무엇인가요?
    a) CPU 레지스터의 값을 모두 백업합니다.
    b) 함수 호출 후 돌아올 다음 명령어의 주소를 스택에 저장합니다.
    c) 함수에 전달되는 매개변수를 레지스터에 저장합니다.
    d) 함수가 사용할 지역 변수 공간을 스택에 할당합니다.

5.  **메모리 연산**에 관련된 문제입니다. 어셈블리 명령어에서 `cmp`와 같은 연산을 할 때, `mov` 명령어와 달리 **메모리 대 메모리(memory-to-memory)** 직접 비교가 불가능한 주된 이유는 무엇인가요?
    a) 메모리 대 메모리 연산은 보안상의 이유로 OS가 제한하기 때문입니다.
    b) CPU의 ALU(산술 논리 장치)가 메모리 데이터를 직접 연산하지 않고, 레지스터를 거쳐서 연산하기 때문입니다.
    c) 메모리 대 메모리 연산은 캐시 일관성(Cache Coherency) 문제를 야기하기 때문입니다.
    d) 어셈블리 명령어의 크기가 제한적이어서 메모리 주소 두 개를 동시에 지정할 수 없기 때문입니다.