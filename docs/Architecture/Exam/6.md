## 핵심 요약: 프로세스, 호출 규약, 그리고 코드 최적화

이 노트는 프로세스 동작 방식, 함수 호출 규약, 그리고 실용적인 코드 작성 기법에 대한 내용을 담고 있습니다. 시험 공부에 도움이 되도록 간결하게 정리했습니다.

---

### 1. 프로세스와 핸들

* **핸들 상속**: 부모 프로세스에서 생성된 **핸들**은 상속이 가능하도록 설정된 경우, 자식 프로세스도 동일한 핸들 값을 공유하게 됩니다.
* **멀티 프로세스 디버깅**: 부모 프로세스가 `CreateProcess`로 자식 프로세스를 생성할 때, 자식 프로세스에 디버거를 연결하여 개별적으로 디버깅할 수 있는 방법이 있습니다.

---

### 2. 함수 호출 규약과 디버깅

* **함수 호출 방식**:
    * **릴리즈 모드**: 컴파일러는 함수를 직접 호출하는 **`jmp`** 명령을 사용하여 성능을 최적화합니다.
    * **디버그 모드**: **증분 링크** 기능을 위해 **두 번의 `jmp`** 를 거칩니다. 이는 코드 수정 시 전체를 다시 링크하지 않고 특정 부분만 빠르게 변경하기 위함입니다.
* **`call` 명령어의 작동 원리**:
    * `call` 명령어는 다음 명령어의 주소(돌아올 주소)를 **스택**에 저장합니다.
    * 이후 함수가 시작되는 주소로 이동합니다.
    * 함수 실행이 끝난 후 **`ret`** 명령어를 만나면 스택에 저장된 주소를 꺼내 원래 위치로 돌아옵니다.
* **매개변수 전달**: 32비트 환경에서 함수 매개변수는 스택에 오른쪽에서 왼쪽 순서(Right to Left)로 `push`되어 전달됩니다.
* **호출 규약**:
    * **`__cdecl`**: 호출하는 쪽(Caller)이 스택에 있는 **매개변수를 정리**합니다. **가변 인자**를 받는 함수(`printf`)에 사용됩니다.
    * **`__stdcall`**: 호출받는 쪽(Callee)이 스택을 정리합니다. **Windows API**에서 주로 사용됩니다.
    * **`__fastcall`**: 일부 매개변수를 **레지스터**로 전달하여 성능을 높입니다.

---

### 3. 코드 작성 기법과 매크로

* **매크로 함수와 `;` 문제**:
    * 매크로 함수를 작성할 때 여러 줄의 코드를 포함하면 `if-else`문 등에서 세미콜론(;) 때문에 구문 오류가 발생할 수 있습니다.
    * 이를 해결하기 위해 **`do { ... } while(0)`** 구문을 사용하여 매크로를 하나의 문장처럼 만듭니다.
* **`try-catch` 주의점**:
    * `try-catch`는 **예외적인 상황**(`null` 포인터 접근 등)을 처리하기 위한 것이며, 일반적인 로직 흐름 제어에는 사용하지 않습니다.
    * OS가 개입하므로 성능 오버헤드가 매우 큽니다.
* **`switch-case` 최적화**:
    * `switch-case`문은 `if-else`의 단순 반복이 아닙니다.
    * `case` 값들이 연속적이거나 특정 규칙을 가지면, 컴파일러가 **점프 테이블**을 만들어 즉시 해당 코드로 점프합니다. 이는 `if-else`보다 훨씬 빠릅니다.
    * 다만, `case` 값들이 불규칙적으로 흩어져 있으면 `if-else`와 유사하게 동작할 수 있습니다.

---

### 4. 기타 개념

* **문자열**: **`wchar`** 를 사용한 멀티바이트(유니코드) 문자열이 현재 표준이며, 과거의 **`tchar`** 는 과도기적 유물입니다.
* **메모리 연산**: **`x86` 아키텍처**는 두 메모리 주소 간의 직접적인 비교 연산을 지원하지 않습니다. 반드시 한쪽 값을 레지스터로 옮겨서 비교해야 합니다.
* **클린 코드**: 객체지향 설계는 중요하지만, MMORPG와 같은 복잡하고 변화가 많은 프로젝트에서는 현실적인 타협이 필요합니다.