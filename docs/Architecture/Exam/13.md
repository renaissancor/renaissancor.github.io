## IO와 캐스팅

* **비동기 IO(Input/Output):** 지금 당장은 다루지 않지만, IO 장치에서 발생하는 입출력 작업을 비동기적으로 처리하여 프로그램의 블로킹을 방지하는 기술입니다.
* **메모리 할당:**
    * `VirtualAlloc`: 가상 메모리 시스템에서 페이지 단위로 메모리를 할당하는 WinAPI 함수입니다.
    * `HeapAlloc`: 힙에서 메모리를 할당하는 WinAPI 함수입니다.
* **캐스팅:** 자료형을 변환하는 작업입니다.
    * **C 스타일 캐스팅:** `(int)a`와 같이 직관적이지만, 여러 종류의 캐스팅을 한 번에 처리하여 잠재적인 버그를 유발할 수 있습니다.
    * **C++ 스타일 캐스팅:** `static_cast`, `dynamic_cast`, `const_cast`, `reinterpret_cast` 등 목적에 따라 캐스팅 연산자를 명확히 구분하여 사용합니다. 이는 코드의 가독성을 높이고 의도치 않은 버그를 줄이는 데 도움을 줍니다.

---

## 멀티스레드와 캐시 메모리

멀티스레드 환경에서 캐시 메모리는 성능에 중요한 영향을 미칩니다. 각 스레드는 일반적으로 자신만의 **L1 캐시**를 가지며, 다른 스레드와 **L2, L3 캐시**를 공유할 수 있습니다.

* **동일 캐시 라인 공유:** `stDATA` 구조체의 `a`와 `b` 변수는 크기가 작아 같은 64바이트 캐시 라인에 위치할 가능성이 높습니다. 
* **캐시 무효화:** 한 스레드가 `b` 변수에 쓰기 작업을 하면, 해당 캐시 라인은 **수정(Modified)** 상태가 됩니다. 동시에 다른 코어에 있는 캐시에 동일한 `b` 변수가 있을 경우, **MESI 프로토콜**에 따라 해당 캐시 라인은 **무효화(Invalid)**됩니다.
* **성능 저하:** 쓰기 작업으로 인해 캐시 라인이 무효화되면, 다른 스레드가 동일한 캐시 라인에 접근할 때 캐시 미스가 발생하여 **L3 캐시** 또는 **메인 메모리(RAM)**에서 데이터를 다시 가져와야 합니다. 이 과정에서 **캐시 간 통신** 오버헤드가 발생하여 성능이 크게 저하됩니다.
* **실험 결과:**
    * **읽기 전용 vs. 쓰기 전용:** 한 스레드가 읽기만 하는 경우와 쓰기만 하는 경우의 성능 차이는 크지 않았습니다.
    * **멀티스레드 간 읽기+쓰기:** 두 스레드가 같은 캐시 라인의 변수에 대해 각각 읽기-쓰기 작업을 할 때, 성능이 **20-40%**까지 크게 하락했습니다. 이는 **`alignas(64)`**를 사용하여 두 변수를 다른 캐시 라인으로 강제 분리했을 때 성능이 복구되는 것으로 확인됩니다.
* **결론:** 읽기-쓰기 작업이 빈번하게 발생하는 변수들은 같은 캐시 라인에 두지 않도록 **데이터를 정렬**하거나 **위치를 재배치**하여 캐시 미스를 줄여야 합니다.

---

## 시간 측정과 해시 함수

### 시간 측정 함수
* **`GetTickCount()`**: 시스템이 시작된 후 경과된 시간을 밀리초 단위로 반환하는 WinAPI 함수입니다. 49.7일이 지나면 오버플로우가 발생할 수 있어, 장시간 실행되는 서버에서는 `GetTickCount64()`를 사용해야 합니다. 이 함수는 CPU 내부의 타이머 인터럽트를 기반으로 동작합니다.
* **`timeGetTime()`**: 역시 WinAPI 함수로, `GetTickCount()`보다 더 정밀한 시간을 제공합니다.
* **`QueryPerformanceCounter()`**: 매우 높은 해상도의 시간을 측정할 때 사용합니다.
* **`std::chrono`**: C++ 표준 라이브러리로, 플랫폼에 관계없이 정밀한 시간 측정을 제공합니다. 내부적으로는 Windows 환경에서 `QueryPerformanceCounter()`를 래핑하여 사용합니다.

### 해시(Hash)
해시는 임의의 크기 데이터를 고정된 크기의 데이터로 변환하는 함수입니다.

* **해시 함수의 특징:**
    1.  **일관성:** 동일한 입력에 대해 항상 동일한 출력을 보장합니다.
    2.  **단방향성:** 해시값으로 원래 데이터를 유추할 수 없습니다.
    3.  **충돌:** 서로 다른 입력이 같은 해시값을 가질 수 있습니다.
* **활용 사례:**
    * **무결성 검증:** 파일의 위변조 여부를 확인하거나, 네트워크 패킷의 오류를 검출하는 데 사용됩니다(체크섬).
    * **비밀번호 저장:** 데이터베이스에 비밀번호를 직접 저장하는 대신 해시값을 저장하여 보안을 강화합니다. 브루트 포스 공격을 막기 위해 **Salt(임의의 문자열)**를 해시값에 추가하는 방식이 사용됩니다.
    * **자료 구조:** `std::unordered_map`과 같은 **해시 테이블**은 키-값 쌍을 저장할 때 해시 함수를 사용하여 빠른 검색 속도를 제공합니다. 데이터의 양에 관계없이 검색 시간 복잡도가 **O(1)**에 가깝지만, 해시 충돌을 해결하기 위한 추가 작업이 필요할 수 있습니다.

---

### 논의된 추가 사항
* **타이머 인터럽트**: OS의 멀티태스킹은 하드웨어 타이머 인터럽트에 의해 주기적으로 발생하며, 이를 통해 여러 프로세스를 스케줄링합니다.
* **객체지향 vs. 데이터 중심 설계**: OOP는 인간 친화적이지만, DOD는 하드웨어(특히 캐시 메모리)의 효율성을 극대화하기 위해 데이터를 논리적 관계가 아닌 물리적 위치를 고려하여 배치합니다.
* **멀티스레딩 성능 저하**: 멀티스레드 환경에서 Read-Write 작업이 빈번한 경우, 캐시 동기화 오버헤드가 발생하여 싱글 스레드보다 성능이 떨어질 수 있습니다.