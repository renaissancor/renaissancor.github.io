### 캐시 메모리 구조와 길찾기 알고리즘

* **길찾기 알고리즘**: 길찾기(Pathfinding) 알고리즘은 **BFS**, **DFS**, **다익스트라**, **A* **와 같은 방법을 사용하여 최적의 경로를 찾습니다. 과거 게임 AI에서 주로 사용되었지만, 최근에는 비동기 처리나 다른 스레드에서 길찾기 작업을 처리하는 방식으로 활용됩니다.
* **캐시 메모리**: 캐시 메모리는 CPU와 RAM 사이의 빠른 저장 공간으로, 데이터의 지역성을 활용하여 성능을 향상시킵니다.
    * **캐시 라인**: 캐시 메모리에서 데이터를 가져오는 최소 단위로 **64 바이트**입니다.
    * **페이지 오프셋**: 가상 메모리 주소에서 페이지 내의 위치를 나타내는 부분으로, **4KB(2^12 바이트)** 크기입니다.
    * **MMU(Memory Management Unit)**: CPU의 가상 메모리 주소를 RAM의 물리적 메모리 주소로 변환하는 장치입니다.

---

### 캐시 메모리 시뮬레이터 과제

과제의 목표는 **자체 캐시 히트/미스 시뮬레이터**를 만들어 코드의 성능을 예측하고 최적화하는 것입니다.

* **구현 방법**:
    1.  **CPU 정보 확인**: 사용 중인 CPU의 캐시 구조(L1, L2, L3 캐시 용량, 캐시 라인 크기, Way 수)를 확인합니다.
    2.  **캐시 모델 구현**: 캐시 라인의 인덱스와 태그를 저장할 배열 또는 자료구조를 만듭니다. **8-Way** 캐시라면, 하나의 인덱스에 8개의 캐시 라인 정보를 저장할 수 있도록 구현합니다.
    3.  **`CacheHit()` 함수**: 이 함수는 특정 변수의 주소를 인자로 받아 캐시 히트 또는 미스를 시뮬레이션합니다.
        * **주소 변환**: 전달된 변수의 가상 주소를 확인합니다.
        * **인덱스 추출**: 가상 주소에서 인덱스 비트를 추출합니다. 예를 들어, 32KB 캐시(8-Way)의 경우, 64개의 인덱스가 필요하며(32KB / 64B / 8), 주소의 6비트가 인덱스로 사용됩니다.
        * **히트/미스 판별**: 추출된 인덱스를 사용하여 시뮬레이션 배열에 접근하고, 8개의 Way 중 해당 태그가 존재하는지 확인합니다. 태그가 존재하면 히트, 없으면 미스입니다.
        * **갱신**: 미스일 경우 가장 오랫동안 사용되지 않은 캐시 라인을 덮어쓰고, 히트일 경우 해당 캐시 라인의 사용 시간을 갱신합니다.

* **활용**:
    * BFS/DFS와 같은 알고리즘을 맵 크기를 크게 잡고 실행하여 의도적으로 **캐시 미스를 유도**하고, 시뮬레이터를 통해 미스가 발생하는 지점을 찾아냅니다.
    * 캐시 히트를 늘리기 위해 데이터 구조를 **캐시 친화적**으로 변경하는 시도를 합니다.
    * **`alignas(64)`** 와 같은 키워드를 사용하여 변수들이 같은 캐시 라인에 위치하도록 강제할 수 있습니다.

---

### 명령어 처리와 캐시 메모리 동기화

* **CPU 파이프라인**: CPU는 명령어를 여러 단계로 나누어 처리하며, 여러 명령어를 동시에 처리하는 **파이프라인** 구조를 사용합니다.
* **비순차적 명령어 처리**: CPU는 명령어 간의 의존성을 분석하여 순서와 관계없이 실행합니다. 이를 통해 지연 시간을 최소화하고 성능을 높입니다.
* **캐시 프로토콜(MESI)**: 멀티코어 시스템에서 각 코어의 캐시가 동일한 데이터를 가리키도록 동기화하는 프로토콜입니다.
    * **M(Modified)**: 캐시 라인의 데이터가 수정되었으며, 메인 메모리에는 아직 반영되지 않은 상태입니다.
    * **E(Exclusive)**: 캐시 라인의 데이터가 메인 메모리와 동일하며, 다른 캐시에는 복사본이 없는 상태입니다.
    * **S(Shared)**: 캐시 라인의 데이터가 메인 메모리와 동일하며, 다른 캐시에도 복사본이 있는 상태입니다.
    * **I(Invalid)**: 캐시 라인의 데이터가 유효하지 않은 상태입니다.
* **Write Back vs. Write Through**:
    * **Write Back**: 데이터 변경 시 먼저 캐시에만 쓰고, 나중에 캐시에서 해당 데이터가 제거될 때(eviction) 메인 메모리에 반영하는 방식입니다. 빠르지만 복잡합니다. 대부분의 데이터 캐시가 이 방식을 사용합니다.
    * **Write Through**: 데이터 변경 시 캐시와 메인 메모리에 동시에 반영하는 방식입니다. 느리지만 구현이 간단합니다.

---

### 데이터 중심 설계(Data-Oriented Design)

* **OOP(객체지향 프로그래밍)**: 인간이 이해하기 쉽고 유지보수가 용이하도록 설계된 패러다임입니다.
* **DOD(데이터 중심 설계)**: 하드웨어, 특히 캐시 메모리의 구조를 고려하여 데이터를 배치하는 설계 방식입니다. 관련된 데이터들을 한 덩어리로 묶어 **캐시 히트율을 극대화**합니다.
* **활용**: `x, y` 좌표처럼 함께 사용되는 멤버 변수들을 배열로 묶어 `x` 좌표 배열, `y` 좌표 배열처럼 분리하면, 특정 로직을 처리할 때 필요한 데이터만 연속적으로 읽어와 캐시 효율을 높일 수 있습니다. 하지만 이는 코드 가독성을 해칠 수 있어 유지보수 측면에서는 불리할 수 있습니다. 