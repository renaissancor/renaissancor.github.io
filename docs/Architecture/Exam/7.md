# 1. 함수 호출과 반환 값

* **`eax` 레지스터**: 함수의 **반환 값은 `eax` 레지스터**에 저장됩니다. 소스 코드가 없는 외부 라이브러리(`WinAPI`)를 디버깅할 때, `eax`의 값을 통해 함수의 반환 값을 추론할 수 있습니다.
* **경고(`Warning`)의 중요성**: `int` 타입 함수에 `return` 문이 없는 경우(`warning C4715`), 컴파일러는 오류를 내지 않습니다. 이 경우 `eax` 레지스터에 이전에 실행된 다른 함수의 반환 값(예: `printf`가 반환한 문자 개수)이 남아있어 예기치 않은 버그가 발생할 수 있습니다. **단 한 개의 경고도 남기지 않는 것이 중요**합니다.

---

### 2. 구조체와 메모리

* **구조체 멤버 접근**: 구조체 멤버는 구조체 시작 주소를 기준으로 한 **오프셋(offset)**으로 접근됩니다. 어셈블리어에서는 `mov ptr[ebp-8]`와 같이 오프셋을 활용합니다.
* **구조체 복사**:
    * `DATA b = d;`와 같이 구조체를 통째로 복사하면, 컴파일러는 `rep movs`와 같은 반복적인 어셈블리 명령을 생성하여 **바이트 단위로 복사**를 수행합니다. 이 과정은 비효율적일 수 있습니다.
    * 멀티스레딩 환경에서 다른 스레드가 데이터를 쓰는 도중 바이트 단위로 읽어오면, 존재하지 않는 이상한 값이 나올 수 있습니다.
* **매개변수 및 반환 값으로 사용**: 크기가 큰 구조체를 함수 매개변수로 전달하거나 반환 값으로 사용하면, 매번 전체 구조체가 스택에 복사되어 성능 저하가 발생합니다. **포인터를 사용하여 전달**하는 것이 효율적입니다.

---

### 3. 난수(`rand`)와 어셈블리 분석

* **의사 난수**: `rand()` 함수는 진정한 의미의 난수가 아닌 **의사 난수**를 생성합니다. `srand()` 함수로 시드(seed) 값을 주어 난수 생성 패턴을 초기화할 수 있으며, 일반적으로 `time(nullptr)`을 시드로 사용합니다.
* **`rand()`의 동작 원리**: 어셈블리 분석을 통해 `rand()`가 시드 값에 특정 상수들을 곱하고 더하는 단순한 연산을 반복함을 알 수 있습니다. 이는 암호학적으로 안전하지 않습니다.
* **온라인 게임에서의 난수**: 온라인 게임에서는 서버와 클라이언트 간의 상태를 일치시키기 위해 **동일한 난수 패턴**을 보장해야 합니다. 이를 위해 서버와 클라이언트가 동일한 난수 알고리즘과 시드값을 사용해야 합니다.

---

### 4. 함수 호출 규약 심화 및 최적화

* **`__fastcall`**: 매개변수를 스택이 아닌 **레지스터로 전달**하여 함수 호출 오버헤드를 줄이는 규약입니다.
* **`switch-case`와 함수 포인터**: `switch-case` 문이 매우 커질 경우, `case` 값에 따라 분기하는 대신 **함수 포인터 배열**이나 `map`과 같은 자료구조를 사용하여 메시지 번호와 함수를 연결하면 성능을 최적화할 수 있습니다. `switch-case`는 디버깅에는 더 직관적이라는 장점이 있습니다.
* **외부 코드 디버깅**: 소스 코드가 없는 런타임 라이브러리나 API를 디버깅할 때, **심볼 파일**을 로드하여 함수 이름을 확인하고 어셈블리 코드를 분석하여 동작을 파악해야 합니다.
