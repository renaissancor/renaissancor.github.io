## 핵심 요약: 쓰레드, 재귀, 그리고 스택 오염 🧠

이번 노트는 운영체제의 쓰레드 동작 방식, 재귀 함수의 위험성, 그리고 스택 프레임의 오염 문제를 다룹니다.

---

### 1. 쓰레드 개념의 재정립: 커널 vs. 유저 레벨

* **우리가 사용하는 쓰레드**: C++ 등에서 사용하는 쓰레드는 대부분 **커널 레벨 쓰레드**입니다. OS가 직접 스케줄링하며, 멀티코어 CPU를 활용해 병렬 처리가 가능합니다.
* **유저 레벨 쓰레드**: 파이버(Fiber), 코루틴(Coroutine) 등이 이에 해당합니다. 하나의 커널 쓰레드 위에서 사용자 코드에 의해 실행됩니다.
    * **특징**: OS의 개입 없이 코드 내부에서 직접 컨텍스트 스위칭이 발생합니다.
    * **목적**: **병렬 처리가 아닌**, 하나의 커널 쓰레드 내에서 여러 작업을 **비동기적으로 처리**하는 데 사용됩니다.
    * **예시**: 유니티 엔진과 같이 싱글 스레드 환경에서 비동기 작업을 처리하기 위한 대안으로 사용됩니다.
* **블로킹과 컨텍스트 스위칭**:
    * `CRITICAL_SECTION`과 같은 락에 의해 커널 레벨 쓰레드가 막히면 해당 쓰레드만 멈추고 다른 커널 쓰레드는 계속 실행됩니다.
    * 유저 레벨 쓰레드가 커널 객체(예: 파일 I/O) 때문에 블로킹되면 해당 **프로세스를 담고 있는 커널 쓰레드 전체가 중단**됩니다.

---

### 2. 재귀 함수와 스택 오버플로우

* **스택 오버플로우**: 재귀 함수는 호출될 때마다 스택에 새로운 프레임을 쌓습니다. 무한 재귀 또는 재귀 깊이가 지나치게 깊어지면 스택의 제한된 메모리 공간을 초과하여 **스택 오버플로우**가 발생합니다.
* **디버그 vs. 릴리즈**: 디버그 모드는 릴리즈 모드보다 스택 크기가 작아 스택 오버플로우가 더 쉽게 발생합니다.
* **안전성**: 재귀는 모든 경우에 위험한 것은 아니며, **트리 자료구조**와 같이 재귀 깊이가 잘 제어되는 경우에는 효율적인 구현 방법이 될 수 있습니다.

---

### 3. 스택 프레임 오염과 방어 기법

* **스택 프레임**: 함수가 호출될 때 스택에 쌓이는 데이터 구조로, 지역 변수, 이전 `ebp` 값, 그리고 반환 주소(`ret ip`) 등을 포함합니다.
* **오염의 원인**: **버퍼 오버런**과 같은 메모리 접근 오류로 인해 스택에 할당된 지역 변수 영역을 넘어 다른 중요한 데이터(이전 `ebp`, 반환 `ip`)를 덮어쓰게 될 때 발생합니다.
* **오염의 결과**:
    * **즉각적인 오류**: 반환 `ip`가 덮어쓰여 프로그램 실행 흐름이 엉뚱한 곳으로 점프하여 프로그램이 비정상적으로 종료됩니다.
    * **최악의 경우**: `ebp`가 덮어쓰여 부모 함수의 지역 변수에 잘못 접근하거나, 데이터가 오염되는 경우가 발생합니다. 이는 프로그램이 당장 멈추지 않고 잘못된 데이터를 처리하게 만들어 **더 큰 문제를 야기**할 수 있습니다.
* **방어 기법**:
    * **스택 쿠키(`__security_cookie`)**: 컴파일러는 스택 프레임의 중요 데이터가 오염되는 것을 막기 위해 **지역 변수와 저장된 `ebp` 사이에 쿠키 값을 삽입**합니다.
    * **작동 방식**: 함수 종료 시 이 쿠키 값이 변경되었는지 확인하여, 변조가 감지되면 프로그램 실행을 중단시킵니다.
    * **한계**: 만약 쿠키 영역을 건너뛰고 바로 `ebp`를 덮어쓰는 경우가 발생하면 이 방어 기법으로도 막을 수 없습니다.