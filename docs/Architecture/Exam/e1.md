저번 문제들이 헷갈리게 느껴졌다면 죄송합니다. 이번에는 기존에 사용했던 단어와 맥락을 유지하면서, 학습 내용을 더 명확히 이해할 수 있도록 문제를 수정하여 다시 내드릴게요. 

---

### **정리된 퀴즈**

다음은 지난 수업 내용을 바탕으로 핵심 개념을 확인하는 문제들입니다. 기존 노트에서 다루었던 용어와 개념을 중심으로 문제를 만들었으니, 편안하게 풀어보세요.

1.  **스택 프레임**과 관련된 문제입니다. 32비트 환경에서 함수가 반환될 때, **EBP 레지스터**와 **ESP 레지스터**의 역할은 무엇인가요?
    a) EBP는 함수 반환값을 저장하고, ESP는 지역 변수를 저장하는 데 사용됩니다.
    b) EBP는 스택 프레임의 기준점 역할을 하고, ESP는 스택의 가장 위를 가리키는 포인터입니다.
    c) EBP는 호출자의 스택 주소를 저장하고, ESP는 현재 함수의 스택 주소를 저장합니다.
    d) EBP와 ESP는 둘 다 함수 매개변수를 저장하는 데 사용됩니다.

2.  **함수 반환값**과 관련된 문제입니다. `int func()`와 같이 정수형 값을 반환하는 함수에서 `return` 문이 없는 실행 경로가 있을 경우, 해당 함수가 반환하는 값은 무엇인가요?
    a) 항상 0을 반환합니다.
    b) 컴파일러가 임의의 쓰레기 값을 EAX 레지스터에 넣습니다.
    c) 함수를 호출한 쪽에서 EAX 레지스터의 이전 값을 재사용합니다.
    d) `printf()`와 같은 이전 함수의 반환값이 EAX 레지스터에 남아있어 해당 값이 반환될 수 있습니다.

3.  **구조체 메모리 관리**와 관련된 문제입니다. 거대한 구조체를 함수에 매개변수로 전달할 때, **성능 저하를 막기 위한 가장 좋은 방법**은 무엇인가요?
    a) 구조체를 전역 변수로 선언하여 모든 함수에서 직접 접근하게 합니다.
    b) 구조체의 멤버 변수 순서를 바꾸어 패딩을 최소화합니다.
    c) 구조체의 복사본 대신 포인터나 참조를 전달하여 불필요한 메모리 복사를 방지합니다.
    d) 구조체를 여러 개의 작은 구조체로 분리하여 전달합니다.

4.  **스택 오염**과 관련된 문제입니다. 다음 중 스택 오염으로 인해 **프로그램이 즉시 비정상 종료되는 경우**와 가장 관련이 깊은 것은 무엇인가요?
    a) EBP 레지스터가 오염되어 지역 변수에 잘못 접근할 때
    b) 함수가 `return`하기 전, 스택에 저장된 리턴 주소(return address)가 오염될 때
    c) 함수가 `return` 없이 종료되어 EAX 레지스터에 쓰레기 값이 남을 때
    d) 동적 할당된 메모리(힙)에서 버퍼 오버플로우가 발생할 때

5.  **난수 생성**과 관련된 문제입니다. `rand()`와 `srand()`를 사용한 의사 난수 생성 시스템에서, **동일한 난수열을 항상 재현**하기 위해 필요한 것은 무엇인가요?
    a) `srand()` 함수를 매번 호출하지 않습니다.
    b) `time(nullptr)` 대신 고정된 시드(seed) 값을 `srand()`에 전달합니다.
    c) 난수 생성 로직을 멀티스레드 환경에서 분리합니다.
    d) `rand()`를 호출하기 전에 항상 `srand()`를 호출합니다.

6.  **어셈블리 명령어**와 관련된 문제입니다. 32비트 환경에서 함수가 지역 변수를 위해 스택 공간을 할당할 때, 컴파일러는 주로 어떤 명령어를 사용하나요?
    a) `push eax`
    b) `add esp, [크기]`
    c) `sub esp, [크기]`
    d) `mov esp, [크기]`

---

**정답 및 해설**

1.  **정답: b)** EBP(Extended Base Pointer)는 함수 스택 프레임의 기준점 역할을 하여 지역 변수나 매개변수에 상대 주소로 접근할 수 있게 해줍니다. ESP(Extended Stack Pointer)는 스택의 가장 위(Top)를 가리키며, `push`, `pop`, `sub` 등의 명령어로 스택 공간을 사용하거나 반환할 때 값이 변합니다.

2.  **정답: d)** `int` 함수에 `return` 문이 없는 실행 경로가 있을 경우, 컴파일러는 EAX 레지스터에 남아있는 마지막 값을 그대로 반환합니다. 만약 그 직전에 `printf()`와 같은 함수가 호출되었다면, EAX에는 `printf()`의 반환값(출력된 문자열의 개수)이 남아있게 됩니다. 이는 예측 불가능한 버그의 원인이 될 수 있으므로, 컴파일러는 보통 이런 경우 경고(Warning)를 띄웁니다.

3.  **정답: c)** C++에서 구조체를 값으로 전달하면 함수 호출 시 해당 구조체 전체가 스택에 복사됩니다. 구조체의 크기가 크면 이 복사 과정이 성능 저하를 일으킵니다. 따라서 포인터나 참조를 전달하여 실제 구조체는 한 곳에 두고 주소만 전달하는 것이 가장 효율적입니다.

4.  **정답: b)** 스택 오염이 발생했을 때, 스택에 저장된 리턴 주소(Return Address)가 잘못된 값으로 덮어씌워지면 함수가 종료되고 나서 실행 흐름이 오염된 주소로 이동합니다. 대부분의 경우 이 주소는 실행 불가능한 메모리 영역이므로, 프로그램이 즉시 `Access Violation`과 같은 치명적인 오류와 함께 종료됩니다.

5.  **정답: b)** 의사 난수는 시드(seed) 값이 같으면 항상 동일한 난수열을 생성합니다. 리플레이와 같이 매번 동일한 결과를 재현해야 하는 시스템에서는 `time(nullptr)`처럼 매번 다른 값을 생성하는 시드를 사용해서는 안 됩니다. 대신 고정된 시드 값을 사용하여 예측 가능한 난수열을 유지해야 합니다.

6.  **정답: c)** 지역 변수를 위해 스택 공간을 할당할 때는 `ESP`의 값을 빼서(낮춰서) 스택의 범위를 확장합니다. 예를 들어, `int a[3]`에 필요한 12바이트 공간을 할당하기 위해 `sub esp, 0Ch`와 같은 명령어를 사용합니다. `push`는 데이터를 스택에 넣는 명령어이고, `add`는 스택의 범위를 줄일 때(함수 종료 직전) 사용됩니다.