훌륭합니다. 지난번 퀴즈는 모두 맞히셨네요! 특히 3번 문제는 정답을 맞히고 이유까지 정확하게 추리한 점이 인상적입니다. 👍 그럼 다음 챕터로 넘어가서 바로 문제를 내드리겠습니다. 이번에도 지난 수업 내용들을 바탕으로, 조금씩 헷갈릴 수 있도록 문제를 구성해 봤습니다.

---

### **정리된 퀴즈**

다음은 250716 수업 내용을 바탕으로 핵심 개념을 확인하는 문제들입니다.

1.  **전위/후위 연산자**에 관련된 문제입니다. 일반적인 `int` 타입의 변수에 대해 **`a++;` (후위 연산)**와 **`++a;` (전위 연산)** 중 어떤 것이 더 효율적이라고 할 수 있나요?
    a) `a++;`는 연산 전에 원래 값을 임시 변수에 저장하는 과정이 추가되므로, `++a;`가 항상 더 효율적입니다.
    b) `++a;`는 증가 후 값을 사용하기 때문에 별도의 사본을 만들 필요가 없어, 대부분의 경우 `a++;`보다 효율적입니다.
    c) `a++;`는 `++a;`보다 더 짧은 어셈블리 명령어를 사용하므로, 더 효율적입니다.
    d) 두 연산자는 컴파일러 최적화에 의해 동일한 어셈블리 코드로 변환되므로, 성능 차이가 없습니다.

2.  **비트 연산**에 관련된 문제입니다. `0xAF` 값을 가진 변수 `a`가 있을 때, 특정 비트 그룹의 값을 다른 값으로 바꾸지 않고 **유지하면서** 다른 비트 그룹의 값을 `0`으로 만들고자 합니다. 이때 사용해야 하는 비트 연산자와 마스킹 값은 무엇인가요?
    a) `OR` 연산자와 `0xF0` 마스크
    b) `XOR` 연산자와 `0x0F` 마스크
    c) `AND` 연산자와 `0xF0` 마스크
    d) `Shift` 연산자와 `4`

3.  **switch-case 문**에 관련된 문제입니다. C/C++ 컴파일러가 대규모 `switch-case`문을 처리할 때, `if-else`문보다 훨씬 빠르게 실행되도록 하는 경우가 많습니다. 이러한 최적화가 가능한 가장 핵심적인 이유는 무엇인가요?
    a) `switch-case`문은 컴파일 시 **JMP(점프) 테이블**을 생성하여 조건 검사 없이 해당 코드로 바로 이동하기 때문입니다.
    b) `switch-case`문은 CPU의 L1 캐시를 효율적으로 사용하여 `if-else`문보다 메모리 접근이 빠르기 때문입니다.
    c) `switch-case`문은 멀티스레딩을 지원하여 여러 조건을 동시에 검사할 수 있기 때문입니다.
    d) `switch-case`문은 컴파일러가 예측 분기(branch prediction)를 더 쉽게 수행할 수 있도록 돕기 때문입니다.

4.  **삼항 연산자**에 관련된 문제입니다. C/C++에서 `int a = (b == 30) ? 10 : 20;` 와 같은 삼항 연산자를 사용했을 때, 어셈블리 코드 상에서 어떤 식으로 처리되나요?
    a) `if-else` 문과 완전히 다른, 더 효율적인 단일 CPU 명령어로 변환됩니다.
    b) `if-else` 문과 유사하게 조건 분기(branch)를 사용하여 구현되며, 최적화가 되지 않으면 성능 차이가 크지 않습니다.
    c) 최적화 컴파일러가 이 코드를 `mov` 명령어로 최적화하여 조건 검사 없이 바로 값을 할당합니다.
    d) 삼항 연산자는 런타임에 해석되므로, 컴파일 시에는 특별한 어셈블리 코드를 생성하지 않습니다.

5.  **비트 플래그(Flag)**에 관련된 문제입니다. 윈도우 프로그래밍에서 `CreateWindow` 함수에 여러 옵션을 동시에 적용하기 위해 `WS_OVERLAPPEDWINDOW | WS_MAXIMIZEBOX | WS_MINIMIZEBOX`와 같이 여러 플래그를 **`|` (OR)** 연산자로 묶어서 사용합니다. 이때 특정 옵션이 적용되었는지 확인하기 위해 사용해야 하는 비트 연산자와 그 이유로 가장 적절한 것은 무엇인가요?
    a) `|` (OR) 연산자. 플래그가 하나라도 1이면 최종 결과가 1이 되기 때문입니다.
    b) `&` (AND) 연산자. 원하는 플래그 비트만 남겨서 값이 있는지 확인하기 때문입니다.
    c) `^` (XOR) 연산자. 해당 플래그 비트만 반전시켜서 값이 변경되었는지 확인하기 때문입니다.
    d) `~` (NOT) 연산자. 해당 플래그 비트를 제외한 나머지 비트를 반전시켜서 확인하기 때문입니다.

---
**정답 및 해설**

1.  **정답: b)** 전위 연산자 `++a;`는 변수 `a`의 값을 먼저 증가시키고 그 값을 사용하기 때문에, 불필요한 사본(copy)을 만들 필요가 없습니다. 반면, 후위 연산자 `a++;`는 연산 **전**의 `a` 값을 반환해야 하므로, 그 값을 임시로 저장하기 위한 사본을 만들어야 합니다. 이 때문에 전위 연산자가 일반적으로 더 효율적입니다.

2.  **정답: c)** **`AND`** 연산자는 두 비트가 모두 1일 때만 결과가 1이 되므로, 특정 비트를 0으로 만들거나 유지하는 데 사용되는 **마스킹(Masking)** 연산의 핵심입니다. `0xAF`(`1010 1111`)에 `0xF0`(`1111 0000`)를 `AND` 연산하면, 하위 4비트는 `0`으로 바뀌고 상위 4비트(`1010`)는 그대로 유지되어 `0xA0`가 됩니다.

3.  **정답: a)** `switch-case`문은 컴파일러가 상수 값들을 이용하여 **점프 테이블(Jump Table)**을 생성할 수 있습니다. 이 테이블은 각 `case`문에 해당하는 코드의 메모리 주소를 담고 있으며, `switch`문의 조건식을 평가한 후 조건에 맞는 주소로 바로 점프하여 코드를 실행합니다. 이 방식은 `if-else`문처럼 모든 조건을 순차적으로 검사할 필요가 없으므로 매우 빠릅니다. 

4.  **정답: b)** 삼항 연산자 `(b == 30) ? 10 : 20;`는 어셈블리 코드 상에서 `if-else` 문과 동일하게 **조건 분기**(`cmp`, `je` 등)를 통해 구현됩니다. 따라서 최적화가 적용되지 않으면 성능상 큰 차이가 없습니다. 컴파일러가 이 코드를 `if-else`문과 유사한 형태로 변환하여 처리합니다.

5.  **정답: b)** 여러 플래그들이 `|` 연산자로 합쳐져 있을 때, 특정 플래그가 포함되어 있는지 확인하려면 **`&` (AND)** 연산자를 사용해야 합니다. `&` 연산자는 해당하는 비트만 남기고 나머지를 0으로 만듭니다. 만약 결과가 0이 아니라면, 해당 플래그가 켜져 있었다는 것을 의미합니다.