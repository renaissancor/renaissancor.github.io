좋은 지적 감사합니다. 꼼꼼하게 확인해주셔서 저도 실수를 바로잡을 수 있었습니다.

첫 번째 문제 해설에서 말씀하신 대로, 초기화된 전역 변수는 실행 파일의 `.data` 섹션에 저장되는 것이 맞습니다. `.text` 섹션은 실행 코드가 들어가는 영역이고, `.bss`는 초기화되지 않은 전역 변수 영역입니다.

해설에 오류가 있었던 점 다시 한번 사과드립니다. 다음 챕터로 넘어가서 바로 문제를 내 드릴게요.

---

### **정리된 퀴즈**

다음은 250709 수업 내용을 바탕으로 핵심 개념을 확인하는 문제들입니다. 기존 노트에서 다루었던 용어와 개념을 중심으로 문제를 만들었습니다.

1.  **전역 변수 메모리**에 관련된 문제입니다. 초기화된 전역 변수(e.g., `int g_a = 1;`)와 초기화되지 않은 전역 변수(e.g., `int g_b;`)가 메모리에 저장되는 방식의 가장 큰 차이점은 무엇인가요?
    a) 초기화된 전역 변수는 **스택**에 저장되고, 초기화되지 않은 전역 변수는 **힙**에 저장됩니다.
    b) 초기화된 전역 변수는 **`.data`** 영역에 포함되어 실행 파일(.exe)의 크기를 늘리지만, 초기화되지 않은 전역 변수는 **`.bss`** 영역에 속해 실행 파일에 포함되지 않습니다.
    c) 초기화된 전역 변수는 **읽기 전용(Read-Only)** 속성을 가지지만, 초기화되지 않은 전역 변수는 그렇지 않습니다.
    d) 초기화된 전역 변수는 **런타임**에 값이 할당되고, 초기화되지 않은 전역 변수는 **컴파일 타임**에 할당됩니다.

2.  **`const` 키워드**에 관련된 문제입니다. 지역 변수에 `const`를 붙인 후(e.g., `const int a = 100;`) 포인터를 사용하여 값을 강제로 변경하면 어떤 결과가 발생하나요?
    a) 컴파일 에러가 발생하여 아예 빌드가 되지 않습니다.
    b) `const` 변수는 읽기 전용 영역에 저장되므로, 런타임에 쓰기 접근 위반 에러가 발생합니다.
    c) 값은 정상적으로 변경되지만, 컴파일러가 최적화로 인해 해당 값을 상수로 대체하여 예상과 다른 결과가 출력될 수 있습니다.
    d) 포인터를 통한 변경이 허용되지 않아 아무런 변화가 없습니다.

3.  **`volatile` 키워드**에 관련된 문제입니다. `volatile` 키워드가 특정 변수에 적용될 때(e.g., `volatile int g_a;`), 컴파일러의 동작에 어떤 영향을 미치나요?
    a) 해당 변수가 항상 **CPU 캐시**를 거치지 않고 **물리 메모리**에 직접 접근하도록 만듭니다.
    b) 해당 변수의 값 변경을 최적화하여 더 빠르게 접근할 수 있게 합니다.
    c) 해당 변수가 사용된 모든 연산에 대해 **컴파일러 최적화**를 막고, 메모리 접근을 유지하도록 강제합니다.
    d) 해당 변수가 특정 스레드에서만 사용되도록 접근을 제한합니다.

4.  **컴파일 과정**에 관련된 문제입니다. 두 개의 소스 파일(a.cpp, b.cpp)이 있을 때, a.cpp에 `int g_x;`라고 전역 변수를 선언하고, b.cpp에서 `int g_x;`를 또 선언하면 **링킹 오류**가 발생합니다. 이 문제를 해결하기 위해 b.cpp에서 사용해야 하는 키워드는 무엇인가요?
    a) `static`
    b) `volatile`
    c) `extern`
    d) `register`

5.  **어셈블리 명령어**와 관련된 문제입니다. `sub esp, 4`와 `push ecx` 명령어는 모두 스택 포인터(ESP)를 4바이트만큼 이동시킵니다. 일반적으로 `push ecx`가 더 선호될 수 있는 이유로 언급된 것은 무엇인가요?
    a) `push ecx`가 `sub esp, 4`보다 더 많은 레지스터를 사용하여 더 효율적이기 때문입니다.
    b) `push ecx`는 스택 메모리에 직접 접근하여 `sub esp, 4`보다 성능이 훨씬 빠르기 때문입니다.
    c) `push ecx`는 명령어 길이가 더 짧아(1바이트) CPU가 읽어오는 속도가 더 빠르기 때문입니다.
    d) `sub esp, 4`는 `push ecx`와 달리 다른 레지스터의 값을 덮어쓸 위험이 있기 때문입니다.

6.  **어셈블리 디버깅**에 관련된 문제입니다. Visual Studio 디버거에서 과거의 어셈블리 코드를 역으로 추적할 때, 특정 명령어(예: `in al, dx`)가 잘못 해석되어 보이는 경우가 있습니다. 이 현상이 발생하는 **가장 근본적인 원인**은 무엇인가요?
    a) `x86-64` 아키텍처의 명령어 길이가 **고정적이지 않기** 때문입니다.
    b) `in al, dx`가 외부 하드웨어 장치에 접근하는 특수한 명령어이기 때문입니다.
    c) 디버거가 **스택**과 **힙** 메모리를 구분하지 못해 발생하는 오류입니다.
    d) 컴파일러가 **디버그 모드**에서 불필요한 코드를 삽입하기 때문입니다.

--- 

1.  **정답: b)**
    * **설명:** 초기화된 전역 변수와 문자열 리터럴은 **`.data`** 섹션에 저장되어 실행 파일(.exe)에 포함됩니다. 반면, 초기화되지 않은 전역 변수는 **`.bss`** 섹션에 저장되며, 이 영역은 실행 파일에 포함되지 않고 프로그램이 로드될 때 0으로 초기화될 공간만 예약해 둡니다.

2.  **정답: c)**
    * **설명:** 지역 변수에 `const`를 붙이면 컴파일러는 이 변수를 상수처럼 취급하여, 해당 변수가 사용된 코드에 직접 값을 박아넣는 최적화를 수행할 수 있습니다. 따라서 포인터를 통해 값을 변경하더라도, `printf()`와 같은 함수는 이미 최적화된 상수 값을 사용하므로 변경 전의 값이 출력됩니다. 지역 변수는 **스택**에 할당되므로 `const`를 붙여도 쓰기 접근 위반 에러가 발생하지 않습니다.

3.  **정답: c)**
    * **설명:** `volatile` 키워드의 주된 목적은 컴파일러의 최적화를 명시적으로 막는 것입니다. 컴파일러는 코드를 분석해 불필요한 메모리 접근을 줄이려 하지만, `volatile`이 붙은 변수는 값이 언제든 외부 요인(예: 다른 스레드, 하드웨어)에 의해 바뀔 수 있다고 가정하고, 모든 접근을 메모리에서 직접 하도록 강제합니다.

4.  **정답: c)**
    * **설명:** `int g_x;`는 변수를 선언(declaration)하면서 동시에 정의(definition)하는 것입니다. 두 개의 파일에 동일한 변수를 정의하면 링커는 "두 개의 `g_x`가 있다"며 충돌을 일으킵니다. 이를 해결하려면, 한 파일에서 정의하고 다른 파일에서는 `extern` 키워드를 사용해 "어딘가에 `g_x`라는 변수가 정의되어 있으니, 가져와서 사용하겠다"고 선언만 해야 합니다.

5.  **정답: c)**
    * **설명:** `sub esp, 4`는 기계어 코드가 여러 바이트로 구성되지만, `push ecx`는 1바이트짜리 기계어 코드로 표현될 수 있습니다. CPU는 짧은 명령어를 더 빠르게 읽어올 수 있으므로, 성능 최적화를 위해 짧은 명령어가 선호될 수 있습니다.

6.  **정답: a)**
    * **설명:** `x86-64` 아키텍처는 **CISC(Complex Instruction Set Computer)** 방식으로, 명령어의 길이가 일정하지 않습니다. 디버거가 실행된 기계어 코드를 역으로 해석하여 어셈블리어로 보여줄 때, 명령어 경계를 잘못 판단하면 엉뚱한 명령어를 보여줄 수 있습니다. RISC(Reduced Instruction Set Computer)는 명령어 길이가 고정되어 있어 이런 문제가 거의 없습니다.