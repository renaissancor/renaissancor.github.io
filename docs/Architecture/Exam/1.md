# 핵심 요약: 어셈블리 및 메모리 구조 

이 노트는 Windows OS의 스택 메모리, CPU의 동작 원리, 어셈블리어의 기본 개념을 정리한 내용입니다. 특히 C/C++ 프로그램이 컴파일되어 실제 기계어(어셈블리어)로 어떻게 변환되고 실행되는지에 초점을 맞추고 있습니다.

---

## 1. Windows OS와 스택

* **스택 크기**: Windows OS에서 스택 메모리의 기본 크기는 **1MB** 입니다. 이 크기를 초과하면 **스택 오버플로우(Stack Overflow)** 오류가 발생합니다.
* **스택의 역할**: 스택은 함수 호출 시 지역 변수, 매개변수, 복귀 주소 등을 저장하는 메모리 영역입니다. 함수가 호출되면 스택에 쌓이고, 함수가 종료되면 해당 스택 프레임은 소멸됩니다.

---

## 2. CPU와 메모리 계층

* **CPU 연산**: CPU는 오직 **레지스터(Register)**에 있는 값만 연산할 수 있습니다. RAM, SSD 등 다른 보조 메모리에 있는 데이터는 연산 전에 반드시 레지스터로 옮겨와야 합니다.
* **메모리 계층**: CPU는 연산 속도 순서대로 **레지스터 -> 캐시 -> RAM -> SSD** 순으로 데이터를 주고받습니다. 이들 사이의 데이터 통신은 **버스(BUS)**를 통해 이루어집니다.
* **CPU 명령어**: CPU는 수백 가지의 단순한 기계어(0과 1) 명령어를 가지고 있습니다. 이 기계어를 사람이 이해하기 쉽게 만든 언어가 바로 **어셈블리어**입니다. 

---

## 3. 어셈블리어의 이해

* **학습 목표**: 어셈블리 코딩이 아니라 **독해(읽기)**가 목표입니다. 복잡한 로직을 어셈블리어로 직접 구현하는 것은 어렵기 때문에, C/C++ 코드가 어떤 어셈블리어로 변환되는지 이해하는 것이 중요합니다.
* **32비트 vs. 64비트**: 학습용으로는 32비트 어셈블리어로 시작하는 것을 추천합니다. 64비트 컴파일러는 성능 최적화를 위해 코드를 더 복잡하게 만들기 때문입니다.
* **레지스터 이름**:
    * **e**로 시작: 32비트 레지스터 (eax, ebx, ecx 등)
    * **r**로 시작: 64비트 레지스터 (rax, rbx, rcx 등)
    * 하위 호환성을 위해 64비트 CPU에서도 32, 16, 8비트 레지스터를 사용할 수 있습니다.
* **주요 레지스터**:
    * **ebp (Extended Base Pointer)**: 현재 스택 프레임의 **시작 주소**를 가리키는 포인터입니다. 함수 내부의 지역 변수 위치를 계산하는 기준점이 됩니다.
    * **esp (Extended Stack Pointer)**: 현재 스택의 **최상단 주소**를 가리키는 포인터입니다. 스택에 데이터가 쌓이거나(push) 제거될 때(pop) 이 값이 변합니다.
    * **eax, ecx, esi, edi**: 용도가 정해져 있지만, 범용적으로 사용 가능한 레지스터입니다.
        * **ecx**: `rep`나 `loop` 같은 반복문 관련 명령어에서 카운터 역할을 합니다.
        * **esi**, **edi**: 주로 메모리 복사 작업 시 사용됩니다. `esi`는 소스(Source), `edi`는 목적지(Destination)를 나타냅니다.

---

## 4. 함수 호출과 스택 프레임

* **지역 변수 저장**: 함수의 지역 변수는 스택에 저장되며, 함수 종료 시 자동으로 소멸됩니다.
* **절대 주소 vs. 상대 주소**:
    * **전역 변수**: 프로그램 실행 내내 주소가 고정되어 있어 **절대 주소**로 접근합니다.
    * **지역 변수**: 함수가 언제 호출되느냐에 따라 스택에 할당되는 위치가 달라지므로 **상대 주소**로만 표현할 수 있습니다.
    * **스택 프레임**: 함수는 자신의 스택 프레임(ebp부터 esp까지의 영역)을 기준으로 지역 변수의 위치를 계산합니다.
* **스택 공간 확보**: 컴파일러는 함수 진입 시 필요한 지역 변수 전체 크기를 계산하여 **`sub esp, [크기]`** 명령어로 한 번에 스택 공간을 확보합니다. 변수가 1개든 1,000개든 확보하는 시간은 동일합니다.
* **디버그 모드**: 디버그 모드에서는 코드 수정 등을 위해 필요 이상으로 스택 공간을 미리 많이 확보하기도 합니다.

---

## 5. 어셈블리어 명령어

* **`mov`**: 레지스터 간 또는 레지스터와 메모리 간의 값을 복사합니다.
* **`lea` (Load Effective Address)**: 주소를 계산하는 명령어입니다. `mov`와 유사하지만, 계산된 값을 주소로 인식하여 대입합니다. 가독성을 위해 사용합니다.
* **`push`**: 스택에 데이터를 넣고 `esp`를 자동으로 감소시킵니다. (32비트 기준 4바이트, 64비트 기준 8바이트 단위)
* **`pop`**: 스택에서 데이터를 빼고 `esp`를 자동으로 증가시킵니다.
* **`[ ]` (대괄호)**: 포인터 역참조를 의미합니다. `mov eax, [ebp]`는 `ebp`가 가리키는 메모리 주소의 값을 `eax`에 가져오는 명령어입니다.

---

## 6. 디버깅 팁

* **Visual Studio 디버깅**:
    * **F9**: 브레이크 포인트 설정
    * **F5**: 디버그 시작
    * **`Ctrl + Alt + D`**: 디스어셈블리 창 열기
    * 디버그 모드로 프로그램을 실행하면서 디스어셈블리 창을 띄워 C/C++ 코드가 어떤 어셈블리어로 변환되는지 눈으로 직접 확인하는 연습을 하면 좋습니다.

이 노트를 통해 어셈블리와 메모리 구조에 대한 이해를 높이고, 실제 프로그래밍과 컴퓨터 구조 사이의 연결고리를 파악하는 데 도움이 되길 바랍니다. 💻🤓