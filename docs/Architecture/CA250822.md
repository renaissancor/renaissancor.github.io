# 1. 데드락 (Deadlock)과 동기화

**데드락**은 여러 쓰레드가 서로 다른 자원을 점유하고, 상대방이 점유한 자원을 요구하며 무한정 대기하는 상태를 말합니다. 데드락이 발생하려면 다음의 4가지 조건이 모두 충족되어야 합니다.

1.  **상호 배제 (Mutual Exclusion)**: 한 번에 한 쓰레드만 자원을 사용할 수 있습니다.
2.  **점유와 대기 (Hold and Wait)**: 자원을 점유한 상태에서 다른 쓰레드가 가진 자원을 기다립니다.
3.  **비선점 (No Preemption)**: 쓰레드가 자원을 자발적으로 놓아줄 때까지 다른 쓰레드가 그 자원을 강제로 뺏을 수 없습니다.
4.  **순환 대기 (Circular Wait)**: 자원을 기다리는 쓰레드들이 원을 이루고 있습니다. (A는 B를, B는 C를, C는 A를 기다리는 식)

**동기화 객체**는 데드락을 유발할 수 있으므로, 사용 시 주의해야 합니다. 특히, 여러 자원에 대한 락(Lock)을 획득하는 순서가 중요합니다. 예를 들어, 모든 쓰레드가 락을 동일한 순서로 획득하면 순환 대기 조건이 깨져 데드락을 방지할 수 있습니다.

---

### 2. 쓰레드 (Thread)의 종류

운영체제에서 쓰레드는 크게 두 가지로 나뉩니다.

* **커널 레벨 쓰레드 (Kernel-Level Thread)**: 운영체제 커널이 직접 관리하고 스케줄링하는 쓰레드입니다. 여러 CPU 코어에 병렬로 할당되어 **진정한 병렬 처리(Parallelism)**를 가능하게 합니다. C/C++에서 `std::thread`, Windows API의 `CreateThread`, `_beginthreadex`로 생성하는 쓰레드는 모두 커널 쓰레드입니다.
* **유저 레벨 쓰레드 (User-Level Thread)**: 사용자 공간에서 라이브러리가 관리하는 쓰레드입니다. 커널은 이들을 하나의 커널 쓰레드로 인식하므로, **병렬 처리(Parallelism)는 불가능**하고, 하나의 코어에서 **동시성(Concurrency)**만 제공합니다. 대표적인 예로 C++20의 **코루틴(Coroutines)**이나 C#의 코루틴이 있습니다. 

코루틴은 **I/O 작업이나 대기 시간이 긴 작업**을 처리할 때 유용합니다. 커널 쓰레드를 생성하는 것보다 오버헤드가 적기 때문에, 게임 로딩 화면처럼 "잠깐 멈췄다가 다시 진행"해야 하는 비동기 작업에 주로 사용됩니다.

---

### 3. 파일 입출력 (File I/O)

파일 입출력은 C/C++ 표준 라이브러리를 사용하거나(예: `fopen`, `fread`), 운영체제 API를 직접 호출하여(예: `CreateFile`, `ReadFile`) 수행할 수 있습니다.

#### **텍스트 모드 vs. 바이너리 모드**

* **텍스트 모드**: 파일의 줄바꿈(`\n`) 문자를 운영체제에 맞게 자동으로 변환합니다. Windows는 `\n`을 `0D0A`(`CRLF`)로, Linux는 `0A`(`LF`)로 변환합니다. 이는 텍스트 파일을 다룰 때 편리하지만, 순수한 데이터 파일(바이너리)을 다룰 때는 데이터가 손상될 수 있습니다.
* **바이너리 모드**: 데이터 변환 없이 파일 내용을 순수한 바이너리 그대로 읽고 씁니다. 게임 데이터 파일처럼 `0`과 `1`로 이루어진 데이터를 다룰 때는 항상 바이너리 모드(`"rb"`, `"wb"`)를 사용해야 합니다.

#### **파일 버퍼링 (File Buffering)**

파일 입출력은 디스크 접근이 포함되므로 매우 느립니다. 이를 최적화하기 위해 운영체제와 C/C++ 표준 라이브러리는 **파일 버퍼링**을 사용합니다.

* **C/C++ 버퍼링**: `fopen`, `fread`와 같은 함수들은 즉시 디스크에 접근하지 않고, 내부 버퍼(일반적으로 4KB)를 사용하여 데이터를 임시로 저장합니다.
    * `fclose()`: 파일을 닫으면 버퍼에 남은 데이터를 모두 디스크에 씁니다.
    * `fflush()`: 버퍼의 내용을 강제로 디스크에 씁니다. 프로그램이 갑자기 종료될 때 로그가 유실되는 것을 막기 위해 `fflush`를 주기적으로 호출하는 것이 좋습니다.
* **OS 파일 캐시**: 운영체제는 디스크 I/O를 최소화하기 위해 **파일 캐시**를 RAM에 유지합니다. `fclose`나 `fflush`를 호출해도 데이터가 즉시 디스크에 저장되지 않고 OS 파일 캐시로 들어갑니다. USB 장치를 "안전하게 제거"하는 것도 이 캐시 때문이다.

#### **파일 입출력 최적화**

* **최소한의 I/O 횟수**: 작은 데이터를 여러 번 읽고 쓰는 것보다, 파일을 한 번에 통째로 메모리에 올려서 처리하는 것이 훨씬 효율적입니다. `fread`를 사용해 파일 크기만큼 한 번에 읽어 메모리 버퍼에 저장하는 것이 일반적입니다.
* **파일 포지션**: `fseek`와 `ftell` 함수를 이용해 파일 포인터의 위치를 조절할 수 있습니다. `fseek(pFile, 0, SEEK_END)`와 `ftell(pFile)`을 조합하면 파일의 전체 크기를 쉽게 얻을 수 있습니다.

#### **과제: 파일 암호화/복호화**

제공해주신 과제는 XOR 연산을 사용해 파일을 암호화하고 복호화하는 기능입니다.

* **구현 로직**:
    1.  사용자로부터 파일 경로를 입력받습니다.
    2.  `fopen`을 `"rb"` 모드로 열고, `fseek`와 `ftell`로 파일 크기를 얻습니다.
    3.  파일 크기만큼 메모리를 할당하고 `fread`로 전체 내용을 읽어옵니다.
    4.  메모리에 올라온 데이터를 XOR 연산으로 암호화/복호화합니다.
    5.  `fopen`을 `"wb"` 모드로 열고 `fwrite`로 결과를 저장합니다.
    6.  `fclose`로 파일을 닫고 메모리를 해제합니다.
* **헤더 사용**: 파일의 암호화 여부나 무결성을 확인하기 위해 파일 내용의 맨 앞에 특정 **헤더(Header)**를 추가하는 것이 좋습니다.
    * 예: 파일의 고유 ID나 해시 값(MD5, SHA-256 등)을 헤더에 저장합니다.
    * 복호화 후, 계산된 해시 값이 헤더에 저장된 해시 값과 일치하는지 확인하여 파일이 손상되지 않았는지, 올바르게 복호화되었는지 검증할 수 있습니다.