# Hash Function 

Input Output 
Asynchronous I O 

Overlapped I/O is designed to return function very quickly 
returning the function before I/O is complete. 
I/O is done by Device, rather than OS. 

CoRoutine is NOT Completion Routine of Overlapped Non-Blocking I/O 

Virtual Allocation 

`VirtualAlloc` 
`HeapAlloc` 

C Style Casting 

`static_cast` 
`dynamic_cast` 

Operator priority 

SleepEx 

Alertable


All Threads attached to different Core use different cache data. 
Data inside Cache is managed by cache lin eunit. 

If there are two close variables inside one cache line 64KB 
and get modified by each different thread, it might be problematic. 
Suppose `struct Type {int a, int b};`. This data is 
very likely to be inside same cache line. 

Core 1 Reads a only 
Core 2 Reads b only 

When Write happens, among MESI 
One cache line that is written by Core 1, then 
That cache line will become exclusive, and the same address cache line 
existing in Core 2 will become invalid. 
Core 2 will wait for that cache line becoming shared status again until 
that Cache Line is rewritten completely. 

Cache Line 64 Byte size based `struct` is made to test Cache Line MESI. 

```cpp
struct Point {
    volatile int x; 
    alignas(64) // Ensure that the structure is aligned to a 64-byte boundary
    // char padding[64 - sizeof(int)];
    volatile int y;
};

Point g_point; // Global Variable 
```

Test function for the thread is following. 

```cpp
static unsigned int __stdcall testa(void*) { 
    SetThreadAffinityMask(GetCurrentThread(), 0x2);
	ULONGLONG dwStart = GetTickCount64();
    LARGE_INTEGER start, end, frequency;
    QueryPerformanceFrequency(&frequency);

    for (size_t i = 0; i < ((size_t)2 << 8); ++i) {
        QueryPerformanceCounter(&start);
        for (size_t i = 0; i < ((size_t)2 << 20); ++i) g_point.x++;
        QueryPerformanceCounter(&end);
        double elapsed = (double)(end.QuadPart - start.QuadPart) * 1000.0 / frequency.QuadPart;
        printf("Thread A inner loop took %.3f ms\n", elapsed);
    }
    
    ULONGLONG   dwEnd = GetTickCount64();
    Sleep(100); // Ensure that thread A has time to run
	printf("Thread A: %llu ms\n", dwEnd - dwStart); 
	printf("Pointer A: %p, B: %p\n", &g_point.x, &g_point.y);
	return 0;
}
```

Reading Function is implemented to check Cache Line  

```cpp
static unsigned int __stdcall testr(void*) {
    SetThreadAffinityMask(GetCurrentThread(), 0x3);
    ULONGLONG dwStart = GetTickCount64();
    LARGE_INTEGER start, end, frequency; 

    volatile int* c = &g_point.y; 
    volatile int dummy = 0;

    QueryPerformanceFrequency(&frequency);
    for (size_t i = 0; i < ((size_t)2 << 8); ++i) {
        QueryPerformanceCounter(&start);
        for (size_t i = 0; i < ((size_t)2 << 20); ++i) {
            dummy += *c;
        }
        QueryPerformanceCounter(&end);
        double elapsed = (double)(end.QuadPart - start.QuadPart) * 1000.0 / frequency.QuadPart;
        printf("Thread R inner loop took %.3f ms\n", elapsed);
    }
    
    ULONGLONG   dwEnd = GetTickCount64();
    Sleep(100); // Ensure that thread B has time to run
    printf("Thread R: %llu ms\n", dwEnd - dwStart);
    printf("Pointer A: %p, B: %p\n", &g_point.x, &g_point.y); 
	printf("Pointer C: %p\n", c);
	return 0;
}
``` 

Main function is following. 

```cpp
#include <windows.h>
#include <process.h> 
#include <iostream>

using namespace std; 

int main(int argc, char* argv[])
{
	HANDLE* hThreads = new HANDLE[2];

    unsigned int threadAID; 
	unsigned int threadBID;

    hThreads[0] = (HANDLE)_beginthreadex(
        NULL, 0, &testa, NULL, 0, &threadAID
    ); 

    if (hThreads[0] == NULL) {
		printf("Error creating thread A: %d\n", GetLastError());
        return 1;
	}

    hThreads[1] = (HANDLE)_beginthreadex(
        NULL, 0, &testr, NULL, 0, &threadBID
	); 

    if (hThreads[1] == NULL) {
        printf("Error creating thread B: %d\n", GetLastError());
        return 1;
	}

    WaitForMultipleObjects(
        2, hThreads, TRUE, INFINITE
	);

	CloseHandle(hThreads[0]);
    CloseHandle(hThreads[1]);

    delete [] hThreads; 
    
	return 0;
}
```
