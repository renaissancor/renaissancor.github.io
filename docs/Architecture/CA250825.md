### 1\. DB 활용과 CPU 코어 사용

게임 서버는 웹 서버와는 다르게 실시간 상호작용이 많아 **멀티쓰레드 설계가 매우 어렵습니다.** 웹 서버는 각 요청을 병렬로 처리할 수 있어 CPU 코어를 효율적으로 활용하는 반면, 게임 서버는 공유 자원(Shared resources)이 많아 동기화(Synchronization) 문제가 빈번하게 발생합니다.

  * **CPU 사용률과 로직**: CPU 사용률은 로직의 복잡성보다는 \*\*처리하는 시간(사용 시간)\*\*과 관련이 있습니다. 로직이 아무리 무거워도 사용 시간이 짧으면 CPU 사용률은 낮게 나타납니다. 코어가 8개인데 쓰레드 1개만 100% 사용하고 있다면, 전체 CPU 사용률은 12.5%에 불과합니다.

  * **DB 활용**: DB는 디스크 I/O가 필수적이므로 CPU 연산에 비해 매우 느립니다. 게임 로직은 나노초 단위로 돌아가지만, DB I/O는 밀리초 단위입니다. 따라서 DB에 과도한 부하가 걸리면 전체 서버 성능 저하로 이어집니다. 게임 서버의 효율은 CPU 코어 활용뿐만 아니라, **DB를 얼마나 잘 활용하는가**에도 달려있습니다.

-----

### 2\. 파일 패킹 (File Packing)

파일 패킹은 여러 개의 파일을 하나로 묶는 과정을 말합니다. 이는 압축과는 다른 개념이며, 주로 다음의 이유로 사용되었습니다.

  * **디스크 공간 절약**: 과거에는 디스크 할당 단위가 커서(예: 4KB), 1바이트짜리 파일도 4KB의 공간을 차지했습니다. 여러 파일을 하나로 묶으면 이러한 낭비 공간을 줄일 수 있습니다.
  * **데이터 노출 방지**: 게임 리소스 파일(이미지, 사운드 등)을 외부에서 쉽게 열어보는 것을 막기 위해 사용되었습니다.

**일반적인 파일 패킹 구조**:

  * **헤더(Header)**: 패킹 파일의 전반적인 정보를 담고 있습니다. 최소한 **파일의 개수**나 **총 용량** 정보를 포함합니다.
  * **파일 정보 블록**: 각 파일에 대한 정보를 담는 구조체 배열입니다. `파일명`, `파일 크기`, 그리고 **파일 데이터의 시작 위치(오프셋)** 정보를 포함하여 특정 파일을 빠르게 찾을 수 있도록 합니다.

<!-- end list -->

```cpp
struct FileInfo {
    char Name[32];   // 32바이트 고정 크기 파일 이름
    int FileSize;    // 파일 크기 (바이트)
    int Offset;      // 파일 데이터 시작 위치
};
```

**과제 수행을 위한 팁**:

  * **파일 읽기/쓰기**: C 스타일의 `fopen`, `fread`, `fwrite` 함수를 사용하거나, C++ 스타일의 `ifstream`, `ofstream` 스트림 클래스를 사용할 수 있습니다. `ftell` 함수를 사용하면 파일 크기를 얻을 수 있지만, 64비트 시스템에서는 `_ftelli64`를 사용하는 것이 더 안전합니다.
  * **XOR 암호화**: 암호화와 복호화에 동일한 키를 사용하는 XOR 연산은 구현이 간단하여 파일 보호 목적으로 자주 사용됩니다. 복호화 후 데이터의 무결성을 검증하기 위해 **원본 파일의 해시 값**을 헤더에 함께 저장하고, 복호화된 데이터의 해시 값과 비교하는 것이 좋습니다.

-----

### 3\. 게임 엔진의 기본: 더블 버퍼링

콘솔 애플리케이션이나 게임에서 화면 깜빡임(flickering)은 흔한 문제입니다. 이는 화면에 여러 오브젝트를 그리는 과정이 우리 눈에 보이기 때문입니다.

  * **문제 발생 원인**: 배경을 그리고, 캐릭터를 지웠다가 다시 그리는 과정이 프레임마다 반복될 때, 우리 눈은 이 과정의 중간 상태를 보게 되어 깜빡이는 것처럼 느껴집니다.

  * **더블 버퍼링 (Double Buffering)**: 이 문제를 해결하기 위한 기술입니다.

    1.  **백 버퍼(Back Buffer)**: 우리 눈에 보이지 않는 메모리 공간(버퍼)에 다음 프레임의 그림을 완성합니다.
    2.  **전면 버퍼(Front Buffer)**: 완성된 그림을 우리 눈에 보이는 실제 화면(전면 버퍼)에 **한 번에 복사**하거나 \*\*버퍼 자체를 통째로 교체(Flip/Swap Chain)\*\*합니다.

이렇게 하면 사용자에게는 완성된 그림만 보이므로 깜빡임이 사라지고 부드러운 화면을 제공할 수 있습니다. 콘솔 화면에서 `cs_MoveCursor`와 같은 함수를 사용하여 커서를 이동시키는 것도 이러한 더블 버퍼링을 구현하기 위한 방법 중 하나입니다.