
Random number generator 
rand value call 

srand value call 

based on different number value page value changes 
number srand 
10 

srand(time(nullptr)); // Time as Seed, Random Page Setup 
completely random ? Mathematically more complicated but anyway quite unpredictable 
day time second etc ... combined to make completely random number 

irandom[i] = rand(); 
If random number is setup between 1 and 100 then 
divide by 100 and do modular calculation 
(rand() % 100 + 1) >> returns 1 ~ 100 random numbers 
64 72 34 ... etc ... 
Since std::map ignore same number input it would automatically overlapping number 

Binary Search Tree Data Removal 

Child object 

virtualization 
parent class should not call object 

Polymorphism 

Child class generated 
then its parent class default generator is called together  

protected only allow access to children and itself 

Inheritance, from parent to child reset order 
compiler order 
Generator initializer only its member 

In a reverse direction reset from parent to children 
however in the terminator it is order from children to parents 

~CChild{
    if (nullptr !- data)
        delete [] data 
    
    // Here unshown parent terminator is called 
}

Default compiler made generator is copy generator. It is automatically generated 
Copy and pasdte data one by one 
Copy generator and inheritance 

Class class2(class1) // same as Class class2 = class1 // Default generator by copy 

Child (const Child& _Other)
:  // Parent(), // In default 
    m_Child(_Other.m_Child)
{

}

Parent default generator is called in this scenario 
Copy generator 

so it should be 


Child (const Child& _Other)
:  Parent(_Other), // Should be this 
    m_Child(_Other.m_Child)
{

}

Constructor 

Class CParent 
class CChild 

CChild:CChild()
: CParent(), 
idx(_idx)

Destructor 

CChild:~CChild()
{

    // 
    ~CParent() 
}

So during the default copy iterator if parent and children data coexist 
chilld class copy generator works 
parent class copy generator but this one might be setup as default generator instead of copy generator 
Thus when explicit copy generator is implemented 
call the parent copy generator intentionally, since default one might breakt it 

## Operator overwriting VS Operator overloading 

Must clearly explain what overwriting and overloading is 

We are currently studying inheritance 

```cpp
class Base \
{
private:
    int m_Base;  
public: 
    void Output()
    {
        cout << " Parent Class " << endl;
    }
public: 
Base(){ }
~Base(){} 
}l 

class Child : public Base() 
{
private:
    int m_Base;  
    Output()
    {
        cout << "Child Class " << endl;
    }
};

int main()
{
    Base base; 
    base.Base::Output(); 
    Child child; 
    child.Child::Output(); 
    return 0;; 
}
```

So function overwriting is 
in the child class, make exactly same function existing in parent class 
So, EXACTLY SAME function NAME and function call parameters 
So it is overwriting 

like 
void Test(){

}

void test(){

}

this one is wrong in the file scope. 

However, for inherited function, this is allowed. 
Same function name with same parameter result in different function structure 

Function overwriting 
parent class pre defiuned function 
inherited child class redefined 
Overwriting 
Parent::Func(int input)
CChild::Func(int input)

Overloading is 
Func() 
Func(int input)
Func(int input1, int input2)

For isntance, animal class 
move function will be different 
same function same no parmaeter 
Snake::Move()
Tiger::Move() 
This is function overwrititg 
Function can be declared for the parent class but 
it can be overwritten inside this complicated class 
especially when class is big
Animal::Move() // Just moving  
Bird::Move()  // Overwiting move to some kind of fly whatever. 

Despite of function overwriting parent function might also be required 

Base base; 
base.Base::Output()l; 

Child child; 
child.Child.Output(); // This is what works for child.output() in default 
However, when child want to use parent function it is also possible 
child.Base.Output(); // This is also possiblee ! So function overwriting in cpp still keeps its parent function usage 
During inheritance function is not completely overwritten removing original function for child class. 
so Parent::Function_Overwritten() can be used. 

Function overwriting 
in inheritance parent class defined function redefined inside the inherited child class 

## Function Overloading 

Class::Func(); 
class:;Func(int a); 

## Polymorphism 

pointer ? Function design ? Very inmprtant  
int main()
{
    Parent P; 
    Child S; 
    Parent *pParent = &P; // 4 Byte No problem 
    Child *pChild = &C; // 4 Byte No problem ?  

    However when 
    pParent = & C; // space 4Byte, should save 8Byte data size. Too big. Parent might be copied to follow Child? 
    pChild = &P;   // space 8Byte, should save 4Byte data size. Child scope became null ? 

    = operator is copy operator. pParent = pChild::Parent this might work, but basic copy function is not likeyl 
    
    Parent Pointer access to child pointer location. Inside pointer location it is 8 byte with 4 byte in front as parent and 4 byte in back. 
    Thus, parent assigned value pointer pointing child pointer can ignore back child part and just copy the parent part of child 

    However, child point er will access to the parent, and WILL read the back part of the parent pointer, where originally child data should be included. 
    Thus, unassigned null ? Trash ? value will be read. 

    sizeof(P); // 4 
    sizeof(S); // 4 + 2 -> 6 -> 8 
    return 0; 
}

It is based on inheritance pointer 

class Parent 
{
private: 
    float m_P; 
}; 

class Child : public Parent 
{
private: 
    short m_S; // 2 Byte, but since it is 2^n structure it should be 8 byte in total adjusting to parent float 4 byte, so 8 byte data type 
}; 


So theoretically since the root parent pointer of really complicated inheritance structure, you can still access by the parent pointer 

Inheritance architecture when you have access to the parent pointer it is possible to access them 
Parent Class pointer type variable is originated from the parent class all inspired class object address is possible to save 
pointing area, should be the most front part of tha t object ()parent area) pointed 

Pointer declaration will 
Thus parent pointer can be used to access any children pointer 

class Player public  Actor 

class Actor 

Game Space includes vector <Actor*> 
Level stage inside actor pointer 
actor pointer 

Tick 
actor Tick function call 

Player monster missile all child classes have their own version of tick function 
Parent class actor tick also exist, and function is overwritten for each 

vector Actor tick player tick called 

If polymorphism is not used level structure will be very complicated 
parent pointer can point out children pointer so 
Parent pointer can point out child pointer 
so save vector of parent class pointer value 

If polymorphism was not available then 
each container for each different class must be existing 

instead of vector <Actor*> m_Actor[]
vector <Player*>
vector <Monster*>
etc ... 
must be required. 

Thus instead of actor, actor pointer is saved, only 4 bytes address value of the parent class 
Access to the player or whatever child class 
Actor driven some child classs might exist, so when access it is easier to code 
Since it is saved as vector pointer, function can be performed 

Parent class pointer CAN point out child class pointer 
this is polymorphism 
parent class pointer vaarialbe, all class object address driven from parent class can be saved 
one type, generated and willl be generated all classs type objects are managable 

In other words one type but pointing classes can be anything inherited from the root parent class type 

virtual function 
polymorphism and virutal function 
several problems driven from the inheritance 

Virtualization 

If just function is declared on the parent node P::Parent.Move() then parent move function is called 
but if child class move is called then function is overwritten 

Howver, if parent address is called by pointer pPointer = &P; 
pParent->Move(); // Parent side move will be called. same as P.Move(); 

pParent = &C; 

Parent class output function for instance, class Animal function Movie is declared. 

Make Sound 

virutla lfunction 

parent pointer parent object point and move call 
parment move is called 

if parent pointer points child object and call move 
child::move should be called but problem is parent::move is called, Since pointing ptr is Parent & inside the game engine scope 
So, since pParent pointed child class function run will call Parent::Move() instead of Child::Move() 
It is not intended consequence, since function overwritting of all child classes became meaningless 
This is problem of polymorphism, when basic parent class function that should be overwritten in child classes will get. 
Statis binding to the parent funciton during compile time since compiler recognize call pointer as parent pointer, so call parent function 
instead of child function that is overwritten in parent function 

virtulal fuinction 

during runtime, according to the real object class overwritten function can be automatically distinguished and called. 

Parent pointer receives parent pointer 

Child class address to parent poineter 
if not virtual function automatically call parent function 
however, if it is virtual function declared in parent scope and writtein in child class, then the compiler will automatically call the child function, 
since the parent function is declared as virtual 

virtual void Parent::Move(); > void child::move() , and when access by parent pointer Parent &target = arr[idx] 
and call function child.Move() then it will automacilally Child::Move that is not virtual, since it is declared as virtual in parent scope. 
Then inheritance map polymorphism access by parent class pointer this will be really useful fully using the advantage of the polymorphism and function overwriting per inheritance  

Problem solving 
function overwriting virtual function this  

How does virtual function work ? Interview question MUST 

how does this static binding problem solved inside the virtual function 
If virtual function operating principles is based on 
parent class inherited any value 
parent pointer parent class inherited then parent inherited child another child child child another child whatever ... 
Whatever class inherited a lot of times still accessible by parent pointer 
Move function parent inheritencne 

Parent inherited child compiler will still suppose that parent move but virtual make it work WHY? 
compiler will take a look what move function is Move() is virtual function! then compiler will generate 
typeinfo. each data structure has type info now parent and derived child classes all of them should generate type info 
type info contains parent data structure when it is inherited child class info also generated 
what parent typeinfo is, what child typeinfo is 
without virtual info, parent class size will be 4, 
but if virtual function exists then type info is also generated. In sammple code from 4 to 16 bytes 

IT represents some invisible member variable is added 
without virtual function, parent memory value is float m_p only 

if virtual function is generated then the new member that I did not generate comes. 
member name __vfptr this value is generated. This is pointer value, so 8 bytes. 
Even though float is 4, __vfptr is 8 byre so total class size became 12 > 16 byres 

virtual function  parent class but also its inherited child classes all generate typeinfo 
virtual function owning parent class has invisible pointer variable named __vfptr 
inheritance, but no function variable. 
If there is NO virtual function, just function, then it is 4 byte 
so void Move() this one in parent still size is 4 bye but 
virtual void Move() this one is 16 bytes be careful 

when parent class contains at least one virtual function then 
typeinfo will be generated and __vfpter(virtual function table) pointer value is also included 
parent class type info __vfptr points parent class typeinfo 
child class typeinfo points parent class typeinfo 
If another child class is generated then it will point child too 
__vfptr points parent or child 

parent pointer points parent object 
parent pointer move into table pointer 

parent pointer points child object parent part. If move is virtual function in parent scope 
then visit child table and call function there. 

virtual function will visit __vfptr and since object will be generated with pointing its own function 
so if function is virtually declared in parent, then it will go to the function of that class 
parent child child 

pointer class child child 
object typeinfo pointing 
parent move function call will visit the table of that child class pointer and go to child class and 
get function address of that child table and execute that function. 

Move to pointer, go to table and call function there . When function is virtual in class. 

Based on what object this parent class is. 
Even only parent is known, since it is at front, it access table 

Parent class  
Child class 

if some function is NOT overriding by child but just bring same function of its parent 
then on child table register the parent's function address   

If child is called ... 

For each virtual function they have index inside table 

Detail 

class Parent 
virtual void Move (){}
virtual void Test (){}


class Child 
virtual void Move (){}
virtual void Test (){}

Pointer contains virtual function talble call index 0 function 
Access to table 1 and child test or parent test 

virtual function index 0 Move 
virtual function index 1 Test 

Compiler will call function Move as idx 0 and Test idx 1 
This one effects like it distinguishes function 

compiler virtual function call 
table Test index 1 call function 1 

Polymorphism problem 
by virtual function 




r59 | AR56 | 2025-04-23 13:54:15 +0900 (수, 23 4 2025) | 5 lines
Changed paths:
   M /C++/C++_56/다형성.cpp

1. 다형성 문제점
  - 부모포인터로 자식객체를 가리킬 경우, 오버라이딩한 함수갖 정상적으로 호출되지 않는 문제
  - 가상함수로 해결

2. 가상함수 동작원리 설명
------------------------------------------------------------------------
r58 | AR56 | 2025-04-23 12:57:12 +0900 (수, 23 4 2025) | 3 lines
Changed paths:
   M /C++/C++_56/C++_56.vcxproj
   M /C++/C++_56/C++_56.vcxproj.filters
   A /C++/C++_56/다형성.cpp
   M /C++/C++_56/복사생성자＿상속.cpp
   A /C++/C++_56/오버라이딩.cpp
   M /C++/C++_56/클래스 상속.cpp

1. 부모포인터로 자식클래스 객체를 가리킬 수 있다.
  - 다형성, 하나의 타입으로 파생되는 모든 클래스들을 관리 가능
