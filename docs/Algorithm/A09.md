# Graph Algorithm 

Array is 
1 Dimensional linear structure 

More generalized form than tree is Graph 

Graph is used to express real life data structure 
SNS connectoin and easy chatting program 
Inter connectoin status 
AI Neural Network is also Graph based 

Graph Data Structure, Design Algorithm 
is important. 

## Graph Basics 

Vertex of Graph is 
similar to Node on List or Tree 
Basic unit to save Data 
In SNS it can be name, profile info, user ID, etc 

Edge is connection between two Vertex 
No Edge between two vertex means no connectoin 

Data might be saved like Weight 
Weight of Edge might exist or not 
Direction can also exist or not 
Can be represented with arrow 
Undirected Graph and Directed Graph 
Undirected Graph means path in both ways 

Edge might save info like geometric distance between two vertex 

In-Degree 진입 차수 
For one Vertex, how much Edges are heading from other vertices to this Vertex 
Other vertices are incoming neighbors 
Out-Degree 출력 차수 
For One Vertex, how much Edges are heading from this vertex to other vertices 
other vertices are outgoing neighbors 

Graph to Math Expression 

4 Vertices expressed as 
$V = {0, 1, 2, 3}$ 

Edges are connection of two vertices, so can be represented as pair. 

$E = {(0, 2), (1, 3), (2, 3), (3, 2), (2, 1)}$

정점 사이 연결 관계 표현 행렬 
인접 행렬 방식 
Adjacent Matrix 

Undirected Graph Adjacent Matrix 
will be Symmetric Matrix (대칭 행렬)

인접 리스트 Adjacent List 

탐색 
최단 거리 지도 전체 뒤지기보다는 시작점부터 
원하는 정보 발견 시 중간에 탐색 멈추기 

깊이우선탐색 

인접리스트 구조 
방문한 적 없는 이웃 우선적으로 진행 

## Topological Sort 위상 정렬

Topology 위상 
Meaning Connection 연결 관계 

Connection Relation based Sort 
So, for shortest path finding, not possible to use 

So what to do? 

Epitite, 
Main Dish, 
Dessert 

Suppose, 
Epitite -> Main Dish 
Epitite -> Dessert 
Main Dish -> Dessert 

Order is possible, and you want to find ways 
to eat every dish possible 

In Directed Grap, 
Find 1 Dimensional Order to access all vertices 

Also, Topological Sort is Impossible to use in 
Circular Order! 
For instance, if Dessert -> Epitite is possible, 
it is infinite circular structure. 

### Characteristics of Topological Sort 

Graph to 1D 
From left to right, if left one visit right one while 
vise versa is imposssible, it will NOT break preceding rule. 
(선행 조건 위반 가능성 없음) 

Sometimes Result of Topological Sort might be multiple, not one 

Some Graph Vertices have 
Either No In-Degree, meaning in left edge 
Whatever order among No In-Degree does not matter in topological sort 
진입차수 0 

Or No Out-Degree, meaning it is in right edge 
Whatever order among No Out-Degree does not matter in topological sort 
출력차수 0 

### Queue Based Topological Sort 

Steps of Queue based Topological Sort is inspired by BFS 
Breadth First Search 

First, make an array storing how much 
In-Degree Edges each vertex have in array. 

```cpp
struct Vertex {
    int index; 
    bool visited = false; 
    vector<Vertex*> out_neighbors; 
}; 

class Graph {
    vector<Vertex*> vertices; 
    // Additional Functions 
}; 
```

If counting array element `in_count[i]` became zero, then that vertex 
with index `i` can be inside queue for topological sort. 

```cpp
vector<size_t> in_count(vertices.size(), 0); // Reset as 0 
for(Vertex* vertex : vertices) {
    for(Vertex* out_neighbor : vertex->out_neighbors)  
        in_count[out_neighbor]++; // Add count per in neighbor 
}
```

Start by pushing all elements that `in_count[i]` is zero. 

```cpp 
queue<Vertex*> bfs;
for (int i = 0; i < in_count.size(); ++i) 
    if (indegree[i] == 0) bfs.push(vertices[i]); 
```

Now, implement logic for topological sort. 
Pseudocode will be, 

1. While Queue is not Empty 
2. Pop current vertex from Queue 
3. Loop of the out neighbor vertices of current vertex 
4. If `in_count[index]` is zero, meaning no In-Direction Edge has left 
5. Push that vertex inside queue as all In-Direction Neighbor are visited 

Real C++ code implementation is similar to this. 

```cpp
while(!bfs.empty()) {
    Vertex *cur = bfs.front(); bfs.pop(); 
    for (Vertex* out : cur->out_neighbors) {
        if (indegree[out->index] > 0) continue; 
        bfs.push(out); 
    } // result.push_back(vertex); // Don't forget to save path 
}
```

If Result path saving and visiting mark is required, should be 
implemented additionally  

### DFS Based Topological Sort 

Surprisingly, Recursion based DFS per each random vertex order can be used. 
This is based on inserting input after calling Recursive function of 
each of its Out neighbors. 

The entire Topological sorting is based on following. 

```cpp
stack<Vertex*> TopologicalSort() {
    ans = stack<Vertex*>();
    for (Vertex* v : vertices) v->visited = false; 
    for (Vertex* v : vertices) 
	    if (v->visited == false) TopologicalSortHelper(v); 
    return ans; 
}
```

The helper function is following. 
Simply, based on the starting vertex, all 
vertices accessible from the starting node will be searched. 

```cpp
void TopologicalSortHelper(Vertex* v)
{
	v->visited = true; 
	for (Vertex* out : v->out_neighbors) {
		if (out->visited == false)
			TopologicalSortHelper(out); 
	}
	ans.push(v); 
}
```

Then, despite of no consideration of order, returned values 
inside stack will satisfy, because of the characteristics of stack. 

In iteration of array of `vector<Vertex*> vertices`, 
When one vertex helper function is called, then all 
Out-Direction vertex will be inside stack. 

Also, since vertices that are not out-neighbors of the previous 
vertex would either be independent vertex or in neighbor of the 
previous vertex. Thus, those pushed into stack after previous 
vertex is pushed inside already makes sense. 

DAG 방향성 비순환 그래프 
Directed Acyclic Graph 

