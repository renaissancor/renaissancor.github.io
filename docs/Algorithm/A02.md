# Path Finding Algorithm 

This post explores various pathfinding algorithms used to find the shortest path between two points on a grid or graph. 

Memorizing and printing graph status requires buffer status, so following `struct` 
datatype is implemented. 

```cpp
union Val {
    struct {
        signed short col; 
		signed short row;
    };
    signed int v; 

    signed int dist(const Val& goal) const {
        return abs(goal.col - col) + abs(goal.row - row); // Manhattan distance
	}

    bool operator<(const Val& other) const {
        return this->dist(other) < other.dist(other);
	}
};
``` 

This `union` datatype allow byte access, letting lower size of dynamic memory allocation. 

## Basic Algorithms: BFS and DFS

* **Breadth-First Search (BFS)** and **Depth-First Search (DFS)** are foundational graph traversal methods.
* BFS explores nodes in layers and guarantees the shortest path in an unweighted grid or graph.
* DFS explores as deep as possible before backtracking but does not guarantee the shortest path.

Sample DFS Code 

```cpp 
void  Graph::DFS(Val start, Val end) {
    CreateBuffer();
    Val cur = start;
    stack<Val> stk;
    stk.push(start); 
	graph[start.row][start.col] = VISITED; // Mark start as visited

    while (!stk.empty())
    {
        cur = stk.top();
        stk.pop();
        if (cur.v == end.v) break; // Found Answer 
        const short dx[4] = { 1, 0, -1, 0 };
        const short dy[4] = { 0, 1, 0, -1 };
        for (signed char i = 0; i < 4; ++i) {
            signed short new_col = cur.col + dx[i];
            signed short new_row = cur.row + dy[i];
            if (0 <= new_row && 0 <= new_col && new_col < col_size && new_row < row_size
                && graph[new_row][new_col] == PATH && buffer[new_row][new_col].v == 0) {
                buffer[new_row][new_col] = cur;
                graph[new_row][new_col] = VISITED;
                stk.push({ new_col, new_row });
            }
        }
    }
    DeleteBuffer(); 
}
```

## Dijkstra’s Algorithm

* Extends BFS to **weighted graphs**, where edges have different costs.
* Finds the shortest path by accumulating edge weights.
* Suitable for graphs where movement costs vary.

Since grid map does not have weight for movement, Dijakstra is simply BFS. 

```cpp
void Graph::BFS(Val start, Val end) {
	CreateBuffer();

    Val cur = start; 
	queue<Val> que; 
	que.push(start); 
	graph[start.row][start.col] = VISITED; // Mark start as visited

    while(!que.empty()) {
		cur = que.front();
		que.pop(); 

        if (cur.v == end.v) break; // Found Answer 

        const short dx[4] = { 1, 0, -1, 0 };
        const short dy[4] = { 0, 1, 0, -1 };

        for(signed char i = 0; i < 4; ++i) {
            signed short new_col = cur.col + dx[i];
            signed short new_row = cur.row + dy[i];
            if (0 <= new_row && 0 <= new_col && new_col < col_size && new_row < row_size
                && graph[new_row][new_col] == PATH && buffer[new_row][new_col].v == 0) {
                buffer[new_row][new_col] = cur;
                graph[new_row][new_col] = VISITED;
                que.push({ new_col, new_row });
            }
		} 
	}
	DeleteBuffer(); 
}
```

## Greedy Algorithm 

* Basic DFS Algorithm is very inefficient, with accessing every possible direction. 
* However, priority queue based implementation would give shortest distance 

**Manhattan Distance** simply calculates linear distance based comparison 

$$
|a_x - b_x| + |a_y - b_y|
$$

**Euclid Distance** calculates square root variable comparison 

$$
\sqrt{(a_x - b_x)^2 + (a_y - b_y)^2}
$$

In this Greedy Algorithm Path Finding, distance between current location 
and destination is simply used Manhattan Diatance logic with `std::priority_queue`. 

```cpp
void Graph::Greedy(Val start, Val end) {
	CreateBuffer();
    auto cmp = [&end](const Val& a, const Val& b) {
        return a.dist(end) > b.dist(end); // Min-Heap
    };
    Val cur = start;
	priority_queue<Val, vector<Val>, decltype(cmp)> pq(cmp); 
    // Min-heap based on distance 
    pq.push(start);
	graph[start.row][start.col] = VISITED; // Mark start as visited
    while (!pq.empty())
    {
        cur = pq.top(); 
        pq.pop();
        if (cur.v == end.v) break;
        const short dx[4] = { 1, 0, -1, 0 };
        const short dy[4] = { 0, 1, 0, -1 };
        for (signed char i = 0; i < 4; ++i) {
            signed short new_col = cur.col + dx[i];
            signed short new_row = cur.row + dy[i];
            if (0 <= new_row && 0 <= new_col && new_col < col_size && new_row < row_size
                && graph[new_row][new_col] == PATH
                && buffer[new_row][new_col].v == 0) {
                buffer[new_row][new_col] = cur;
                graph[new_row][new_col] = VISITED;
                pq.push({ new_col, new_row });
            }
		}
    }
	DeleteBuffer();
}
``` 

Priority Queue will have comparison function `cmp` to figure out distance 
between destination point `end` and current location. 

```cpp
auto cmp = [&end](const Val& a, const Val& b) {
        return a.dist(end) > b.dist(end); // Min-Heap
};
priority_queue<Val, vector<Val>, decltype(cmp)> pq(cmp); 
``` 

Key concepts used here are lambda function and usage of it in `priority_queue`. 

## A\* Algorithm

* An informed search algorithm that uses a **heuristic** (often Manhattan distance) to prioritize nodes closer to the goal.
* Unlike BFS, which explores all neighbors equally, A\* focuses on the most promising path, minimizing actual search space.
* Provides optimal paths like BFS but often with better performance on large maps.

## Grid vs. Graph Representation

* Pathfinding can be done on **grids**, where each cell is a node, or on **graphs** with vertices and edges.
* Grids are easier to visualize and implement but can be less efficient for very large or sparse maps.
* Graphs allow explicit edge weights and complex connections.

## Path Reconstruction Methods

To display the found path, algorithms need to record how they reached each node. Two common methods:

1. **Store the Previous Position (Coordinates)**

   * Requires a buffer that saves the previous node’s row and column.
   * For large maps (row/column > 256), use a union like `{ unsigned short x; unsigned short y; }` to handle indices efficiently.

2. **Store the Previous Direction**

   * Saves the direction (e.g., up, down, left, right) from which the node was reached.
   * More space-efficient, using only a char per cell.

## Implementation Overview

* The implementations here build on BFS and DFS for complete search algorithms.
* Source and destination are defined, and the algorithms attempt to find a path between them.
* The path is recorded using a buffer of previous positions and then reconstructed for display.
* The map is generated as a 2D grid with walls and paths, using a byte per node.

## Summary

* BFS guarantees the shortest path in unweighted grids but can explore many nodes.
* Dijkstra handles weighted edges by accumulating costs.
* A\* optimizes search by estimating distance to the goal, reducing unnecessary exploration.
* Efficient path reconstruction and map storage are crucial for performance, especially on large grids.
