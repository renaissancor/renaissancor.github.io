# Algorithms 

Path Finding 

## Recursion 

Recursion Function 

Basic recursion function works like this 

```cpp
void Recurse(UINT row, UINT col, char val)
{
    if(graph[row][col] == 0) return; 
    else if (graph[row][col] == val) return;
    else graph[row][col] = val;

    if (0 < col) Recurse(row, col - 1, val); 
    if (0 < row) Recurse(row - 1, col, val); 
    if (col < col_size - 1) Recurse(row, col + 1, val);
    if (row < row_size - 1) Recurse(row + 1, col, val); 
}
```

During the time measurement, the function is called a lot. 
For the simple DFS and BFS logic that do NOT check and mark value 
before it gets inside stack or queue, recursion is more efficient. 


## BFS (Breadth First Search)

Implementation based on Queue 


```cpp
void Graph::BFS(UINT row, UINT col, char val)
{
    RC* queue = new RC[ROW_SIZE * COL_SIZE * 2];
    size_t front = 0, back = 0;
    queue[back++] = { row, col };

    while (front < back)
    {
        if (back >= ROW_SIZE * COL_SIZE * 2) {
            printf("Queue overflow! \n");
            break;
        }
        UINT row = queue[front].row;
        UINT col = queue[front].col;
        ++front;

        //if (graph[row][col] == 0) continue; 
        // if (graph[row][col] == val) continue; 
        graph[row][col] = val;
        // system("cls"); 
        // PrintGraph(); 

        if (col > 0 && graph[row][col - 1] != 0 && graph[row][col - 1] != val) {
            graph[row][col - 1] = val;
            queue[back++] = { row, col - 1 };
        }
        if (row > 0 && graph[row - 1][col] != 0 && graph[row - 1][col] != val) {
            graph[row - 1][col] = val;
            queue[back++] = { row - 1, col };
        }
        if (col < col_size - 1 && graph[row][col + 1] != 0 && graph[row][col + 1] != val) {
            graph[row][col + 1] = val;
            queue[back++] = { row, col + 1 };
        }
        if (row < row_size - 1 && graph[row + 1][col] != 0 && graph[row + 1][col] != val) {
            graph[row + 1][col] = val;
            queue[back++] = { row + 1, col };
        }
    }

    delete[] queue;
}
```

Since queue input without checking validity or visit of the value has potential to 
make so much input queue that buffer overflow of queue is very likely. 


## DFS (Depth First Search)

Implementation based on Stack 

```cpp 
void Graph::DFS(UINT row, UINT col, char val)
{
    RC* stack = new RC[ROW_SIZE * COL_SIZE];
    size_t top = 0;
    stack[top++] = { row, col };

    cntjhp = 0;
    while (top > 0)
    {
        cntjhp++;
        top--;
        UINT row = stack[top].row;
        UINT col = stack[top].col;

        // if (graph[row][col] == 0) continue;
        // if (graph[row][col] == val) continue;
        graph[row][col] = val;
        // system("cls");
        // PrintGraph();

        if (0 < col && graph[row][col - 1] != 0 && graph[row][col - 1] != val) stack[top++] = { row, col - 1 };
        if (0 < row && graph[row - 1][col] != 0 && graph[row - 1][col] != val) stack[top++] = { row - 1, col };
        if (col < col_size - 1 && graph[row][col + 1] != 0 && graph[row][col + 1] != val) stack[top++] = { row, col + 1 };
        if (row < row_size - 1 && graph[row + 1][col] != 0 && graph[row + 1][col] != val) stack[top++] = { row + 1, col }; 

        // if (0 < col)  stack[top++] = { row, col - 1 }; 
		// if (0 < row)  stack[top++] = { row - 1, col };
        // if (col < col_size - 1) stack[top++] = { row, col + 1 };
        // if (row < row_size - 1) stack[top++] = { row + 1, col };
    }

    delete[] stack;
}
```

DFS originally had same logic implementation with Recursion, so even function count was exactly identical. 
However, performance could increase if buffer check ignore one. 

To improve performance more, stack usage without any handle after access is also useful like this. 

```cpp
if (0 < col && graph[row][col - 1] != 0 && graph[row][col - 1] != val) {
    stack[top++] = { row, col - 1 };
	graph[row][col - 1] = val; // mark as visited
}
if (0 < row && graph[row - 1][col] != 0 && graph[row - 1][col] != val) {
    stack[top++] = { row - 1, col };
	graph[row - 1][col] = val; // mark as visited
}
if (col < col_size - 1 && graph[row][col + 1] != 0 && graph[row][col + 1] != val) {
    stack[top++] = { row, col + 1 };
	graph[row][col + 1] = val; // mark as visited
}
if (row < row_size - 1 && graph[row + 1][col] != 0 && graph[row + 1][col] != val) {
    stack[top++] = { row + 1, col };
	graph[row + 1][col] = val; // mark as visited
}
```

Instead of marking by stack, this is way much more efficient. 
