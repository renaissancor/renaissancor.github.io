# Adjacent Matrix Multiplication 

Reference Problems 

- [Baekjoon 12849](https://www.acmicpc.net/problem/12849)
- [Baekjoon 12850](https://www.acmicpc.net/problem/12850)

Given graph 

```cpp 
struct Edge { size_t x, y; };
Edge edges[12] = {
    {0, 1}, {0, 2}, {1, 2}, {1, 3}, 
    {2, 3}, {2, 4}, {3, 4}, {3, 6}, 
    {4, 5}, {4, 6}, {5, 7}, {6, 7}, 
}; 
```

Problem 12849 restriction is `d < 100'000` which can be solveable by 
typical graph and DP problem. 

```cpp
using ll = unsigned long long; 
constexpr const ll MOD = 1'000'000'007;
int main()
{
    ios_base::sync_with_stdio(false); 
    cin.tie(nullptr); 
    vector<vector<size_t>> graph(8, vector<size_t>());
    for (size_t i = 0; i < 12; ++i) {
        graph[edges[i].x].push_back(edges[i].y);
        graph[edges[i].y].push_back(edges[i].x);
    }
    size_t d;
    cin >> d; 
    ll dp[8] = { 0, }; 
    dp[0] = 1; 

    for (size_t i = 0; i < d; ++i) {
        ll tmp[8] = { 0, }; 
        for (size_t src = 0; src < 8; ++src) {
            for (size_t j = 0; j < graph[src].size(); ++j) {
                size_t dst = graph[src][j];
                tmp[src] += dp[dst];
                tmp[src] %= MOD;
            }
        }
        for (size_t src = 0; src < 8; ++src) {
            dp[src] = tmp[src];
            tmp[src] %= MOD;
        }
    } 
    cout << dp[0] << '\n'; 
    return 0; 
}
```

However, Problem 12850 restriction is given that it should be 
`d < 1'000'000'000`, which is enough to reach time and memory limit 
by typical dynamic programming. Thus, another approach is required. 

## **Linear Algebra Approach to Graph DP**

We want to solve problems like:

“Number of paths from node 0 back to node 0 in D steps on a given graph.”

We will approach it using **matrix representation and exponentiation**.

---

## **1. Representing the Graph as a Matrix**

### **Adjacency Matrix**

For a graph with `N` nodes, define the adjacency matrix (A) as:

\[
A[i][j] =
\begin{cases}
1 & \text{if there is an edge between node } i \text{ and } j \\
0 & \text{otherwise}
\end{cases}
\]

* **Example Graph:** 8 nodes

\[
A =
\begin{bmatrix}
0 & 1 & 1 & 0 & 0 & 0 & 0 & 0\\
1 & 0 & 1 & 1 & 0 & 0 & 0 & 0\\
1 & 1 & 0 & 1 & 1 & 0 & 0 & 0\\
0 & 1 & 1 & 0 & 1 & 1 & 0 & 0\\
0 & 0 & 1 & 1 & 0 & 1 & 0 & 1\\
0 & 0 & 0 & 1 & 1 & 0 & 1 & 0\\
0 & 0 & 0 & 0 & 0 & 1 & 0 & 1\\
0 & 0 & 0 & 0 & 1 & 0 & 1 & 0\\
\end{bmatrix}
\]

* Row (i) shows **which nodes are connected to node i**.

---

## **2. DP Recurrence as a Matrix Equation**

Let (dp_t[i]) = number of paths that arrive at node `i` after `t` steps.

Original DP recurrence:

\[
dp_{t+1}[i] = \sum_{j=0}^{N-1} A[i][j] \cdot dp_t[j]
\]

* For each node `i`, sum all paths coming from neighbors `j`.

In vector/matrix form:

\[
\mathbf{dp}_{t+1} = A \cdot \mathbf{dp}_t
\]

* $\mathbf{dp}_t$ is a column vector of size `N`.
* (A) is an `N x N` matrix.

---

## **3. Repeating the Transition**

After `D` steps:

\[
\mathbf{dp}_D = A^D \cdot \mathbf{dp}_0
\]

* $\mathbf{dp}_0 = [1, 0, 0, \dots, 0]^T$ (starting at node 0)
* The answer we want:

\[
\text{Answer} = (\mathbf{dp}_D)_0 = (A^D)[0][0]
\]

`Observation`: Instead of iterating `D` times (slow for large `D`), 
we can **exponentiate the matrix**.

---

## **4. Matrix Multiplication (Scalar Form)**

For two matrices (A, B) of size `N x N`:

\[
C = A \cdot B \quad \Rightarrow \quad C[i][j] = \sum_{k=0}^{N-1} A[i][k] \cdot B[k][j]
\]

* Each entry (C[i][j]) is a **scalar**.
* This is exactly what happens in the DP recurrence: sum over neighbors.

---

## **5. Matrix Exponentiation**

To compute (A^D) efficiently:

\[
A^D =
\begin{cases}
I & D = 0 \\
(A^{D/2})^2 & D \text{ even} \\
A \cdot A^{D-1} & D \text{ odd}
\end{cases}
\]

* Use **binary exponentiation**.
* `I` = identity matrix

---

## **6. Modulo Operation**

If the problem requires large numbers, compute all operations modulo (MOD):

\[
C[i][j] = \Big( \sum_{k=0}^{N-1} A[i][k] \cdot B[k][j] \Big) \mod MOD
\]

* Keep numbers manageable.
* Avoid overflow.

---

## **7. Step-by-Step Algorithm (Math Version)**

1. Build adjacency matrix (A)
2. Initialize $\mathbf{dp}_0 = [1,0,\dots,0]^T$
3. Compute $A^D$ using binary exponentiation
4. Multiply $A^D \cdot \mathbf{dp}_0$
5. Answer = first element of the resulting vector

---

## **8. C++ Implementation (Code Version)**

```cpp
#include <iostream>
#include <cstring>
using namespace std; 
using ll = unsigned long long;
constexpr const ll MOD = 1'000'000'007;
ll A[8][8] = {
    {0, 1, 1, 0, 0, 0, 0, 0},
    {1, 0, 1, 1, 0, 0, 0, 0},
    {1, 1, 0, 1, 1, 0, 0, 0},
    {0, 1, 1, 0, 1, 1, 0, 0},
    {0, 0, 1, 1, 0, 1, 0, 1},
    {0, 0, 0, 1, 1, 0, 1, 0},
    {0, 0, 0, 0, 0, 1, 0, 1},
    {0, 0, 0, 0, 1, 0, 1, 0}, 
}; 

static void multi(ll A[8][8], ll B[8][8], ll C[8][8]) {
    ll temp[8][8] = { 0, };
    for (size_t i = 0; i < 8; ++i) {
        for (size_t k = 0; k < 8; ++k) {
            if (A[i][k] == 0) continue; 
            for (size_t j = 0; j < 8; ++j) {
                temp[i][j] += (A[i][k] * B[k][j]) % MOD; 
                temp[i][j] %= MOD; 
            }
            
        }
    }
    memcpy(C, temp, 64 * sizeof(ll));
}

static void power(ll base[8][8], ll exp, ll ans[8][8]) {
    for (size_t i = 0; i < 8; ++i) 
        for (size_t j = 0; j < 8; ++j) 
            ans[i][j] = (i == j ? 1 : 0); 
    
    while (exp > 0) {
        if (exp & 1) multi(ans, base, ans); 
        multi(base, base, base); 
        exp >>= 1; 
    }
}

int main()
{
    ios_base::sync_with_stdio(false); 
    cin.tie(nullptr); 
    ll d;
    cin >> d; 
    ll ans[8][8] = { 0, };
    power(A, d, ans); 
    cout << ans[0][0] % MOD << '\n'; 
    return 0; 
}
```
