# Bucket Sort 

Limit of Sort by Comparison 

Sorting probability exist total `n!`, permutation numbers. 
For total size of `n` array, there would exist total `n!` likelihoods of order. 

숫자 비교 기반 정렬의 한계 

숫자 a b c 를 정렬하는 것은 총 6가지 경우의 수가 존재 

순열 Permutation 
입력이 n 이면 경우의 수가 n! 개 

이진 결정 트리로 만들어 보면, 
비교 결과에 따라서 이진 탐색 하듯이 아래로 내려 오는 구조 
가장 마지막에 리프 노드에 도착하면 정렬이 끝난 것 
즉 이러한 비교 기반 정렬은 결정 트리의 구조이다 

내려오는 깊이가 적을수록 정렬 속도가 빠른 것이다 

이진 트리 관점 
숫자 N개를 정렬하는 결정 트리를 이진 트리로 그리면 리프노드가 n! 개인 
이진 트리가 된다 
이 이진트리의 높이 가 시간 복잡도 
완전이진트리이고 리프노드가 n! 개라면 
log (n!) 으로 높이를 구할 수 있다 

n! 개의 리프노드를 가진 이진 트리의 높이는 최소 log(n!) 의 올림이다 

Stirling's Approximation 

$$
n! \approx \sqrt{2\pi n} \left(\frac{n}{e}\right)^n
$$

$$
\log(n!) = \Theta(n \log n)
$$

Thus, worst caste of any sorting function based on one by one comparison and swap
will have at least $\Theta(n \log n)$. Or, since it is at least $\Theta(n \log n)$, 
meaning that it is $\Omega (n \log n)$

Then, any other way to make sorting faster, in linear time close to $O(n)$? 

## Counting Sort (계수 計數 정렬) 

공에 통을 넣음 
비교 정렬 O(n log n)
메모리 접근은 상수 시간 O(1) 

숫자들 통을 준비하고, 같은 숫자들이 여러 번 중복될 것을 미리 전제 
같은 숫자가 몇 개인지 세어서 별도의 카운트 배열에 저장 
그 후 값들을 뒤에서 누적시키고 
마지막으로 카운트 배열 

입력이 n개, 숫자가 k가지 있다고 전제하면 

시간 복잡도 는 \theta(n + k) = \theta(n) 
공간 복잡도 는 \theta(n + k) = \theta(n) 

## Radix Sort (기수 基數 정렬) 

Counting 정렬을 여러 자리 숫자에 사용하기에는 무리가 있다 
크기가 너무 커지면 부담이 되기 때문 
예를 들어 단위가 3자리 숫자면 카운트 배열 크기가 1000 
그래서 이걸 보완하면서 선형 복잡도를 유지하기 위한 게 
자리수 별로 나누어서 정렬하는 기수 정렬 
한 자릿수씩만 1의 자리 수부터 마지막 자리까지 정렬 

무의식중에 높은 자리부터 정렬을 많이 하는데, 이러면 
기수 정렬이 아니라 분할 정복처럼 되어 버린다 
그래서 여기서는 낮은 자리부터 

제약사항, Stable Sort 필요 
불필요한 순서 변경 금지 
해당 자릿수가 같으면 순서를 변경하지 않는다 

반대로 Unstable Sort 대표적인 수는 Quick Sort 

카운팅 정렬 에서 최대 자리 수가 d 라면, 
$\Theta(d\dot(n+k)) = \Theta(n)$

## Bucket Sort 

버킷 정렬 
앞에서는 정수 정렬이지만 
버킷 정렬은 실수 정렬 기반 
적절한 크기의 버킷 배열을 미리 준비하고 
유사한 크기의 숫자들을 미리 나누어서 담는다 

이후 삽입정렬 같은 가벼운 정렬로 버킷 단위로 정렬하는 것 
자료구조에 나온 Hashing 과 상당히 유사 

에를들어 input i 가 0 ~ 1 사이 실수에 버킷 10개면 
float (i * 10) / 1 이렇게 해서 결정 

$$
T(n) = \Theta(n) + \sigma^{n-1}_{i=0} O(n_i^2) \rightarrow T(n) = \Theta(n) 
$$

Ideal case, one number per one bucket, 
$n_i = 1 \rightarrow O(n_i^2) = O(1^2) = O(1)$

Worst, case, all numbers inside one single bucket 
$n_i = n \rightarrow O(n_i^2) = O(n^2)$

Average expectecd usage case, if small number `k` is input then 
$n_i = k \rightarrow O(n_i^2) = O(k^2) = O(1)$