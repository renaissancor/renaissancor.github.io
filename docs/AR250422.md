# C++ Inheritance and Object Lifecycle

### Date: 2025-04-22

---

## Key Points

- Inheritance allows classes to extend and reuse functionality.
- Constructors initialize from base to derived; destructors run in reverse.
- Use `protected` to allow child access without exposing to external code.
- Manual memory management must be matched in constructors and destructors.
- Initializer lists only initialize members of the current class.

---

## Overview

This note explores class inheritance in C++, focusing on constructor and destructor order, access control, and memory management. It uses a base class `CParent` and a derived class `CChild` to illustrate these points.

---

## Example: Parent and Child Class with Dynamic Memory

```cpp
class CParent {
protected:
    int m_I;
    int* m_pData;

public:
    void SetData(int _Data) { m_I = _Data; }
    int GetData() { return m_I; }

    CParent() : m_I(0), m_pData(new int[100]) {}
    CParent(int _Data) : m_I(_Data), m_pData(new int[100]) {}

    ~CParent() {
        if (m_pData) delete[] m_pData;
    }
};

class CChild : public CParent {
private:
    float m_F;
    float* m_pFloatData;

public:
    void SetFloat(float _F) {
        m_I = 100; // accessing protected member from base class
        m_F = _F;
    }
    float GetFloat() { return m_F; }

    CChild() : m_F(0.f), m_pFloatData(new float[1000]) {}
    CChild(int _IntData, float _FloatData)
        : CParent(_IntData), m_F(_FloatData), m_pFloatData(new float[1000]) {}

    ~CChild() {
        if (m_pFloatData) delete[] m_pFloatData;
        // CParent destructor called automatically
    }
};
```

### Key Concepts:
- Constructors run base-to-derived.
- Destructors run derived-to-base.
- Only the current class's members can be initialized in its constructor.

---

## Common Mistakes

**Forgetting virtual destructors in polymorphic base classes**
```cpp
class Base {
public:
    virtual ~Base() {}  // required for proper cleanup
};
```

**Accessing private base members from derived class**
- Only `protected` or `public` members are accessible.

**Leaking memory by skipping cleanup**
- Always `delete[]` if you used `new[]`.

---

## Constructor/Destructor Order

```cpp
CChild child;
```
This calls `CParent()` first, then `CChild()`.

When `child` goes out of scope, it calls `~CChild()` first, then `~CParent()`.

### Code Demo

```cpp
int size = sizeof(CParent);
size = sizeof(CChild);

CParent parent;
CParent parent1(100);

CChild child;
CChild child1(100, 2.2f);
```

---

## Interview Questions

**Q: What’s the order of constructor and destructor calls in inheritance?**  
A: Constructors execute from base to derived. Destructors execute from derived to base.

**Q: What happens if a derived class allocates memory but doesn’t define a destructor?**  
A: Memory leaks may occur if the destructor doesn’t free allocated memory.

**Q: Why use `protected` instead of `private`?**  
A: `protected` allows access from derived classes, which `private` denies.

**Q: Can derived constructors initialize base members directly?**  
A: No, use the initializer list to call base constructors.

---

## Visual: Object Lifetime in Inheritance

```
Construction:
CParent() -> CChild()

Destruction:
~CChild() -> ~CParent()
```

Understanding the exact sequence is crucial for managing resources and preventing undefined behavior.

---


Random number generator 
rand value call 

srand value call 

based on different number value page value changes 
number srand 
10 

srand(time(nullptr)); // Time as Seed, Random Page Setup 
completely random ? Mathematically more complicated but anyway quite unpredictable 
day time second etc ... combined to make completely random number 

irandom[i] = rand(); 
If random number is setup between 1 and 100 then 
divide by 100 and do modular calculation 
(rand() % 100 + 1) >> returns 1 ~ 100 random numbers 
64 72 34 ... etc ... 
Since std::map ignore same number input it would automatically overlapping number 

Binary Search Tree Data Removal 

r57 | AR56 | 2025-04-22 13:45:47 +0900 (화, 22 4 2025) | 3 lines
Changed paths:
   M /C++/C++_56/C++_56.vcxproj
   M /C++/C++_56/C++_56.vcxproj.filters
   A /C++/C++_56/복사생성자＿상속.cpp
   M /C++/C++_56/클래스 상속.cpp

1. 상속을 사용할 경우, 생성자와 소멸자 호출 동작 방식 설명

2. 복사생성자를 상속구조에서 직접 구현하는경우 주의점 설명
------------------------------------------------------------------------
r56 | AR56 | 2025-04-22 12:54:13 +0900 (화, 22 4 2025) | 1 line
Changed paths:
   M /C++/C++_56/C++_56.vcxproj
   M /C++/C++_56/C++_56.vcxproj.filters
   A /C++/C++_56/클래스 상속.cpp

1. 클래스 상속 파트 시작


