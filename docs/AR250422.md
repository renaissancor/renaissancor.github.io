# C++ Inheritance and Object Lifecycle

### Date: 2025-04-22

---

## Key Points

- Inheritance allows classes to extend and reuse functionality.
- Constructors initialize from base to derived; destructors run in reverse.
- Use `protected` to allow child access without exposing to external code.
- Manual memory management must be matched in constructors and destructors.
- Initializer lists only initialize members of the current class.

---

## Overview

This note explores class inheritance in C++, focusing on constructor and destructor order, access control, and memory management. It uses a base class `CParent` and a derived class `CChild` to illustrate these points.

---

## Example: Parent and Child Class with Dynamic Memory

```cpp
class CParent {
protected:
    int m_I;
    int* m_pData;

public:
    void SetData(int _Data) { m_I = _Data; }
    int GetData() { return m_I; }

    CParent() : m_I(0), m_pData(new int[100]) {}
    CParent(int _Data) : m_I(_Data), m_pData(new int[100]) {}

    ~CParent() {
        if (m_pData) delete[] m_pData;
    }
};

class CChild : public CParent {
private:
    float m_F;
    float* m_pFloatData;

public:
    void SetFloat(float _F) {
        m_I = 100; // accessing protected member from base class
        m_F = _F;
    }
    float GetFloat() { return m_F; }

    CChild() : m_F(0.f), m_pFloatData(new float[1000]) {}
    CChild(int _IntData, float _FloatData)
        : CParent(_IntData), m_F(_FloatData), m_pFloatData(new float[1000]) {}

    ~CChild() {
        if (m_pFloatData) delete[] m_pFloatData;
        // CParent destructor called automatically
    }
};
```

### Key Concepts:
- Constructors run base-to-derived.
- Destructors run derived-to-base.
- Only the current class's members can be initialized in its constructor.

---

## Common Mistakes

**Forgetting virtual destructors in polymorphic base classes**
```cpp
class Base {
public:
    virtual ~Base() {}  // required for proper cleanup
};
```

**Accessing private base members from derived class**
- Only `protected` or `public` members are accessible.

**Leaking memory by skipping cleanup**
- Always `delete[]` if you used `new[]`.

---

## Constructor/Destructor Order

```cpp
CChild child;
```
This calls `CParent()` first, then `CChild()`.

When `child` goes out of scope, it calls `~CChild()` first, then `~CParent()`.

### Code Demo

```cpp
int size = sizeof(CParent);
size = sizeof(CChild);

CParent parent;
CParent parent1(100);

CChild child;
CChild child1(100, 2.2f);
```

---

## Interview Questions

**Q: What’s the order of constructor and destructor calls in inheritance?**  
A: Constructors execute from base to derived. Destructors execute from derived to base.

**Q: What happens if a derived class allocates memory but doesn’t define a destructor?**  
A: Memory leaks may occur if the destructor doesn’t free allocated memory.

**Q: Why use `protected` instead of `private`?**  
A: `protected` allows access from derived classes, which `private` denies.

**Q: Can derived constructors initialize base members directly?**  
A: No, use the initializer list to call base constructors.

---

## Visual: Object Lifetime in Inheritance

```
Construction:
CParent() -> CChild()

Destruction:
~CChild() -> ~CParent()
```

Understanding the exact sequence is crucial for managing resources and preventing undefined behavior.

---

