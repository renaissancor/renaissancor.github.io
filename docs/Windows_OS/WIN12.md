# Thread Generation and Termination 

In Windows, HANDLE is process subordinate, and generally 
not usable outside that process that created HANDLE. 
However, Kernel Object ID are consistent for all different processes.

### Thread Generation  

```cpp
HANDLE CreateThread (
    LPSECURITY_ATTRIBUTES lpThreadAttributes, 
    SIZE_T dwStackSize, 
    LPTHREAD_START_ROUTINE lpStartAddress, 
    LPVOID lpParameter, 
    DWORD dwCreationFlags, 
    LPDWORD lpThreadId 
)
```

Three parameters are important. 

`SIZE_T dwStackSize` will define thread stack size. 
If this is zero, it is default stack size 1MB, not 0! 

`LPTHREAD_START_ROUTINE lpStartAddress` is a function pointer. 
It looks like `typedef DWORD (WINAPI *PTHREAD_START_ROUTINE)(LPVOID lpThreadParameter) 
Get void pointer * value and return type is DWORD. Basically make function and 
give function name as parameter. This input parameter `lpStartAddress` will act 
as thread main function. 

`LPVOID lpParameter` is pointer value for arguments for thread main function `lpStartAddress`. 

If function fails return value is 0. 
Windows can create as much thread as possible, if memory allows it. 
Check `CountThread.cpp`. 

Main thread return 0; will terminate process. 
Non main thread return will terminate thread. 

Thread termination by `return` is most recommended! 

```cpp
CreateThread( /*Params*/); 
printf("Whatever"); 
```

It is not clear what will start quicker. 
Generally, default Stack size is 1MB. 

Also, compared to `CreateThread`, function `_beginthreadex` is more recommended. 

```cpp
uintptr_t _beginthreadex (
     void *security, 
     unsigned stack_size, 
     unsigned ( *start_address ) (void *),
     void *arglist, 
     unsigned initflag, 
     unsigned *threadaddr
);
```

Its parameter deliver order is same as `CreateThread` function. 
Both `CreateThread` and `_beginthreadex` are inside process stack memory. 

Difference is that, `CreateThread` will NOT CORRECTLY RESET C/C++ runtime library (CRT). 
If process uses CRT, then specific functions that require reset per thread including 
`errno` value or `stdio` buffer will result in memory leak or unexpected behavior. 

On the other hand, `_beginthreadex` will correctly reset C/C++ runtime library (CRT). 
Thus, `CreateThread` is not recommended, so use `_beginthreadex`. 

### Thread Termination 

Use return function in thread function 
Suppose sum from 1 to 10. 
This will require a lot of I/O externally, so it will get blocked often. 
So, to finish this as quick as possible, create several threads to 
distribute workload. Then, CPU will do more work in limited amount of time, 
and Blocked status will be distributed evenly to each thread too, thus improving speed. 

Thread function Design  
``` 
              +-------------+
              | Main Thread |
              +-------------+
              /      |       \
           6 /       |        \
            /      22|         \ 27 
           /         |          \
+----------+   +----------+   +----------+
| Thread A |   | Thread B |   | Thread C |
+----------+   +----------+   +----------+
```

Now declare function and use it as thread. 

```cpp
DWORD WINAPI ThreadProc(LPVOID lpParam)
{
    DWORD * nPtr = (DWORD *) lpParam; 
    DWORD numOne = *nPtr, numTwo = *(nPtr+1); 
    DWORD total = 0; 
    // Whatever codes 
    return total; 
}

int main(int argc, TCHAR *argv[]){
    HANDLE hThread[3]; 
    DWORD paramThrad[] = {1, 3, 4, 7, 8, 10}; 
    hThread[2] = // Do same for index 0 and 1 too 
    CreateThread( NULL, 0, ThreadProc, (LPVOID)(&paramThread[4]), 0, &dwThreadID[2] ); 
}
``` 

So that function is executed inside thread, and function parameters are transferrable 
through pointer access.  

```cpp
BOOL TerminateThread(HANDLE hThread, DWORD dwExitCode); // For CreateThread 
void _endthreadex(unsigned retval); // For _beginthreadex 
```

this function is possible, forcing thread to quit. However, since thread will NOT 
recognize that it is ending, so it might be terminated while handling data, so 
`TerminateThread` and `_endthreadex` functions are dangerous and not recommended. 

```cpp 
GetExitCodeThread(HANDLE hThread, LPDWORD lpExitCode);
```
This function will let it possible to get the exit code of the thread into unsigned int DWORD. 
Similar to getting the exit code of the child process. 

Since thread generated by `_beginthreadex` assigns memory stack space outside main process, 
`_endthreadex` will retrieve allocated memory. 

Also, thread can generate thread! 

## Characteristics of Thread and Thread state Management 

Suppose two threads access same resource like global value declared in `.data` section. 
Over two threads simultaneously using same memory space would make unexpected consequence. 

Change 1. Ready after Beginning 

Change 2. When selected by Kernel Scheduler, Running state execution begins 

Change 3. Time Slice for executing Threaed is all done, so move to other thread, running to ready state movement. 
    Some people misunderstand that it is from Running to Blocked, but it is Running to Ready here. 

Change 4. For I/O or sleep so execution of thread is blocked, then turn to blocked, 

Change 5. If blocked reason is solved, blocked status will turn into ready status. 

### Suspend and Resume 

In WINAPI, it is possible to turn thread into blocked state and ready state. 

```cpp
DWORD SuspendThread (HANDLE hThread); // If success return prev suspend count, else return -1 for fail 
DWORD ResumeThread  (HANDLE hThread); // If function succeeds return value is thread's prev suspend count. if not -1  
```

Also, Windows Kernel Object `Thread` has value called `Suspend Count`. 
When `SuspendThread` is called `Suspend Count` became 1, and when
`ResumeThread` is called `Suspend Count` became 2. 


# Thread Synchronization 

Two perspectives of thread synchronization 

Synchronize means matching different stuffs. 
For instance A server and B server synchronous means both data are in same status 

However, synchronous here represents order, or **sequence**, rather than match.

### Memory Access based synchronization 

Blocking simultaneous, or Councurrent access of more than one thread into memory 