# Virtual Memory, Heap, MMF 

Why Virtual Memory Control is required, 
Why Heap is generated by programmers 
What advantages MMF provide . 
Sample Codes in Windows OS environment. 

## Virtual Memory Management 

In 32Bit OS, 
CPU think 4GB exist 
Programmer think 4GB exist 
Physical RAM is not sure, maybe more or less. 

In 64 Bit OS it is much larger.

Virtual Memory Control 

Virtual Memory Page Table, Page Status 
VM is divided by unit called Page. 
These day X86-64 Architecture Page is mostly 
$2^{12} = 4KB$. So, in 32 Bit OS, the total possible number of 
virtual memory pages would be 4GB / 4KB = 1,000,000. It is one million. 

Virtual page status in Windows is three. 

- Reserve 
- Commit 
- Free 

In VS2022, Free Memories are displayed as ?? ?? Question Marks. 
All unallocated pages are in free status, meaning that it is not allocated, 
aka not connected to the physical memory frame in RAM. 

Committed 4KB page in virtual memory is connected to the physical RAM 4KB frame. 
Commit is Memory allocated, while free memory is not allocated.

`malloc` for instance, make memory commit.
Commit virtual memory page means that virtual memory will be mapped to 
physical memory frame, while `free` will remove the mapping between 
virtual memory page 4KB and physical memory frame 4KB. 

However, using two status `commit` and `free` only is inefficient. 
Suppose some process is running and its memory usage sometimes 
gets 1MB for 99% of time while sometimes 4GB in 1% of time. 
Sometimes, process must need all 4GB RAM of the computer, 
but it is quite inefficient for 99% of the cases. Thus, status named 
`reserve` is implemented.

`Commit` status represent physical RAM frame is mapped to the 
virtual memory of the thread, so other threads of CPU cannot access that 
RAM frames. So, occupation of all 4GB while 99% of times it will not be necessary, 
is inefficient. 

In virtual memory, aka our programming, sometimes programmers intend to make 
sequential order of data, like arrays. Arrays let sequential access due to 
connected address. So, it is NOT expected to acquisit separated pages. 
Thus, connected pages are required, while waste of RAM should be minimized.

`Reserved` status (예약) means it is not currently used. 
It means, in Virtual Memory, it will NOT be committed. 
However, it will NOT be mapped to the physical address neither, 
preventing any physical frame mapping that will result in occupation of 
physical RAM resources. It will occupy ONLY virtual memory, but no 
physical memory due to lack of mapping of page and frame. 
When more RAM is required, then reserved virtual pages will be 
mapped to the physical memory. 

Allocation Granularity Boundary, meaning 
Starting point of Memory allocation 

Based, start by 4KB Unit.  
Page size times to prevent too much 단편화 fragmentation. 
Recommended for pages to be connected. 

Minimum allocation memory isze is at least one page, 4KB. 

```cpp
GetSystemInfo(&si) 
pageSize = si.dwPageSize // Page Size (4KB)
allocGranularity = si.dwAllocationGranularity // Memory Allocation Start Point HOW (64KB)
```

## Virtual Alloc & Virtual Free 

malloc and free 
allocate in heap. 
Is it virtual Memory ? 
malloc guarantees commit status! 
malloc and free CANNOT make Reserved status, 
meaning efficient RAM occupation is impossible!!! 

```cpp 
LPVOID VirtualAlloc(
    LPVOID lpAddress, 
    SIZE_T dwSize, 
    DWORD flAllocationType, // MEM_RESERVE OR MEM_COMMIT 
    DWORD flProtect         // PAGE_NOACCESS OR PAGE_READWRITE 
);

BOOL VirtualFree(
    LPVOID lpAddress, 
    SIZE_T dwSize, 
    DWORD dwFreeType // MEM_DECOMMIT OR MEM_RELEASE 
);
```

Virtual Memory is divided into code data heap and stack

Virtual Free turns not only Commit to Free, but also Reserved to Free. 
Moreover, Virtual Free might turn Commit to Reserved too! 
When parameter `dwFreeType` is `MEM_DECOMMIT` or `MEM_RELEASE`. 

## Heap Control 

Virtual Memory pages can be Commit or Reserved or Free status 

Heap Control 
Default Heap and Dynamic Heap 

Suppose data structure like Linked List. 
Generally, for safe memory deallocation, 
well calculated accurate delete code is required. 
One Heap contains two or more different lists or other 
complicated graph like structure usingg pointer and requires delete functions.

However, this heap used in programming is actually called as 
**Default Heap**. When process is generated, this default heap is also 
generated in default too! It automatically increase its size when required. 

In Windows OS, it is allowed to create another Heap outside default heap. 
This is **Heap Control**. 
Then, when two independent lists are implemented in each different 
heap space created, then when deleting one list, it can be removed by 
removing entire heap, instead of list deleting function. 

Dynamic Heap is more likely to be in separation of heap. 
In 32 Bit OS some data some heap some stack ... and most zones are empty. 

Some VM is in commit, some in reserve status. 
Heap is defined its size in RunTime. 
VM allocation is also in Runtime, so in some perspective 
this VM is also classified as Heap. 

Pros and Cons of Dynamic Heap 

- Pros : Memory Fragmentation rreduced 
- Cons : Program Locality reduced 
- Pros : Free from asynchronous problem  
- Pros : Because heap created per thread 

Dynamic Heap Create and Destroy 

- `HeapCreate` 
- `HeapDestroy` 
- `HeapAlloc`
- `HeapFree` 

In virtual memory space, among data stack default heap etc ... 
`malloc` will allocate in Default Heap. 
create independent heap by this `CreateHeap`. 
And inside this newly created heap space can be allocated by `HeapAlloc` 

## MMF Memory Mapped File 

Connect certain memory space of file into the process virtual memory! 
Then, writing data in process virtual memory result in file data change. 

Process <-> Memory I/O should be frequent 
Memory <-> File I/O do not have to get applied that frequently 

So, Memory and File IO can be periodic, or up to circumstance rather than 
high frequency required. 

MMF implementation 

```cpp
HANDLE hFile = CreateFile(...); // Create File K O 
HANDLE hMapFile = CreateFileMapping(hFile, ...); // File Mapping K O 
TCHAR * pWrite = MapViewOfFile(hMapFile, ...); // Connect Virtual Memory and File  
// By using File Mapping K O  
```
This returns void pointer `*pWrite`. 
Now, similar to array access, it is file data access like array or pointer access. 
