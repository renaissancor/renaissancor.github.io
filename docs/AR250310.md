# Bitwise Operators and Preprocessor Macros in C++

### Date: 2025-01-01

---

## 1. Using Macros to Simplify Code

In C++, macros defined by `#define` help create reusable code patterns that improve readability and reduce complexity.

```cpp title="Macro Definitions"
#define MY int
#define MAX_FLOOR 60

// Commonly used status flags represented in hexadecimal
#define ATT_UP      0x1
#define DEF_UP      0x2
#define DEX_UP      0x4
#define SPEED_UP    0x8
#define ATT_DOWN    0x10
#define DEF_DOWN    0x20
#define DEX_DOWN    0x40
#define SPEED_DOWN  0x80

// Frequently used combination of buffs
#define EVENT_POTION (ATT_UP | DEF_UP | DEX_UP | SPEED_UP)
```

### Why Use Macros?

1. **Simplifies frequently used patterns.**
2. **Improves readability** with descriptive names.
3. **Abstracts complex binary operations** into manageable pieces.

---

## 2. Introduction to Bitwise Operators

Bitwise operations manipulate data at the bit level, allowing precise control over memory and flags.

```cpp title="Basic Bitwise Example"
int a = 2 << 3;  // Left shift by 3: multiplies by 2Â³ = 8, result is 16
```

### Explanation of Operators

- `<<` : Left shift (multiplies by powers of 2)
- `>>` : Right shift (divides by powers of 2)
- `&`  : AND (used to check specific bits)
- `|`  : OR (used to set specific bits)
- `~`  : NOT (flips all bits)
- `^`  : XOR (toggles specific bits)

---

## 3. Using Unsigned for Accurate Bit Operations

To avoid unexpected behavior during bit shifts, use `unsigned` types.

```cpp title="Bit Shifting and Unsigned Example"
unsigned char c = -1;  // Assigns 255 due to wrap-around
c = c >> 1;            // Right shift
c = 127;
c = c << 1;            // Left shift, result is 254
```

---

## 4. Examples of Bitwise Logic

```cpp title="Bitwise AND, OR, NOT, XOR"
unsigned char c1 = 10; // 0000 1010
unsigned char c2 = 2;  // 0000 0010

unsigned char c3 = c1 & c2;  // AND: 0000 0010
c3 = c1 | c2;                // OR:  0000 1010

c1 = 0;
c1 = ~c1;                    // NOT: 1111 1111 (255)

c1 = 10;
c2 = 2;
c3 = c1 ^ c2;                // XOR: 0000 1000

c3 = c3 + 2;   // Addition
c3 += 2;       // Equivalent shorthand
```

---

## 5. Bit Flags for Game Character Status

We can use individual bits to represent character states such as attack buff, defense buff, etc.

```cpp title="Character Status Using Bit Flags"
unsigned long long CharStat = 0;

CharStat |= ATT_UP;     // Enable ATT_UP
CharStat |= DEF_UP;     // Enable DEF_UP
CharStat |= DEX_UP;     // Enable DEX_UP
CharStat |= SPEED_UP;   // Enable SPEED_UP

// Check if DEF_UP is active
if (CharStat & DEF_UP) {
    int a = 0; // Do something
}

// Toggle SPEED_UP using XOR
if (CharStat & SPEED_UP) {
    CharStat ^= SPEED_UP;  // Disable if set
}

// Forcefully remove SPEED_UP
CharStat &= ~SPEED_UP;

// Apply pre-defined combination of buffs
CharStat |= EVENT_POTION;
```

### Benefits of Bit Flags

- **Compact storage**: Multiple states in a single integer.
- **Fast checks**: Bit operations are extremely fast.
- **Flexible**: Can combine, toggle, and reset specific flags easily.


