# Bitwise Operators and Preprocessor Macros in C++

### Date: 2025-03-10

---

## Key Points

- Bitwise operations are performed on the binary level using operators like `&`, `|`, `^`, `~`, `<<`, and `>>`.
- Use `unsigned` types to avoid unexpected behavior due to sign bit extension.
- Preprocessor macros (`#define`) help simplify repetitive patterns and improve readability.
- Bitmasks can efficiently represent multiple flags in a single variable.

---

## Overview

This study note explores bitwise operations and macro definitions, commonly used in systems-level C++ to manage flags, states, and memory-efficient operations. Bitwise logic is essential for low-level data manipulation and is widely used in areas like game development, embedded systems, and real-time programming.

---

## Preprocessor Macros

```cpp
#define MY int
#define MAX_FLOOR 60
```

Macros can simplify syntax and represent meaningful constants. `MAX_FLOOR` replaces hardcoded values with readable terms.

Macros also help define flag constants with binary representations:

```cpp
#define ATT_UP    0x1
#define DEF_UP    0x2
#define DEX_UP    0x4
#define SPEED_UP  0x8
#define ATT_DOWN  0x10
#define DEF_DOWN  0x20
#define DEX_DOWN  0x40
#define SPEED_DOWN 0x80
```

Define combinations for convenience:

```cpp
#define EVENT_POTION (ATT_UP | DEF_UP | DEX_UP | SPEED_UP)
```

This enables setting multiple states with one macro.

---

## Bitwise Operators

### Shift Operators

```cpp
int a = 2 << 3;  // 2 * 2^3 = 16
```

- `<<`: Left shift multiplies by powers of 2.
- `>>`: Right shift divides by powers of 2.

Use `unsigned` types to prevent sign extension issues:

```cpp
unsigned char c = -1;  // Assigns 255
c = c >> 1;            // Logical shift
```

### Basic Bitwise Logic

```cpp
unsigned char c1 = 10; // 0000 1010
unsigned char c2 = 2;  // 0000 0010

unsigned char c3 = c1 & c2;  // AND -> 0000 0010
c3 = c1 | c2;                // OR  -> 0000 1010
c3 = c1 ^ c2;                // XOR -> 0000 1000
c3 = ~c1;                    // NOT -> 1111 0101
```

You can combine arithmetic and assignment:

```cpp
c3 += 2;  // Same as: c3 = c3 + 2;
```

---

## Tricky Case: Flag Management with Bitmask

```cpp
unsigned long long CharStat = 0;

CharStat |= ATT_UP;     // Turn on ATT_UP flag
CharStat |= DEF_UP;     // Turn on DEF_UP flag
CharStat |= DEX_UP;
CharStat |= SPEED_UP;

// Check if DEF_UP is enabled
if (CharStat & DEF_UP) {
    // Flag is set
}

// Toggle SPEED_UP flag
if (CharStat & SPEED_UP) {
    CharStat ^= SPEED_UP;
}

// Ensure SPEED_UP is disabled
CharStat &= ~SPEED_UP;

// Apply all boost flags at once
CharStat |= EVENT_POTION;
```

This design is commonly used in games to manage character statuses efficiently.

---

## Interview Questions

**Q: What's the difference between `|` and `^` in bitwise operations?**  
A: `|` sets bits if either operand has them set, while `^` sets bits only if exactly one operand has them set.

**Q: Why use `unsigned` types with shift operators?**  
A: Signed integers may introduce sign-extension behavior on right shifts. `unsigned` ensures predictable logic.

**Q: How do you check and toggle a specific bit using bitwise operations?**  
A: Use `&` to check: `if (val & FLAG)`, `^` to toggle: `val ^= FLAG`, and `|` to set: `val |= FLAG`.

**Q: When would you use bitmasks in real applications?**  
A: Bitmasks are efficient for representing multiple boolean states in embedded systems, game engines, or low-latency environments.

---

## Code Demonstration

```cpp
unsigned long long CharStat = 0;
CharStat |= ATT_UP | DEF_UP;

if (CharStat & ATT_UP) {
    std::cout << "Attack Boost Active\n";
}

CharStat &= ~ATT_UP;  // Disable ATT_UP
```

---

## Visual: Bit Masking

```
Initial State      After |= ATT_UP
-------------      ------------------
0000 0000          0000 0001

After |= DEF_UP
0000 0001          0000 0011

After ^= DEF_UP
0000 0011          0000 0001

After &= ~ATT_UP
0000 0001          0000 0000
```

---


