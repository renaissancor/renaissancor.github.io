{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"#common-commands","title":"Common Commands","text":"<pre><code>mkdocs serve\nmkdocs build\nmkdocs gh-deploy\n</code></pre> <p>Visual Studio </p> <p><code>Ctrl</code> + <code>F5</code> Program Execution </p> <p><code>Ctrl</code> + <code>~</code>  Open Terminal </p> <p><code>F5</code>          Program Debug </p> <p>Visual Studio Code </p> <p><pre><code>svn update \nsvn log -v -l 10 \n</code></pre> Shows latest 10 logs of svn updated records containing file changes </p> <pre><code>Get-Content \"docs/AR250409.md\" | Out-String | Select-String -Pattern '[^\\x00-\\x7F]' -AllMatches\n</code></pre> <p>Open git bash  <pre><code>iconv -f UTF-8 -t UTF-8 docs/AR250409.md &gt; /dev/null\n</code></pre></p>"},{"location":"AR111111/","title":"Sample Template Title","text":"<p>Write a Markdown-formatted study note for my MkDocs-based C++ blog. Generate markdown texts with this kind of structure:</p>"},{"location":"AR111111/#sample-template-title_1","title":"Sample Template Title","text":""},{"location":"AR111111/#date-2025-01-01","title":"Date: 2025-01-01","text":""},{"location":"AR111111/#key-points","title":"Key Points","text":"<ul> <li>Move semantics transfer ownership instead of copying.</li> <li><code>std::move()</code> performs a cast to an rvalue reference.</li> <li>Mark move operations <code>noexcept</code> to enable STL optimizations.</li> <li>Rule of Five: if you define one special function, consider defining all five.</li> </ul>"},{"location":"AR111111/#overview","title":"Overview","text":"<p>Move semantics, introduced in C++11, enable efficient resource transfer?\ubd34seful for managing dynamic memory, file handles, etc.</p> <pre><code>class Resource {\n    int* data; size_t size;\n\npublic:\n    Resource(size_t s) : size(s), data(new int[s]) {}\n    ~Resource() { delete[] data; }\n\n    Resource(const Resource&amp; other);\n\n    Resource(Resource&amp;&amp; other) noexcept\n        : data(other.data), size(other.size) {\n        other.data = nullptr; other.size = 0;\n    }\n\n    Resource&amp; operator=(Resource&amp;&amp; other) noexcept {\n        if (this != &amp;other) {\n            delete[] data;\n            data = other.data; size = other.size;\n            other.data = nullptr; other.size = 0;\n        }\n        return *this;\n    }\n};\n</code></pre>"},{"location":"AR111111/#common-mistakes","title":"Common Mistakes","text":"<p>Using moved-from objects <pre><code>std::vector&lt;int&gt; v1 = {1, 2, 3};\nstd::vector&lt;int&gt; v2 = std::move(v1);\n// v1 is now valid but unspecified\n</code></pre></p> <p>Missing <code>noexcept</code> <pre><code>class A {\npublic:\n    A(A&amp;&amp;) noexcept;  // Allows STL containers to optimize\n};\n</code></pre></p> <p>Preventing RVO (Return Value Optimization) <pre><code>std::vector&lt;int&gt; create() {\n    std::vector&lt;int&gt; v = {1, 2};\n    return std::move(v);  // Bad: disables RVO\n    // return v;          // Good: lets RVO work\n}\n</code></pre></p>"},{"location":"AR111111/#tricky-case-unique_ptr","title":"Tricky Case: <code>unique_ptr</code>","text":"<pre><code>auto ptr = std::make_unique&lt;Resource&gt;();\n\n// Error: copy is disabled\n// process(ptr);\n\n// Correct: use std::move\nprocess(std::move(ptr));\n</code></pre> <p>After the move, <code>ptr</code> is null and must not be used except for reset or reassignment.</p>"},{"location":"AR111111/#interview-questions","title":"Interview Questions","text":"<p>Q: Difference between <code>std::move</code> and <code>std::forward</code>? A: <code>std::move</code> casts to rvalue; <code>std::forward</code> preserves value category in template functions.</p> <p>Q: Why use <code>noexcept</code> with move? A: Containers prefer <code>noexcept</code> move operations to maintain strong exception guarantees.</p>"},{"location":"AR111111/#modern-examples","title":"Modern Examples","text":"<pre><code>// C++17: optional + implicit move\nstd::optional&lt;std::string&gt; get(bool ok) {\n    if (ok) return std::string(\"value\");\n    return std::nullopt;\n}\n\n// C++20: constexpr move\nconstexpr std::string create() {\n    std::string a = \"A\";\n    return std::move(a);\n}\n</code></pre>"},{"location":"AR111111/#code-demonstration","title":"Code Demonstration","text":"<pre><code>std::string a = \"Hello\";\nstd::string b = std::move(a);\n\nstd::cout &lt;&lt; \"b: \" &lt;&lt; b &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"a: \" &lt;&lt; a &lt;&lt; \"\\n\";  // Moved-from state\n</code></pre>"},{"location":"AR111111/#visual-ownership-transfer","title":"Visual: Ownership Transfer","text":"<pre><code>Before Move             After Move\n------------            -------------\nObject A                Object A\n[data -&gt; 0x1234]        [data -&gt; nullptr]\n\nObject B                Object B\n[data -&gt; nullptr]       [data -&gt; 0x1234]\n</code></pre> <p>Format the explanation clearly and concisely,  so easily readable while containing all necessary details.  Respect the comments inside the code and rewrite them in the blog text description.  Keep code blocks clean and readable.  Focus on tricky cases and common cases that might be crucial later as C++ video game programmer intervew  Create extra contents for common mistakes or tricky cases.  Make sample interview questions and answers.  It is good to make tricky cases or sample interview questions related to input text.  Write in English. Do not use icon. Return markdown in canvas, aka textdoc editor. Now convert the study notes and codes I will copy and paste below.  Date is 2025 03 10</p> <p>Convert the study notes and code I will paste below into a well-structured markdown article for my technical blog.  It should serve as a comprehensive study guide for a C++ game programmer interview. Clearly and concisely explain each concept for easy readability without skipping any important idea or nuance.  Integrate all original notes and comments from the code into the markdown explanation.  These should appear as narrative text, not left as raw comments. Keep code blocks clean and correctly formatted, grouped logically with the explanation. Add any missing examples or diagrams to clarify tricky or subtle mechanics.  Relate sample questions and tricky cases directly to input content where possible.  No emojis or icons.  Output in markdown format only, using the canvas editor.</p> <p>const_member_variables.cpp  <pre><code>class CMyClass\n{\nprivate:\n    int         m_i;\n    const char  m_C;\n\npublic:\n    void SetIntData(int _Data)\n    {\n        m_i = _Data;\n    }\n\n    // const \ub9f4\ubc84\ud568\uc218\n    // \ub9f4\ubc84\ud568\uc218 \ub4a4\uc5d0 const \ub97c \ubd99\uc774\uba74, \n    // \ud574\ub2f9 \ub9f4\ubc84\ud568\uc218\uac00 \ub3d9\uc791\ud558\ub294\ub3d9\uc548 \uac1d\uccb4\uc758 \ub9f4\ubc84\ub97c \ubcc0\uacbd\uc744 \ud558\uc9c0 \uc54a\uc74c\uc744 \ubcf4\uc7a5\ud55c\ub2e4.\n    int GetIntData() const\n    {\n        return m_i;\n    }\n\n    char GetCharData() const\n    {\n        return m_C;\n    }\n\npublic:\n    CMyClass()\n        : m_i(0)\n        , m_C(100)\n    {\n        m_i = 10;\n    }\n\n    ~CMyClass()\n    {\n    }\n};\n\n\n\nint main()\n{\n    const int a = 100;\n\n    CMyClass c;\n    CMyClass c1;\n\n    c.SetIntData(200);\n\n    // const * \uc640 const \ub9f4\ubc84\ud568\uc218\n    const CMyClass* pMy = &amp;c;\n    pMy-&gt;GetIntData();\n\n\n\n    return 0;\n}\n</code></pre></p> <p>static_member_function.cpp <pre><code>class CTest\n{\nprivate:\n    static int  m_Static;\n\nprivate:\n    int         m_i;\n\npublic:\n    void SetData(int _Data) \n    { \n        this-&gt;m_i = _Data; \n        m_Static = 20;\n    }\n\n    // \uac1d\uccb4 \uc5c6\uc774 \ud638\ucd9c\uac00\ub2a5\ud55c \ub9f4\ubc84\ud568\uc218\n    // this \ud3ec\uc778\ud130 \uc5c6\ub2e4 == \ub9f4\ubc84\ubcc0\uc218 \uc0ac\uc6a9 \ubd88\uac00\ub2a5\n    static void StaticFunc() \n    {\n        // \uc815\uc801\ub9f4\ubc84\ubcc0\uc218\uac00 private \uc774\ub77c\ub3c4 \uc815\uc801\ub9f4\ubc84\ud568\uc218\ub3c4 \ub9f4\ubc84\ud568\uc218\uae30 \ub54c\ubb38\uc5d0 \uc811\uadfc \uac00\ub2a5\n        m_Static = 100;\n\n    }\n\npublic:\n    CTest() :m_i(0) {};\n    ~CTest() {}\n};\n\nint CTest::m_Static = 0;\n\n\n\n// \uc804\uc5ed\ud568\uc218\nvoid GlobalFunc()\n{\n    // \uc815\uc801\ub9f4\ubc84\ubcc0\uc218\uac00 private \uc774\ub77c\uc11c \uc678\ubd80\uc5d0\uc11c\ub294 \uc811\uadfc\uc774 \ubd88\uac00\ub2a5\n    //CTest::m_Static = 100;\n}\n\nint main()\n{\n    CTest t1;\n    CTest t2;\n    CTest t3;\n\n    t1.SetData(100);\n    t2.SetData(100);\n    t3.SetData(100);\n\n\n\n    // \uc815\uc801\ub9f4\ubc84\ud568\uc218\ub294 \ud2b9\uc815\uac1d\uccb4\uac00 \uc5c6\uc774\ub3c4 \ud638\ucd9c\uc774 \uac00\ub2a5\ud558\ub2e4\n    // this \uac1c\ub150\uc774 \uc874\uc7ac\ud558\uc9c0 \uc54a\uae30 \ub54c\ubb38\n    CTest::StaticFunc();\n\n    // \uc815\uc801\ub9f4\ubc84\ud568\uc218\uc640 \uc77c\ubc18 \uc804\uc5ed\ud568\uc218\uc640\uc758 \ucc28\uc774?\n    // \uc815\uc801\ub9f4\ubc84\ud568\uc218\ub3c4 \ub9f4\ubc84\ud568\uc218\uc758 \uc77c\uc885\uc774\uae30 \ub54c\ubb38\uc5d0, \n    // \uc815\uc801\ub9f4\ubc84\ud568\uc218\uac00 \uc120\uc5b8\ub41c \ud074\ub798\uc2a4\uc758 private: \uae30\ub2a5\uc5d0 \uc811\uadfc\uc774 \uac00\ub2a5\ud558\ub2e4.\n    // \uc815\uc801\ub9f4\ubc84\ud568\uc218 \uc548\uc5d0\uc11c\ub294 private: \uc5d0 \uc120\uc5b8\ub41c \uc815\uc801\ub9f4\ubc84\ubcc0\uc218\uc5d0 \uc811\uadfc \uac00\ub2a5\ud558\ub2e4.\n    GlobalFunc();\n\n    // \uc815\uc801\ub9f4\ubc84\ubcc0\uc218\uac00 private \uc774\ub77c\uc11c \uc678\ubd80\uc5d0\uc11c\ub294 \uc811\uadfc\uc774 \ubd88\uac00\ub2a5\n    //CTest::m_Static = 200;\n\n    return 0;\n}\n</code></pre></p> <p>static_var_class.cpp <pre><code>// \uc815\uc801\ubcc0\uc218\n// \uacf5\ud1b5 - \ub370\uc774\ud130 \uc601\uc5ed\uc5d0 \uc800\uc7a5\uc774 \ub41c\ub2e4.\n// 1. \uc804\uc5ed\ud568\uc218, \ub9f4\ubc84\ud568\uc218 \uc548\uc5d0 \uc120\uc5b8\ub41c \uacbd\uc6b0\n//  \ud574\ub2f9 \ud568\uc218 \uc804\uc6a9 \uc804\uc5ed\ubcc0\uc218\n//  \ud574\ub2f9 \ud568\uc218\uc548\uc5d0\uc11c\ub9cc \ubcc0\uc218\uba85\uc73c\ub85c \uc811\uadfc\uc774 \uac00\ub2a5\n//  \uc8fc\uc18c\ub97c \uc54c\uba74 \ud3ec\uc778\ud130\ub85c\ub294 \uc5b4\ub514\uc11c\ub4e0 \uc811\uadfc \uac00\ub2a5\n\n\n// 2. cpp \ud30c\uc77c\uc5d0 \uc120\uc5b8\ud558\ub294 \uacbd\uc6b0\n//  \uc120\uc5b8\ub41c \ud30c\uc77c \uc804\uc6a9 \uc804\uc5ed\ubcc0\uc218\n//  \ub2e4\ub978 cpp \uc5d0 \ub611\uac19\uc740 \uc774\ub984\uc758 \uc804\uc5ed\ubcc0\uc218\uac00 \uc788\uc5b4\ub3c4 \uc0c1\uad00\uc774 \uc5c6\ub2e4.\nstatic int g_static = 0;\n\n\n\n\n\n// 3. \ud074\ub798\uc2a4 \ub9f4\ubc84\ubcc0\uc218\uc55e\uc5d0 static \uc774 \ubd99\uc740 \uacbd\uc6b0\n//  \uc815\uc801 \ub9f4\ubc84\ubcc0\uc218\n//  \ud574\ub2f9 \ud074\ub798\uc2a4 \uc790\ub8cc\ud615 \uc804\uc6a9 \uc804\uc5ed\ubcc0\uc218\n//  \ub9f4\ubc84\ubcc0\uc218\uc758 \ud2b9\uc9d5\uc778 \uc811\uadfc\uc81c\ud55c \uc9c0\uc815\uc790\uc5d0 \uc601\ud5a5\uc744 \ubc1b\uc74c\n//  private: \ud544\ub4dc\uc5d0 \uc120\uc5b8\ub41c \uacbd\uc6b0, \ud574\ub2f9 \ud074\ub798\uc2a4 \ub9f4\ubc84\ud568\uc218 \uc548\uc5d0\uc11c\ub9cc \uc811\uadfc \uac00\ub2a5\n//  public: \ud544\ub4dc\uc5d0 \uc120\uc5b8\ub41c \uacbd\uc6b0 \ud2b9\uc815 \uac1d\uccb4 \uc5c6\uc774\ub3c4 \uc811\uadfc \uac00\ub2a5(\uac1d\uccb4 \uc548\uc5d0 \ub4e4\uc5b4\uc788\ub294 \uac1c\ub150\uc774 \uc544\ub2c8\uae30 \ub54c\ubb38)\nclass CTestClass\n{\npublic:\n    static int  m_StaticMember; // \uc804\ubc29\uc120\uc5b8\n\nprivate:\n    // static == \ub370\uc774\ud130\uc601\uc5ed\n    // \uc815\uc801 \ub9f4\ubc84\ub294 \ub370\uc774\ud130\uc601\uc5ed\uc5d0 1\uac1c\ub9cc \uc874\uc7ac\ud568    \n    int         m_Member;\n\npublic:\n    CTestClass()\n        : m_Member(0)       \n    {\n        m_StaticMember = 20;\n    }\n    ~CTestClass()\n    {}\n};\n\n// \ud2b9\uc815 CPP \uc5d0 \ubc18\ub4dc\uc2dc \ub9c1\ud06c\ubc1b\uc744 \uc2e4\uc81c \uc815\uc801\ub9f4\ubc84\ubcc0\uc218\ub97c \uc815\uc758\ud574\uc57c\ud568\n// extern \uc804\uc5ed\ubcc0\uc218\uc640 \uc720\uc0ac\ud55c \uad6c\uc870\nint CTestClass::m_StaticMember = 0;\n\n\n\n\nint* StaticFunc()\n{\n    static int iStatic = 0;\n    iStatic = 100;\n\n    return &amp;iStatic;\n}\n\n\n\n\n\n\nint main()\n{\n    int* pStatic = StaticFunc();\n\n    *pStatic = 300;\n\n    StaticFunc();\n\n    CTestClass inst;\n    CTestClass inst1;\n    CTestClass inst2;\n\n    inst.m_StaticMember = 10;\n    inst1.m_StaticMember = 20;\n    inst2.m_StaticMember = 30;\n\n    CTestClass::m_StaticMember = 40;\n\n\n    return 0;\n}\n</code></pre></p> <p>polymorphism.cpp <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\n\n\n// \ub2e4\ud615\uc131\n// \uc0c1\uc18d\n// \ud3ec\uc778\ud130\nclass Parent\n{\nprivate:\n    float   m_P;\n\npublic:\n    virtual void Move()\n    {\n        cout &lt;&lt; \"!!Parent Move!!\" &lt;&lt; endl;\n    }\n\n    virtual void Test()\n    {\n        cout &lt;&lt; \"!!Parent Test!!\" &lt;&lt; endl;\n    }\n\n    // \uc21c\uc218 \uac00\uc0c1\ud568\uc218\n    virtual void Fly() = 0;\n};\n\nclass Child\n    : public Parent\n{\nprivate:\n    short   m_S;\n\npublic:\n    virtual void Move() override\n    {\n        cout &lt;&lt; \"!!Child Move!!\" &lt;&lt; endl;\n    }\n\n    virtual void SetShort(short _Short)\n    {\n        m_S = _Short;\n    }\n};\n\nint main()\n{\n    Parent  P;\n    Child   C;\n\n    int size = 0;\n    size = sizeof(P);\n    size = sizeof(C);\n\n    Parent* pParent = &amp;P;\n    Child* pChild = &amp;C;\n\n    pParent = &amp;C; // -- (1) \ubd80\ubaa8\ud074\ub798\uc2a4 \ud3ec\uc778\ud130\ub85c, \uc790\uc2dd\ud074\ub798\uc2a4 \uac1d\uccb4\uc758 \uc8fc\uc18c\ub97c \uc800\uc7a5\ud560 \uc218 \uc788\ub098?\n    //pChild = &amp;P;  // -- (2) \uc790\uc2dd\ud074\ub798\uc2a4 \ud3ec\uc778\ud130\ub85c, \ubd80\ubaa8\ud074\ub798\uc2a4 \uac1d\uccb4\uc758 \uc8fc\uc18c\ub97c \uc800\uc7a5\ud560 \uc218 \uc788\ub098?\n\n    // \ubd80\ubaa8\ud074\ub798\uc2a4 \ud3ec\uc778\ud130 \ubcc0\uc218\ub294, \ubd80\ubaa8\ud074\ub798\uc2a4\ub85c\ubd80\ud130 \ud30c\uc0dd\ub41c \ubaa8\ub4e0 \ud074\ub798\uc2a4 \uac1d\uccb4\ub4e4\uc758 \uc8fc\uc18c\ub97c \uc800\uc7a5\ud560 \uc218 \uc788\ub2e4.\n    // \uac00\ub9ac\ud0a4\ub294 \uc601\uc5ed\uc774, \ud574\ub2f9 \uac1d\uccb4\uc758 \uac00\uc7a5 \uc55e\ubd80\ubd84(\ubd80\ubaa8\ud074\ub798\uc2a4 \uc601\uc5ed) \uae4c\uc9c0\ub9cc \uac00\ub9ac\ud0a4\uae30 \ub54c\ubb38\n\n    // \ub2e4\ud615\uc131\n    // \ubd80\ubaa8\ud074\ub798\uc2a4 \ud3ec\uc778\ud130\ubcc0\uc218 \ud558\ub098\ub85c, \ubd80\ubaa8\ud074\ub798\uc2a4\ub85c\ubd80\ud130 \ud30c\uc0dd\ub418\ub294 \ubaa8\ub4e0 \ud074\ub798\uc2a4\ub4e4\uc758 \uac1d\uccb4\uc758 \uc8fc\uc18c\ub97c \uc800\uc7a5\ud560 \uc218 \uc788\ub2e4.\n    // \ud558\ub098\uc758 \ud0c0\uc785\uc73c\ub85c, \uc0dd\uc131\ub41c \uadf8\ub9ac\uace0 \uc55e\uc73c\ub85c \uc0dd\uc131\ub420 \ubaa8\ub4e0 \ud074\ub798\uc2a4\ud0c0\uc785 \uac1d\uccb4\ub97c \uad00\ub9ac \uac00\ub2a5\n    // \ud0c0\uc785\uc740 \ud558\ub098\uc9c0\ub9cc, \uac00\ub9ac\ud0a4\ub294 \ub300\uc0c1\uc740 \ubb50\ub4e0\uc9c0 \uac00\ub2a5\ud568\n\n    // \ub2e4\ud615\uc131\uc758 \ubb38\uc81c\uc810\n    // \ubd80\ubaa8\ud3ec\uc778\ud130 \ud0c0\uc785\uc73c\ub85c \uc790\uc2dd\uac1d\uccb4\ub97c \uac00\ub9ac\ud0a4\uba74\uc11c \uc624\ubc84\ub77c\uc774\ub529\ub41c \ud568\uc218\ub97c \ud638\ucd9c\uc2dc\ud0ac \uacbd\uc6b0,\n    // \ucef4\ud30c\uc77c\ub7ec\ub294 \ud638\ucd9c\uc790 \ud3ec\uc778\ud130\uac00 \ubd80\ubaa8\ud3ec\uc778\ud130 \ud0c0\uc785\uc774\uae30 \ub54c\ubb38\uc5d0, \ucef4\ud30c\uc77c \ud0c0\uc784\uc5d0 \ubd80\ubaa8\ucabd \ud568\uc218\ub85c \uc815\uc801\ubc14\uc778\ub529\uc744 \ud558\uac8c \ub428\n\n    // \ud574\uacb0 - \ubd80\ubaa8 \ud3ec\uc778\ud130\ub85c \uc790\uc2dd\ucabd\uc5d0 \uc624\ubc84\ub77c\uc774\ub529\ub41c \ud568\uc218\uac00 \ud638\ucd9c\uc774 \uc548\ub418\ub294 \ubb38\uc81c\ub97c \ud574\uacb0\ud558\uae30\uc704\ud574\uc11c\n    //        virtual(\uac00\uc0c1\ud568\uc218) \ub97c \ud65c\uc6a9\ud55c\ub2e4.\n    P.Move();\n    C.Move();\n\n    // Parent \ud3ec\uc778\ud130\ub85c Parent \uac1d\uccb4\ub97c \uac00\ub9ac\ud0a4\uace0, Move \ub97c \ud638\ucd9c\uc2dc\ud0b4\n    // Parent::Move \uac00 \ud638\ucd9c\ub428\n    pParent = &amp;P;\n    pParent-&gt;Move(); \n\n    // Parent \ud3ec\uc778\ud130\ub85c Child \uac1d\uccb4\ub97c \uac00\ub9ac\ud0a4\uace0, Move \ub97c \ud638\ucd9c\uc2dc\ud0b4\n    // Child::Move \uac00 \ud638\ucd9c\ub418\uc5b4\uc57c \ud558\ub294\ub370 Parent::Move \uac00 \ud638\ucd9c\ub418\ubc84\ub9bc ==&gt; \ubb38\uc81c\uc0ac\ud56d\n    pParent = &amp;C;\n    pParent-&gt;Test();\n\n    // virtual \uac00\uc0c1\ud568\uc218\n    // \ub7f0\ud0c0\uc784 \uc911\uc5d0, \uc2e4\uc81c \uac1d\uccb4\uc758 \ud074\ub798\uc2a4\uc5d0 \ub9de\ub294 \ubc84\uc804\uc758 \uc624\ubc84\ub77c\uc774\ub529\ub41c \ud568\uc218\ub97c \uad6c\ubcc4\ud574\uc11c \ud638\ucd9c\uc2dc\ud0ac \uc218 \uc788\uac8c \ud574\uc90c\n\n    // \uac00\uc0c1\ud568\uc218 \ub3d9\uc791 \uc6d0\ub9ac\n    // \uac00\uc0c1\ud568\uc218\ub97c \ubcf4\uc720\ud558\uace0\uc788\ub294 \ubd80\ubaa8\ud074\ub798\uc2a4 \ubfd0\ub9cc \uc544\ub2c8\ub77c, \uadf8\uac78 \uc0c1\uc18d\ubc1b\uc740 \ubaa8\ub4e0 \uc790\uc2dd\ud074\ub798\uc2a4\ub4e4\ub3c4 \uac01\uac01 TypeInfo \uac00 \uc0dd\uc131\ub41c\ub2e4.\n    // TypeInfo \uc548\uc5d0\ub294 \uac00\uc0c1\ud568\uc218 \ud14c\uc774\ube14\uc774 \uc788\ub2e4. \ud574\ub2f9\ud074\ub798\uc2a4\uc758 \uac00\uc0c1\ud568\uc218\uc758 \uc8fc\uc18c\ub4e4\uc744 \uc800\uc7a5\ud558\uace0 \uc788\ub2e4. \n    // \uac00\uc0c1\ud568\uc218\ub97c \ubcf4\uc720\ud55c \ubd80\ubaa8 \ud074\ub798\uc2a4\ub294 __vfptr(\uac00\uc0c1\ud568\uc218 \ud14c\uc774\ube14 \ud3ec\uc778\ud130) \uc774\ub77c\ub294 \ud3ec\uc778\ud130\ubcc0\uc218\uac00 \uc0dd\ub7b5\ub418\uc5b4\uc788\ub2e4.\n\n\n    // \ucd94\uc0c1\ud654\n    // virtual \ud568\uc218\uba85 = 0; == \uc21c\uc218\uac00\uc0c1\ud568\uc218\n    // \uac00\uc0c1\ud568\uc218\ub97c \uc120\uc5b8\ud568\uc73c\ub85c\uc368 \uc790\uc2dd\ucabd\uc5d0\uc11c \uc624\ubc84\ub77c\uc774\ub529 \ud560 \uc218 \uc788\uac8c \ud558\uace0, \ud574\ub2f9 \ud074\ub798\uc2a4\uc5d0\ub294 \uad6c\ud604\uc744 \ud558\uc9c0 \uc54a\uc74c\n    // \uac00\uc0c1\ud568\uc218\ub97c \uad6c\ud604\ud558\uc9c0 \uc54a\uc558\uae30 \ub54c\ubb38\uc5d0, \ud14c\uc774\ube14\uc5d0 \ub4f1\ub85d\uc2dc\ud0ac \ud568\uc218\uac00 \uc5c6\uac8c \ub418\uace0, \n    // \ub530\ub77c\uc11c \ud574\ub2f9 \ud074\ub798\uc2a4\ub85c \uac1d\uccb4\uc0dd\uc131\uc744 \ud558\ub294\uac83\uc774 \uae08\uc9c0 \ub428\n\n    // \uc21c\uc218\uac00\uc0c1\ud568\uc218\ub97c \uc790\uc2dd\ud074\ub798\uc2a4\ub3c4 \uc624\ubc84\ub77c\uc774\ub529(\uc7ac\uc815\uc758) \ud558\uc9c0 \uc54a\uc73c\uba74, \ud574\ub2f9 \ud074\ub798\uc2a4\ub3c4 \ud638\ucd9c\ud560 \ud568\uc218\uac00 \uc5c6\uae30\ub54c\ubb38\uc5d0\n    // \uac1d\uccb4\uc0dd\uc131\uc774 \ubd88\uac00\ub2a5\ud558\ub2e4.\n\n    // \uc21c\uc218\uac00\uc0c1\ud568\uc218\ub97c \uad6c\ud604\ud55c \uc790\uc2dd\ud074\ub798\uc2a4\ubd80\ud130 \uac1d\uccb4\uc0dd\uc131\uc774 \uac00\ub2a5\ud574\uc9c4\ub2e4.\n\n    // \uc21c\uc218\uac00\uc0c1\ud568\uc218\uac00 \uc120\uc5b8\ub41c \ud074\ub798\uc2a4\uac00 \ucd94\uc0c1\uc801\uc778 \uac1c\ub150\uc758 \ud074\ub798\uc2a4\uc784\uc744 \uc120\uc5b8\n    // \ucd94\uc0c1\ud074\ub798\uc2a4\ub294 \uac1d\uccb4\uc0dd\uc131\uc744 \ud560 \uc218 \uc5c6\ub3c4\ub85d \ubc29\uc9c0\ud568\n    // \ud30c\uc0dd\ub418\ub294 \uc790\uc2dd\ud074\ub798\uc2a4\ub4e4\uc774 \ud574\ub2f9 \ud568\uc218\ub97c \uad6c\ud604\ud558\ub3c4\ub85d \uac15\uc81c\ud558\uace0, \n\n\n\n\n\n    return 0;\n}\n</code></pre></p>"},{"location":"AR250403/","title":"Dynamic Array, STL Vector","text":""},{"location":"AR250403/#date-2025-04-03","title":"Date: 2025-04-03","text":""},{"location":"AR250403/#key-points","title":"Key Points","text":"<ul> <li>C++ templates can deduce array size from references but generate separate functions for each size.</li> <li>Prefer pointer + size parameters for reusable and efficient code.</li> <li><code>new</code> and <code>delete</code> guarantee constructor/destructor calls, unlike <code>malloc</code>/<code>free</code>.</li> <li>Mixing C-style allocation with C++ class objects is unsafe.</li> </ul>"},{"location":"AR250403/#overview","title":"Overview","text":"<p>This note explores how dynamic arrays are handled in C++ with templates, allocation mechanisms (<code>new/delete</code> vs. <code>malloc/free</code>), and class construction behavior.</p>"},{"location":"AR250403/#array-templates","title":"Array Templates","text":"<p>Passing an array as a reference in a function allows the compiler to deduce its size, but:</p> <pre><code>void SetData(int (&amp;_Arr)[10]) {\n    for(int i = 0; i &lt; 10; ++i) {\n        _Arr[i] = i + 1;\n    }\n}\n\nint iArr[10] = {};\nint jArr[20] = {};\nSetData(iArr);    // OK\nSetData(jArr);    // ERROR: size mismatch\n</code></pre> <p>To fix this, use a template parameter for array size:</p> <pre><code>template&lt;int Size&gt;\nvoid SetData(int (&amp;_Arr)[Size]) {\n    for(int i = 0; i &lt; Size; ++i) {\n        _Arr[i] = i + 1;\n    }\n}\n</code></pre> <p>However, this creates a new function for each different size, which is inefficient if heavily reused.</p> <p>Instead, use pointer and explicit size:</p> <pre><code>void SetData(int* _Arr, int Size) {\n    for(int i = 0; i &lt; Size; ++i) {\n        _Arr[i] = i + 1;\n    }\n}\n</code></pre> <p>This pattern avoids template bloat and increases flexibility.</p>"},{"location":"AR250403/#c-dynamic-memory-newdelete-vs-mallocfree","title":"C++ Dynamic Memory: <code>new/delete</code> vs <code>malloc/free</code>","text":"<pre><code>int* pData = (int*) malloc(sizeof(int) * 2);\nfree(pData);\n</code></pre> <p>In C++, use of <code>malloc</code> is discouraged for objects, because it doesn't call constructors. Instead:</p> <pre><code>MyClass* obj = new MyClass();\ndelete obj;\n</code></pre> <p>Here: - <code>new</code> = <code>malloc</code> + constructor call - <code>delete</code> = destructor call + <code>free</code></p> <p>This is essential for managing resources and guarantees correct initialization and cleanup.</p>"},{"location":"AR250403/#object-on-stack","title":"Object on Stack","text":"<pre><code>MyClass my;\n</code></pre> <p>Stack-allocated objects automatically call the constructor and destructor at scope entry/exit.</p>"},{"location":"AR250403/#object-with-malloc-not-recommended","title":"Object with <code>malloc</code> (Not Recommended)","text":"<pre><code>MyClass* pMy = (MyClass*) malloc(sizeof(MyClass)); // Constructor NOT called\nfree(pMy); // Destructor NOT called\n</code></pre>"},{"location":"AR250403/#correct-approach-with-class","title":"Correct Approach with Class","text":"<pre><code>MyClass* pNewMy = new MyClass();\ndelete pNewMy;\n</code></pre> <p>This ensures both constructor and destructor are properly handled.</p>"},{"location":"AR250403/#function-templates-arithmetic-example","title":"Function Templates: Arithmetic Example","text":"<pre><code>template&lt;typename A&gt;\nA Add(A a, A b) {\n    A c = a + b;\n    return c;\n}\n\nint a = Add(10, 20);\nfloat f = Add(2.1f, 1.9f);\nshort s1 = 10, s2 = 30;\nshort s3 = Add(s1, s2);\n</code></pre> <p>This template function can add values of any arithmetic type.</p>"},{"location":"AR250403/#code-demonstration-setdata-and-arrays","title":"Code Demonstration: SetData and Arrays","text":"<pre><code>int iArr[20] = {};\nSetData(iArr, 20);\n\nint Arr[40] = {};\nSetData(Arr, 40);\n</code></pre> <p>Function works with arrays of any size using pointer+size.</p>"},{"location":"AR250403/#c-style-vs-class-style-dynamic-arrays","title":"C-style vs. Class-style Dynamic Arrays","text":"<pre><code>#include \"Array.h\"\n#include \"CArray.h\"\n\nint main() {\n    tArray arr = {};\n    InitArr(&amp;arr);\n\n    PushBack(&amp;arr, 10);\n    PushBack(&amp;arr, 20);\n    PushBack(&amp;arr, 30);\n\n    CArray IntArr;\n    IntArr.reserve(100);\n\n    IntArr.push_back(10);\n    IntArr.push_back(20);\n    IntArr.push_back(30);\n\n    return 0;\n}\n</code></pre> <ul> <li><code>tArray</code> is a C-style dynamic array.</li> <li><code>CArray</code> is a class-based dynamic array with encapsulation and safe resizing.</li> </ul>"},{"location":"AR250403/#common-mistakes","title":"Common Mistakes","text":"<p>Using <code>malloc</code> for C++ objects</p> <pre><code>MyClass* obj = (MyClass*) malloc(sizeof(MyClass)); // Bad: no constructor\n</code></pre> <p>Array reference with fixed size only</p> <pre><code>void SetData(int (&amp;_Arr)[10]); // Only works with size 10\n</code></pre>"},{"location":"AR250403/#tricky-case-template-bloat","title":"Tricky Case: Template Bloat","text":"<p>Each <code>Size</code> in <code>template&lt;int Size&gt;</code> produces a new instantiation.</p> <pre><code>template&lt;int Size&gt;\nvoid SetData(int (&amp;_Arr)[Size]); // Separate for [10], [20], etc.\n</code></pre> <p>Better to use:</p> <pre><code>void SetData(int* _Arr, int Size);\n</code></pre>"},{"location":"AR250403/#interview-questions","title":"Interview Questions","text":"<p>Q: What are the pros and cons of using array reference templates in C++? A: Pros: compile-time size check, no need to pass size. Cons: code bloat due to multiple instantiations.</p> <p>Q: Why is <code>malloc</code> discouraged for C++ class objects? A: Because it does not call constructors/destructors, leading to unsafe initialization and memory leaks.</p> <p>Q: Difference between <code>new</code> and <code>malloc</code> in C++? A: <code>new</code> invokes constructors and throws on failure. <code>malloc</code> returns void* and does not initialize objects.</p> <p>Q: How do you safely manage dynamic memory for a class? A: Use <code>new</code>/<code>delete</code>, or better yet, use smart pointers (<code>std::unique_ptr</code>, <code>std::shared_ptr</code>).</p>"},{"location":"AR250403/#references","title":"References","text":"<ul> <li>CArray.h</li> <li>new_delete.cpp</li> <li>template.cpp</li> <li>dynamic_arr_class.cpp</li> </ul>"},{"location":"AR250407/","title":"Dynamic Memory Management and Template Usage","text":""},{"location":"AR250407/#date-2025-04-07","title":"Date: 2025-04-07","text":""},{"location":"AR250407/#key-points","title":"Key Points","text":"<ul> <li>The <code>new</code> operator is used for dynamic memory allocation in C++, replacing C's <code>malloc</code>.</li> <li>Dynamic allocation using <code>new</code> calls constructors and <code>delete</code> calls destructors automatically.</li> <li>Templates enable type-safe dynamic memory management.</li> <li>The Rule of Three/Five: Define destructors, copy constructors, and assignment operators for resource management.</li> <li>Using <code>assert</code> in C++ helps verify conditions during debugging.</li> </ul>"},{"location":"AR250407/#overview","title":"Overview","text":"<p>C++ offers powerful ways to manage dynamic memory using <code>new</code> and <code>delete</code> operators. These operators manage memory on the heap, which is essential for objects that need to persist beyond their scope or be shared between different parts of the program. Along with dynamic memory, C++ supports templates, which allow you to create generic classes and functions that work with any data type.</p> <p>Dynamic memory allocation and deallocation are central concepts in C++, and understanding these is crucial for managing resources efficiently. This section will also explore containers like <code>vector</code> and <code>list</code> for handling collections of data.</p>"},{"location":"AR250407/#c-dynamic-memory-management","title":"C++ Dynamic Memory Management","text":""},{"location":"AR250407/#basic-dynamic-allocation","title":"Basic Dynamic Allocation","text":"<p>In C++, dynamic memory is allocated using the <code>new</code> keyword, which initializes objects and arrays on the heap. Unlike the <code>malloc</code> function in C, <code>new</code> calls constructors and handles memory initialization automatically.</p> <pre><code>// Allocating a single object dynamically using new\nMyClass* pNewMy = new MyClass;\n\n// Deallocating memory using delete\ndelete pNewMy;\n\n// Allocating an array dynamically\nMyClass* pMyArr = new MyClass[10];\n\n// Deallocating an array using delete[]\ndelete[] pMyArr;\n</code></pre> <p>Important note: When you use <code>delete[]</code>, make sure to use the <code>[]</code> as this ensures the array destructor is called properly.</p>"},{"location":"AR250407/#templates-in-c-carray-example","title":"Templates in C++: <code>CArray</code> Example","text":"<p>Templates in C++ allow you to define classes and functions that can operate on any data type. For instance, <code>CArray</code> is a custom container that mimics the behavior of a vector:</p> <pre><code>template &lt;typename T&gt;\nvoid CArray&lt;T&gt;::push_back(const T&amp; _Data) {\n    // Adds an element to the array (implementation not shown here)\n}\n</code></pre> <p>Template Constructors:</p> <p>The constructor for a template class (e.g., <code>CArray&lt;t&gt;::CArray()</code>) initializes the object. This is useful for creating data structures that can handle any type of data.</p>"},{"location":"AR250407/#common-mistakes","title":"Common Mistakes","text":""},{"location":"AR250407/#1-mismatched-memory-management","title":"1. Mismatched Memory Management","text":"<p>When working with dynamic memory allocation, matching <code>new</code> with <code>delete</code> is essential. Failing to do so can lead to memory leaks or undefined behavior.</p> <pre><code>// Correct way to allocate and deallocate dynamically\nMyClass* pMy = new MyClass;\ndelete pMy;\n\n// Incorrect: Forgetting delete[] for arrays\nMyClass* pArr = new MyClass[10];\ndelete pArr;  // Error: should be delete[] for arrays\n</code></pre>"},{"location":"AR250407/#2-template-function-duplication","title":"2. Template Function Duplication","text":"<p>Ensure that template functions are correctly specialized or instantiated. Duplicate definitions across files can cause link errors.</p> <pre><code>// Duplicate definition of a template function\nint Add(int a, int b);  // Declaration\nint Add(int a, int b);  // This should cause a link error if defined twice\n</code></pre>"},{"location":"AR250407/#3-use-of-assert","title":"3. Use of <code>assert</code>","text":"<p>The <code>assert</code> macro is used for debugging purposes, ensuring conditions hold true during runtime.</p> <pre><code>#include &lt;cassert&gt;\n\nassert(m_CurSize &gt; _idx);  // Check that the index is valid\n\n// Example of assert behavior\nassert(nullptr);  // This will prompt a failure during debugging\n</code></pre>"},{"location":"AR250407/#working-with-containers-vector-vs-list","title":"Working with Containers: <code>vector</code> vs <code>list</code>","text":""},{"location":"AR250407/#vector","title":"<code>vector</code>","text":"<p>A vector is a dynamic array that allows fast indexing but slower insertions/deletions in the middle of the collection. Its size can be dynamically adjusted, and elements can be accessed quickly.</p> <pre><code>std::vector&lt;int&gt; vecInt;\nvecInt.push_back(10);\nvecInt.push_back(20);\nvecInt.push_back(30);\n\n// Accessing elements\nint first = vecInt[0];  // O(1) access time\n</code></pre> <p>Capacity and Resizing:</p> <ul> <li><code>reserve()</code>: Pre-allocates memory to avoid frequent reallocation.</li> <li><code>resize()</code>: Adjusts the current size and fills with default values.</li> </ul>"},{"location":"AR250407/#list","title":"<code>list</code>","text":"<p>A list is a doubly-linked list, which excels at insertion and deletion operations but suffers from slower access times compared to <code>vector</code>.</p> <pre><code>std::list&lt;int&gt; intList;\nintList.push_back(10);\nintList.push_back(20);\nintList.push_back(30);\n\n// Iterating through a list using an iterator\nfor (auto iter = intList.begin(); iter != intList.end(); ++iter) {\n    // Do something with *iter\n}\n</code></pre>"},{"location":"AR250407/#why-list-is-better-for-certain-use-cases","title":"Why <code>list</code> is Better for Certain Use Cases","text":"<ul> <li>Insertion and Deletion: <code>list</code> is better when you frequently insert or remove elements in the middle.</li> <li>Accessing by Index: For indexed access, <code>vector</code> is more efficient.</li> </ul>"},{"location":"AR250407/#interview-questions","title":"Interview Questions","text":"<p>Q: What is the difference between <code>new</code> and <code>malloc</code>? A: <code>new</code> in C++ calls the constructor of the object being allocated, while <code>malloc</code> simply allocates memory without initializing it. <code>new</code> also throws exceptions in case of failure, while <code>malloc</code> returns <code>nullptr</code>.</p> <p>Q: Why use <code>delete[]</code> instead of <code>delete</code> when deallocating arrays? A: <code>delete[]</code> ensures that the destructors for each element of the array are called properly, while <code>delete</code> only calls the destructor for the first element.</p>"},{"location":"AR250407/#tricky-case-using-template-with-custom-containers","title":"Tricky Case: Using <code>template</code> with Custom Containers","text":"<pre><code>// Template container example (simplified)\ntemplate &lt;typename T&gt;\nclass CArray {\n    T* m_data;\n    size_t m_Capacity;\n\npublic:\n    CArray(size_t capacity = 10) : m_Capacity(capacity) {\n        m_data = new T[m_Capacity];\n    }\n\n    ~CArray() {\n        delete[] m_data;\n    }\n\n    void push_back(const T&amp; _Data);\n};\n</code></pre> <p>Note: When using templates, ensure that memory management is done properly, especially when handling raw pointers and dynamic arrays inside a template class.</p>"},{"location":"AR250407/#code-demonstration","title":"Code Demonstration","text":"<pre><code>int* pArr = new int[5];  // Dynamically allocate an array\n\n// Fill the array\nfor (int i = 0; i &lt; 5; ++i) {\n    pArr[i] = i * 10;\n}\n\n// Output array\nfor (int i = 0; i &lt; 5; ++i) {\n    std::cout &lt;&lt; pArr[i] &lt;&lt; \" \";\n}\n\n// Deallocate memory\ndelete[] pArr;\n</code></pre>"},{"location":"AR250407/#visual-ownership-transfer-with-new-and-delete","title":"Visual: Ownership Transfer with <code>new</code> and <code>delete</code>","text":"<pre><code>Before Deletion             After Deletion\n------------                -------------\nObject A                    Object A\n[data -&gt; 0x1234]            [data -&gt; nullptr]\n\nObject B                    Object B\n[data -&gt; nullptr]           [data -&gt; 0x1234]\n</code></pre>"},{"location":"AR250407/#references","title":"References","text":"<ul> <li>CArray.h</li> <li>new_delete.cpp</li> <li>vector_usage.cpp</li> <li>class_template.cpp</li> </ul>"},{"location":"AR250408/","title":"STL Vector and Iterator Behavior","text":""},{"location":"AR250408/#date-2025-04-08","title":"Date: 2025-04-08","text":""},{"location":"AR250408/#key-points","title":"Key Points","text":"<ul> <li><code>std::vector</code> uses dynamic arrays and supports efficient back operations.</li> <li><code>std::vector::resize()</code> changes the size and may allocate/fill memory.</li> <li>Avoid using invalidated iterators after operations like <code>erase()</code> or <code>pop_back()</code>.</li> <li><code>std::list</code> supports efficient front and middle operations, unlike <code>vector</code>.</li> <li>STL iterators become invalid after erasure; always update them after modifying the container.</li> </ul>"},{"location":"AR250408/#overview","title":"Overview","text":"<p>This example focuses on the behavior of STL containers like <code>std::vector</code> and <code>std::list</code>, especially regarding memory allocation, iterator usage, and best practices. Additionally, it compares a custom container (<code>CArray</code>) with similar STL behavior, emphasizing safe iterator usage and container manipulation.</p> <pre><code>vector&lt;int&gt; vecInt;\nvecInt.resize(2000); // Allocates memory for 2000 elements and initializes them\n\nvecInt.push_back(10);\nvecInt.push_back(20);\nvecInt.push_back(30);\nvecInt.push_back(40);\nvecInt.push_back(50);\n\nvecInt.clear(); // Removes all elements\n\n{\n    vector&lt;int&gt; vecTemp;\n    vecTemp = vecInt; // Copy assignment\n    vecInt.swap(vecTemp); // Efficient way to reset or exchange contents\n}\n\nint Size = vecInt.size();\nint Cap = vecInt.capacity();\n</code></pre>"},{"location":"AR250408/#common-mistakes","title":"Common Mistakes","text":"<p>Accessing end() or invalid iterators <pre><code>vector&lt;int&gt; vecInt = {1, 2, 3, 4};\nauto iter = vecInt.begin();\niter += 4; // Dangerous: equal to end()\n// ++iter; // Error: out-of-bounds\n</code></pre></p> <p>Erasing while iterating improperly <pre><code>list&lt;int&gt; intList = {1, 2, 3, 4};\nauto it = intList.begin();\nintList.erase(it); // 'it' is now invalid\n// int value = *it; // Undefined behavior\n</code></pre></p> <p>Using <code>erase()</code> in loops incorrectly <pre><code>for (auto it = intList.begin(); it != intList.end();) {\n    if (*it &lt;= 60) {\n        it = intList.erase(it); // Returns valid next iterator\n    } else {\n        ++it;\n    }\n}\n</code></pre></p>"},{"location":"AR250408/#tricky-case-begin-end","title":"Tricky Case: <code>begin() == end()</code>","text":"<p>When a container is empty, calling <code>begin()</code> returns the same as <code>end()</code>. Using such an iterator must be guarded.</p> <pre><code>vector&lt;int&gt; vecInt;\nauto iter = vecInt.begin();\nif (iter == vecInt.end()) {\n    // Safe: container is empty\n}\n</code></pre> <p>The same applies to custom containers like <code>CArray</code>.</p> <pre><code>CArray&lt;int&gt; arrInt;\nauto it = arrInt.begin();\nif (it == arrInt.end()) {\n    // Safe check\n}\n</code></pre>"},{"location":"AR250408/#interview-questions","title":"Interview Questions","text":"<p>Q: What happens to an iterator after <code>erase()</code> in STL containers? A: It becomes invalid. Always update the iterator with the return value of <code>erase()</code>.</p> <p>Q: Why doesn't <code>std::vector</code> provide <code>pop_front()</code>? A: Because <code>std::vector</code> is optimized for fast back operations; front operations are inefficient due to shifting elements.</p> <p>Q: What's the difference between <code>resize()</code> and <code>reserve()</code> in <code>vector</code>? A: <code>resize()</code> changes the actual size and fills with default values. <code>reserve()</code> only allocates memory without changing the size.</p> <p>Q: How can you safely erase multiple elements in a loop? A: Use the return value of <code>erase()</code> to continue iteration.</p>"},{"location":"AR250408/#modern-examples","title":"Modern Examples","text":"<pre><code>// Using C++11 range-based loops\nvector&lt;int&gt; data = {1, 2, 3};\nfor (int val : data) {\n    cout &lt;&lt; val &lt;&lt; \" \";\n}\n</code></pre> <pre><code>// C++17 structured bindings (not directly used but relevant)\nauto [first, second] = pair&lt;int, int&gt;{1, 2};\n</code></pre>"},{"location":"AR250408/#code-demonstration","title":"Code Demonstration","text":"<pre><code>vector&lt;int&gt; vecInt = {1, 2, 3};\nfor (auto it = vecInt.begin(); it != vecInt.end(); ++it) {\n    cout &lt;&lt; *it &lt;&lt; endl;\n}\n\nCArray&lt;int&gt; arrInt;\narrInt.push_back(1);\narrInt.push_back(2);\narrInt.push_back(3);\n\nfor (auto it = arrInt.begin(); it != arrInt.end(); ++it) {\n    cout &lt;&lt; *it &lt;&lt; endl;\n}\n</code></pre>"},{"location":"AR250408/#visual-iterator-invalidation","title":"Visual: Iterator Invalidation","text":"<pre><code>Before erase()             After erase()\n-----------------          -----------------\n[10] [20] [30]             [20] [30]\n ^                        ^\n it                       invalid (do not use!)\n</code></pre>"},{"location":"AR250408/#references","title":"References","text":"<ul> <li>CArray.h</li> <li>vector_usage.cpp</li> <li>iterator.cpp</li> </ul>"},{"location":"AR250409/","title":"STL Vector vs List &amp; Custom Iterator Logic (with CArray)","text":""},{"location":"AR250409/#date-2025-04-09","title":"Date: 2025-04-09","text":"<p>This article explains in detail how a custom dynamic array (<code>CArray&lt;T&gt;</code>) and its iterator are implemented in C++. It covers why dynamic arrays like <code>std::vector</code> have certain limitations, how iterator invalidation works, and what patterns to follow when erasing elements during iteration.</p>"},{"location":"AR250409/#vector-vs-list-efficiency-and-design-tradeoffs","title":"Vector vs. List: Efficiency and Design Tradeoffs","text":""},{"location":"AR250409/#dynamic-array-vector","title":"Dynamic Array (Vector)","text":"<ul> <li>Vectors are built on dynamic arrays.</li> <li>Removing elements from the middle or front is inefficient because all the following elements must be shifted.</li> <li>Worst-case performance: <code>O(n)</code> when erasing from the front.</li> <li><code>pop_back()</code> is fast: <code>O(1)</code>.</li> <li><code>pop_front()</code> is not supported due to inefficiency.</li> </ul>"},{"location":"AR250409/#linked-list-list","title":"Linked List (List)","text":"<ul> <li>Lists use a node-based (linked list) structure.</li> <li><code>pop_front()</code> and <code>erase()</code> are efficient: constant-time operations.</li> <li>Cannot use random access with <code>[index]</code> or <code>.at()</code>.</li> <li>Iterators are used to access elements.</li> </ul>"},{"location":"AR250409/#stl-usage-examples","title":"STL Usage Examples","text":""},{"location":"AR250409/#vector-erase","title":"Vector Erase:","text":"<pre><code>std::vector&lt;int&gt; vecInt = {10, 20, 30};\nauto iter = vecInt.begin();\nvecInt.erase(iter); // Removes first element\n</code></pre>"},{"location":"AR250409/#list-erase","title":"List Erase:","text":"<pre><code>std::list&lt;int&gt; intList = {10, 20, 30};\nauto Liter = intList.begin();\nintList.erase(Liter); // Removes first element\n</code></pre>"},{"location":"AR250409/#iterator-invalidation","title":"Iterator Invalidation","text":"<ul> <li>After calling <code>erase()</code>, the passed iterator becomes invalid.</li> <li>Accessing <code>*iter</code> after erasure is undefined behavior.</li> <li>Iterators must not be incremented past <code>.end()</code>.</li> </ul>"},{"location":"AR250409/#safe-erase-pattern-in-loops","title":"Safe Erase Pattern in Loops","text":"<pre><code>for (auto iter = list.begin(); iter != list.end(); ) {\n    if (*iter &lt; 60)\n        iter = list.erase(iter); // safe\n    else\n        ++iter; // only if not erased\n}\n</code></pre>"},{"location":"AR250409/#tricky-erase-patterns-bad-vs-good","title":"Tricky Erase Patterns (Bad vs. Good)","text":""},{"location":"AR250409/#bad-pattern","title":"Bad Pattern","text":"<pre><code>for (auto it = vec.begin(); it != vec.end(); ++it) {\n    if (*it % 2 == 0)\n        vec.erase(it); // WRONG: iterator becomes invalid\n}\n</code></pre>"},{"location":"AR250409/#good-pattern","title":"Good Pattern","text":"<pre><code>for (auto it = vec.begin(); it != vec.end(); ) {\n    if (*it % 2 == 0)\n        it = vec.erase(it); // erase returns next iterator\n    else\n        ++it;\n}\n</code></pre>"},{"location":"AR250409/#custom-carray-iterator-internals","title":"Custom CArray Iterator Internals","text":""},{"location":"AR250409/#iterator-class-fields","title":"Iterator Class Fields:","text":"<ul> <li><code>m_Owner</code>: pointer to the parent container.</li> <li><code>m_Idx</code>: index currently pointed to. <code>-1</code> means end.</li> </ul>"},{"location":"AR250409/#special-iterator-states","title":"Special Iterator States:","text":"<ul> <li><code>(nullptr, -1)</code> = points to nothing.</li> <li><code>(_, -1)</code> = valid <code>end()</code> iterator.</li> </ul>"},{"location":"AR250409/#iterator-constructor","title":"Iterator Constructor","text":"<pre><code>iterator() : m_Owner(nullptr), m_Idx(-1) {}\niterator(CArray&lt;T&gt;* owner, int idx) : m_Owner(owner), m_Idx(idx) {}\n</code></pre>"},{"location":"AR250409/#begin-and-end-return","title":"begin() and end() Return","text":"<pre><code>iterator begin() {\n    return (m_CurSize == 0) ? end() : iterator(this, 0);\n}\n\niterator end() {\n    return iterator(this, -1);\n}\n</code></pre>"},{"location":"AR250409/#iterator-operators","title":"Iterator Operators","text":"<pre><code>T&amp; operator*(); // dereference\n\niterator&amp; operator++();     // prefix ++\niterator operator++(int);   // postfix ++\n\niterator&amp; operator--();     // prefix --\niterator operator--(int);   // postfix --\n\nbool operator==(const iterator&amp;);\nbool operator!=(const iterator&amp;);\n</code></pre>"},{"location":"AR250409/#custom-erase-implementation","title":"Custom erase() Implementation","text":"<pre><code>iterator CArray&lt;T&gt;::erase(iterator&amp; _TargetIter) {\n    assert(this == _TargetIter.m_Owner);\n    assert(_TargetIter.m_Idx &lt; m_CurSize);\n    assert(_TargetIter.m_Idx != -1);\n\n    iterator nextIter(this, _TargetIter.m_Idx);\n\n    int moveCount = m_CurSize - (_TargetIter.m_Idx + 1);\n    for (int i = 0; i &lt; moveCount; ++i)\n        m_Data[i + _TargetIter.m_Idx] = m_Data[i + _TargetIter.m_Idx + 1];\n\n    --m_CurSize;\n\n    _TargetIter.m_Owner = nullptr;\n    _TargetIter.m_Idx = -1;\n\n    return nextIter;\n}\n</code></pre>"},{"location":"AR250409/#common-mistakes","title":"Common Mistakes","text":"<ul> <li>Calling <code>++</code> on <code>end()</code> iterator  triggers <code>assert</code>.</li> <li>Dereferencing erased/invalid iterator  undefined behavior.</li> <li>Using <code>erase()</code> inside a <code>for</code> loop incorrectly.</li> </ul>"},{"location":"AR250409/#sample-interview-questions","title":"Sample Interview Questions","text":""},{"location":"AR250409/#q1-what-happens-if-you-call-on-end-iterator","title":"Q1: What happens if you call <code>++</code> on <code>end()</code> iterator?","text":"<p>A: It triggers an <code>assert</code> because the iterator is in an invalid position. Incrementing past <code>.end()</code> is undefined.</p>"},{"location":"AR250409/#q2-why-is-pop_front-not-provided-for-stdvector","title":"Q2: Why is <code>pop_front()</code> not provided for <code>std::vector</code>?","text":"<p>A: Because it requires shifting all elements to the left, which is an O(n) operation. This breaks the efficiency guarantee of <code>O(1)</code> random access.</p>"},{"location":"AR250409/#q3-how-can-you-safely-remove-elements-during-iteration","title":"Q3: How can you safely remove elements during iteration?","text":"<p>A: Use the erase-and-assign pattern: <pre><code>iter = container.erase(iter);\n</code></pre> This ensures the iterator always points to the valid next element.</p>"},{"location":"AR250409/#q4-can-you-implement-a-const_iterator-version-of-this-carray","title":"Q4: Can you implement a const_iterator version of this CArray?","text":"<p>A: Yes. Define a similar class but mark all accessors <code>const</code>, and restrict mutation operations. Also implement const overloads for <code>begin()</code> and <code>end()</code>.</p>"},{"location":"AR250409/#q5-when-does-stdvectorerase-invalidate-iterators","title":"Q5: When does <code>std::vector::erase()</code> invalidate iterators?","text":"<p>A: It invalidates the erased iterator and all that follow it.</p>"},{"location":"AR250409/#summary","title":"Summary","text":"<ul> <li><code>vector</code> is best for fast back insertions and random access.</li> <li><code>list</code> is best for frequent insertions/deletions from any position.</li> <li>Always be cautious with iterator invalidation, especially with <code>erase()</code>.</li> <li>Custom iterators must carefully handle edge cases (begin, end, invalid states).</li> <li>Understanding iterator behavior is crucial for bug-free, high-performance code.</li> </ul>"},{"location":"AR250409/#references","title":"References","text":"<ul> <li>CArray.h</li> <li>vector_usage.cpp</li> <li>iterator2.cpp</li> <li>CArray_iterator.cpp</li> </ul>"},{"location":"AR250410/","title":"Doubly Linked List and Iterator Design","text":""},{"location":"AR250410/#iterator-basics-and-usage","title":"Iterator Basics and Usage","text":"<pre><code>CArray&lt;int&gt;::iterator arrIter = arrInt.begin();\n\n*(arrIter++);     // Postfix\n*(++arrIter);     // Prefix\n</code></pre>"},{"location":"AR250410/#prefix-vs-postfix-operator","title":"Prefix vs Postfix Operator++","text":"<ul> <li>Always prefer prefix (<code>++iter</code>) over postfix (<code>iter++</code>) in loops.</li> <li><code>++iter</code> avoids the creation of a temporary copy.</li> <li><code>iter++</code> needs to save the original value, return it, then increment the iterator.</li> </ul>"},{"location":"AR250410/#correct-return-types-for-operator","title":"Correct Return Types for Operator++","text":"<p><pre><code>iterator&amp; operator++();        // Prefix\niterator operator++(int);     // Postfix\n</code></pre> - Return <code>iterator&amp;</code> for prefix (faster, no temporary). - Return <code>iterator</code> (by value) for postfix.</p>"},{"location":"AR250410/#clist-template-and-linked-list-design","title":"CList Template and Linked List Design","text":""},{"location":"AR250410/#node-structure","title":"Node Structure","text":"<pre><code>template&lt;typename T&gt;\nstruct tNode {\n    T m_Data;\n    tNode* m_Next;\n    tNode* m_Prev;\n\n    tNode() : m_Data(), m_Next(nullptr), m_Prev(nullptr) {}\n    tNode(const T&amp; _Data, tNode* _Next = nullptr, tNode* _Prev = nullptr)\n        : m_Data(_Data), m_Next(_Next), m_Prev(_Prev) {}\n};\n</code></pre>"},{"location":"AR250410/#clist-class-structure","title":"CList Class Structure","text":"<pre><code>template&lt;typename T&gt;\nclass CList {\nprivate:\n    tNode&lt;T&gt;* m_Head;\n    tNode&lt;T&gt;* m_Tail;\n    int       m_Size;\n\npublic:\n    void push_back(const T&amp; _Data);\n    void push_front(const T&amp; _Data);\n    void pop_front();\n    void pop_back();\n    void clear();\n    T&amp; front();\n    T&amp; back();\n\n    class iterator;\n    iterator begin();\n    iterator end();\n    iterator erase(iterator&amp; _iter);\n};\n</code></pre>"},{"location":"AR250410/#time-complexity","title":"Time Complexity","text":"<ul> <li><code>push_back</code>, <code>push_front</code>: O(1) (thanks to <code>m_Tail</code> and <code>m_Head</code>).</li> <li>Without <code>m_Tail</code>, <code>push_back</code> would be O(n).</li> </ul>"},{"location":"AR250410/#push_back","title":"push_back()","text":"<ul> <li>If empty, initialize <code>m_Head</code> and <code>m_Tail</code>.</li> <li>Otherwise, link new node to current <code>m_Tail</code>, then update <code>m_Tail</code>.</li> </ul>"},{"location":"AR250410/#push_front","title":"push_front()","text":"<ul> <li>Create new node, make current head its next.</li> <li>Update <code>m_Head</code>.</li> <li>If list was non-empty, update old head's previous pointer.</li> </ul>"},{"location":"AR250410/#pop_front","title":"pop_front()","text":"<ul> <li>Assert not empty.</li> <li>If only one node, also reset <code>m_Tail</code>.</li> <li>Delete current <code>m_Head</code>, move to next node.</li> </ul>"},{"location":"AR250410/#pop_back","title":"pop_back()","text":"<ul> <li>If only one node, reuse <code>pop_front()</code>.</li> <li>Update <code>m_Tail</code> to previous node.</li> <li>Delete old tail.</li> </ul>"},{"location":"AR250410/#iterator-internals","title":"Iterator Internals","text":"<pre><code>class iterator {\nprivate:\n    CList&lt;T&gt;* m_Owner;\n    tNode&lt;T&gt;* m_TargetNode;\n\n    // m_Owner == nullptr &amp;&amp; m_TargetNode == nullptr: invalid\n    // m_Owner != nullptr &amp;&amp; m_TargetNode == nullptr: end()\n\npublic:\n    // Comparison\n    bool operator==(const iterator&amp; _Other);\n    bool operator!=(const iterator&amp; _Other);\n\n    // Dereference\n    T&amp; operator*();\n\n    // Increment\n    iterator&amp; operator++();       // Prefix\n    iterator operator++(int);     // Postfix\n\n    // Decrement\n    iterator&amp; operator--();       // Prefix\n    iterator operator--(int);     // Postfix\n};\n</code></pre>"},{"location":"AR250410/#iterator-behavior-notes","title":"Iterator Behavior Notes","text":"<ul> <li><code>++</code> should <code>assert(m_TargetNode)</code> because <code>nullptr</code> can't be incremented.</li> <li><code>--</code> can handle <code>end()</code> case by setting to <code>m_Tail</code>.</li> <li>If <code>--</code> called on <code>begin()</code>, assert.</li> <li>Be cautious with invalid iterators.</li> </ul>"},{"location":"AR250410/#erase-behavior","title":"Erase Behavior","text":"<pre><code>template&lt;typename T&gt;\ntypename CList&lt;T&gt;::iterator CList&lt;T&gt;::erase(iterator&amp; _iter)\n</code></pre>"},{"location":"AR250410/#important-conditions","title":"Important Conditions:","text":"<ul> <li>Must check <code>m_Owner == this</code> using <code>assert</code>.</li> <li>Return the iterator pointing to the next element.</li> </ul>"},{"location":"AR250410/#edge-cases","title":"Edge Cases:","text":"<ul> <li>If <code>m_Head == _iter.m_TargetNode</code> =&gt; use <code>pop_front()</code>.</li> <li>If <code>m_Tail == _iter.m_TargetNode</code> =&gt; use <code>pop_back()</code>.</li> <li>Otherwise, handle using <code>m_Prev</code> and <code>m_Next</code> rewiring.</li> </ul>"},{"location":"AR250410/#reverse-function-recursive","title":"Reverse Function (Recursive)","text":"<ul> <li>Uses recursion to reach last node, then flips <code>m_Next</code> and <code>m_Prev</code>.</li> <li>Once base case (<code>nullptr</code>) hit, swap <code>m_Head</code> and <code>m_Tail</code>.</li> </ul>"},{"location":"AR250410/#common-mistakes","title":"Common Mistakes","text":"<ul> <li>Forgetting to update <code>m_Size</code> after push/pop.</li> <li>Incorrect handling of <code>nullptr</code> for empty list.</li> <li>Using <code>iter++</code> in loops over lists instead of <code>++iter</code>.</li> <li>Not asserting valid iterator before dereferencing or incrementing.</li> </ul>"},{"location":"AR250410/#sample-interview-questions","title":"Sample Interview Questions","text":""},{"location":"AR250410/#q1-what-is-the-difference-between-iter-and-iter-in-a-custom-iterator-class","title":"Q1. What is the difference between <code>++iter</code> and <code>iter++</code> in a custom iterator class?","text":"<p>A: - <code>++iter</code> is a prefix operator: it modifies and returns the same object (usually more efficient). - <code>iter++</code> is a postfix operator: it returns the value before incrementing, requiring a temporary copy.</p>"},{"location":"AR250410/#q2-when-does-clisteraseiterator-_iter-call-pop_front-or-pop_back","title":"Q2. When does <code>CList::erase(iterator&amp; _iter)</code> call <code>pop_front()</code> or <code>pop_back()</code>?","text":"<p>A: - If <code>_iter</code> points to <code>m_Head</code>, it calls <code>pop_front()</code>. - If <code>_iter</code> points to <code>m_Tail</code>, it calls <code>pop_back()</code>. - These are special edge cases that must be handled explicitly.</p>"},{"location":"AR250410/#q3-in-the-context-of-a-doubly-linked-list-what-makes-push_back-and-push_front-o1","title":"Q3. In the context of a doubly linked list, what makes <code>push_back</code> and <code>push_front</code> O(1)?","text":"<p>A: - The class stores both <code>m_Head</code> and <code>m_Tail</code>, allowing instant access to both ends without traversal.</p>"},{"location":"AR250410/#q4-what-does-an-end-iterator-mean-in-a-list","title":"Q4. What does an end iterator mean in a list?","text":"<p>A: - <code>m_TargetNode == nullptr</code>, but <code>m_Owner != nullptr</code>. It signifies one-past-the-last element.</p>"},{"location":"AR250410/#q5-why-is-it-necessary-to-check-m_owner-in-clisterase","title":"Q5. Why is it necessary to check <code>m_Owner</code> in <code>CList::erase()</code>?","text":"<p>A: - To ensure the iterator passed belongs to the current list. Otherwise, modifying foreign memory could cause undefined behavior.</p>"},{"location":"AR250410/#references","title":"References","text":"<ul> <li>linked_list_template.cpp</li> <li>[CList.h] (codes/CList.h)</li> </ul>"},{"location":"AR250411/","title":"Notes on Iterators and Linked List Implementation","text":""},{"location":"AR250411/#iterator-design-and-behavior","title":"Iterator Design and Behavior","text":""},{"location":"AR250411/#prefix-vs-postfix-operators","title":"Prefix vs Postfix Operators","text":"<ul> <li>Use <code>++iter</code> instead of <code>iter++</code> for performance:</li> <li>Prefix does not require a temporary copy.</li> <li>Postfix creates a copy before incrementing, which is slower in tight loops.</li> </ul> <pre><code>iterator&amp; operator++() { /* Prefix */ }\niterator operator++(int) { /* Postfix */ }\n</code></pre> <ul> <li>Similar pattern applies for <code>--iter</code> and <code>iter--</code>.</li> </ul>"},{"location":"AR250411/#why-return-iterator-instead-of-void","title":"Why Return Iterator Instead of Void?","text":"<ul> <li>Return type must be <code>iterator&amp;</code> for prefix, and <code>iterator</code> (by value) for postfix.</li> <li>This allows usage like <code>int value = *(++iter);</code>.</li> </ul> <pre><code>iterator&amp; operator++();           // Prefix\niterator operator++(int);         // Postfix (must return copy)\n</code></pre>"},{"location":"AR250411/#clist-internals-and-iterator-logic","title":"CList Internals and Iterator Logic","text":""},{"location":"AR250411/#default-constructors","title":"Default Constructors","text":"<ul> <li>Default constructor initializes pointers to <code>nullptr</code>, and value to default-initialized <code>T</code>.</li> </ul> <pre><code>tNode()\n  : m_Data(), m_Next(nullptr), m_Prev(nullptr) {}\n</code></pre>"},{"location":"AR250411/#list-operations","title":"List Operations","text":""},{"location":"AR250411/#push_back-and-push_front","title":"<code>push_back()</code> and <code>push_front()</code>","text":"<ul> <li>O(1) with head and tail pointers.</li> <li>If list is empty:</li> <li>Set both <code>m_Head</code> and <code>m_Tail</code> to new node.</li> <li>When inserting at head:</li> <li>Connect new node to current head.</li> <li>Update old head's prev.</li> <li>When inserting at tail:</li> <li>Connect current tail to new node.</li> <li>Update tail pointer.</li> </ul>"},{"location":"AR250411/#pop_front-and-pop_back","title":"<code>pop_front()</code> and <code>pop_back()</code>","text":"<ul> <li>Remove node and update adjacent pointers.</li> <li>Be careful with one-element list: update both head and tail.</li> </ul>"},{"location":"AR250411/#reverse-list","title":"Reverse List","text":"<ul> <li>Recursive reversal swaps next and prev pointers.</li> <li>Base case is when node is <code>nullptr</code> or last node.</li> </ul>"},{"location":"AR250411/#eraseiterator","title":"<code>erase(iterator&amp;)</code>","text":"<ul> <li>Handles three cases:</li> <li>Node is head: call <code>pop_front()</code></li> <li>Node is tail: call <code>pop_back()</code></li> <li>Node is in the middle:<ul> <li>Connect previous and next nodes together.</li> <li>Delete the target node.</li> </ul> </li> <li>Asserts that iterator's owner matches the current list.</li> </ul> <pre><code>assert(_iter.m_Owner == this);\n</code></pre>"},{"location":"AR250411/#iterator-states","title":"Iterator States","text":"<ul> <li><code>m_Owner == nullptr &amp;&amp; m_TargetNode == nullptr</code> : Invalid iterator</li> <li><code>m_Owner != nullptr &amp;&amp; m_TargetNode == nullptr</code> : End iterator</li> <li>End iterator should not be incremented.</li> </ul>"},{"location":"AR250411/#prefix-postfix-operator-for-list","title":"Prefix/ Postfix -- Operator for List","text":"<pre><code>iterator&amp; operator--()\n{\n  assert(m_Owner-&gt;m_Head != m_TargetNode);\n  if (nullptr == m_TargetNode)\n    m_TargetNode = m_Owner-&gt;m_Tail;\n  else\n    m_TargetNode = m_TargetNode-&gt;m_Prev;\n  return *this;\n}\n</code></pre>"},{"location":"AR250411/#common-mistakes-and-tricky-cases","title":"Common Mistakes and Tricky Cases","text":""},{"location":"AR250411/#mistake-postfix-operator-returning-reference","title":"Mistake: Postfix Operator Returning Reference","text":"<ul> <li><code>operator++(int)</code> must return a copy, not a reference.</li> <li>Otherwise, the reference to a local copy goes out of scope.</li> </ul>"},{"location":"AR250411/#mistake-iterator-to-wrong-container","title":"Mistake: Iterator to Wrong Container","text":"<ul> <li>Ensure iterator belongs to the same list before erase.</li> <li>Use <code>assert(iter.m_Owner == this)</code> to prevent undefined behavior.</li> </ul>"},{"location":"AR250411/#tricky-case-called-on-begin","title":"Tricky Case: -- Called on <code>begin()</code>","text":"<ul> <li><code>--begin()</code> is undefined; assert if <code>m_Head == m_TargetNode</code>.</li> </ul>"},{"location":"AR250411/#tricky-case-called-on-end","title":"Tricky Case: ++ Called on <code>end()</code>","text":"<ul> <li><code>++end()</code> is undefined; assert if <code>m_TargetNode == nullptr</code>.</li> </ul>"},{"location":"AR250411/#sample-interview-questions","title":"Sample Interview Questions","text":""},{"location":"AR250411/#q1-what-is-the-time-complexity-of-push_back-in-a-doubly-linked-list-with-tail-pointer","title":"Q1: What is the time complexity of push_back in a doubly linked list with tail pointer?","text":"<p>A: O(1), since we can directly access and update the tail.</p>"},{"location":"AR250411/#q2-what-is-the-difference-between-prefix-and-postfix-iterator-increment-operators","title":"Q2: What is the difference between prefix and postfix iterator increment operators?","text":"<p>A: - Prefix: modifies and returns the same iterator. - Postfix: returns a copy of the original before modification.</p>"},{"location":"AR250411/#q3-how-would-you-implement-the-erase-function-for-a-doubly-linked-list","title":"Q3: How would you implement the erase function for a doubly linked list?","text":"<p>A: - Validate iterator. - If at head or tail, call <code>pop_front()</code> or <code>pop_back()</code>. - Otherwise, update surrounding node pointers and delete the target node.</p>"},{"location":"AR250411/#q4-why-is-iter-preferred-over-iter-in-a-loop","title":"Q4: Why is ++iter preferred over iter++ in a loop?","text":"<p>A: <code>++iter</code> is faster because it doesn\u00a1\u00aft need to copy the iterator object.</p>"},{"location":"AR250411/#q5-what-does-an-end-iterator-represent","title":"Q5: What does an end() iterator represent?","text":"<p>A: An iterator pointing to <code>nullptr</code>, which comes after the last element in the container.</p>"},{"location":"AR250411/#assignments-summary-0411","title":"Assignments Summary (0411)","text":"<ul> <li>Implement <code>CArray::erase(iterator&amp;)</code> and <code>pop_back()</code>.</li> <li><code>erase()</code> should shift elements left.</li> <li><code>pop_back()</code> decreases size by one.</li> <li>Implement <code>CList::pop_back()</code>.</li> <li>Handle tricky iterator edge cases and owner validation.</li> </ul>"},{"location":"AR250411/#references","title":"References","text":"<ul> <li>linked_list_template.cpp</li> <li>[CList.h] (codes/CList.h)</li> </ul>"},{"location":"AR250414/","title":"Linked List: Reverse Function &amp; Notes Summary","text":""},{"location":"AR250414/#date-2025-04-14","title":"Date: 2025-04-14","text":""},{"location":"AR250414/#overview","title":"Overview","text":"<p>This document summarizes the key implementation and conceptual points of a Doubly Linked List (DLList), particularly focusing on the <code>reverse()</code> function, which was a Krafton coding test question. Additional system-level and algorithmic context related to data erasure, sorting, and data structures is also included.</p>"},{"location":"AR250414/#core-class-dllist","title":"Core Class: DLList","text":"<p>The <code>DLList</code> template manages a doubly linked list with forward and backward traversal. Each node (<code>tNode</code>) contains:</p> <ul> <li><code>T m_Data</code>: Stored data.</li> <li><code>tNode* m_Next</code>: Pointer to the next node.</li> <li><code>tNode* m_Prev</code>: Pointer to the previous node.</li> </ul>"},{"location":"AR250414/#important-members","title":"Important Members:","text":"<ul> <li><code>m_Head</code>: Points to the first node.</li> <li><code>m_Tail</code>: Points to the last node.</li> <li><code>m_Size</code>: Current size of the list.</li> </ul>"},{"location":"AR250414/#reverse-function-krafton-exam-focus","title":"Reverse Function (Krafton Exam Focus)","text":"<pre><code>void reverse() {\n    reverse(m_Head);\n}\n\nvoid reverse(tNode&lt;T&gt;* _Node) {\n    if (nullptr != _Node-&gt;m_Next) {\n        reverse(_Node-&gt;m_Next);\n    }\n\n    if (_Node-&gt;m_Next == nullptr) {\n        tNode&lt;T&gt;* pTemp = m_Head;\n        m_Head = m_Tail;\n        m_Tail = pTemp;\n    }\n\n    tNode&lt;T&gt;* pTemp = _Node-&gt;m_Next;\n    _Node-&gt;m_Next = _Node-&gt;m_Prev;\n    _Node-&gt;m_Prev = pTemp;\n}\n</code></pre>"},{"location":"AR250414/#key-points","title":"Key Points:","text":"<ul> <li>Recursive approach.</li> <li>Base case is the last node (<code>_Node-&gt;m_Next == nullptr</code>).</li> <li>Upon reaching the last node, <code>m_Head</code> and <code>m_Tail</code> are swapped.</li> <li>Pointers are reversed for every node recursively.</li> </ul>"},{"location":"AR250414/#technical-notes","title":"Technical Notes","text":""},{"location":"AR250414/#0-based-vs-1-based-data","title":"0-based vs 1-based data","text":"<ul> <li>Systems may index starting at 0 or 1. Pay attention in competitive programming and interviews.</li> </ul>"},{"location":"AR250414/#forensic-data-removal","title":"Forensic Data Removal","text":"<ul> <li>Header-only deletion means the actual data remains on disk.</li> <li>Overwriting with high-volume data ensures old content becomes unrecoverable.</li> </ul>"},{"location":"AR250414/#friend-class-usage","title":"<code>friend class</code> Usage","text":"<ul> <li>Enables mutual access between internal iterator classes and their containers.</li> <li>Example: <code>friend class DLList;</code> inside <code>iterator</code>.</li> </ul>"},{"location":"AR250414/#carray-context-erase-function-for-comparison","title":"CArray Context &amp; Erase Function (For Comparison)","text":"<pre><code>template&lt;typename T&gt;\ntypename CArray&lt;T&gt;::iterator CArray&lt;T&gt;::erase(iterator&amp; _TargetIter) {\n    assert(this == _TargetIter.m_Owner\n        &amp;&amp; _TargetIter.m_Idx &lt; m_CurSize\n        &amp;&amp; _TargetIter.m_Idx != -1);\n\n    iterator NextIter(this, _TargetIter.m_Idx);\n\n    int MoveCount = m_CurSize - (_TargetIter.m_Idx + 1);\n    for (int i = 0; i &lt; MoveCount; ++i) {\n        m_Data[_TargetIter.m_Idx + i] = m_Data[_TargetIter.m_Idx + i + 1];\n    }\n\n    return end();\n}\n</code></pre> <p>This shows how iterator logic and range assertions ensure safe array element erasure.</p>"},{"location":"AR250414/#additional-notes","title":"Additional Notes","text":""},{"location":"AR250414/#search-algorithms","title":"Search Algorithms:","text":"<ul> <li>Linear search: O(n)</li> <li>Binary search: O(log n) \u2013 requires sorted data</li> </ul>"},{"location":"AR250414/#graph-algorithms","title":"Graph Algorithms:","text":"<ul> <li>Handle data relationships.</li> <li>Useful for managing relational information (e.g., social networks, recommendation systems).</li> </ul>"},{"location":"AR250414/#sorting-algorithms","title":"Sorting Algorithms:","text":"<ul> <li>Stable sort: Maintains order of equal elements</li> <li>Unstable sort: Does not guarantee order</li> </ul>"},{"location":"AR250414/#trees","title":"Trees:","text":"<ul> <li>Represent layered structures like organizational charts or family trees.</li> <li>BSTs are optimized for fast searching.</li> </ul>"},{"location":"AR250414/#references","title":"References","text":"<ul> <li><code>linked_list_2.cpp</code></li> <li><code>BST1.cpp</code></li> <li><code>WeekendHW.cpp</code></li> </ul>"},{"location":"AR250414/#summary","title":"Summary","text":"<p>This document provides a clean breakdown of a double linked list reverse function (frequently tested in technical interviews), system-level data deletion insights, and supplementary algorithmic context including sorting, trees, and friend class access.</p> <p>Ready for next-level integration or implementation into custom containers or performance tests.</p>"},{"location":"AR250415/","title":"Tree Algorithms and Traversals","text":""},{"location":"AR250415/#date-2025-04-15","title":"Date: 2025-04-15","text":""},{"location":"AR250415/#key-points","title":"Key Points","text":"<ul> <li>Trees are hierarchical data structures with a single root node</li> <li>Binary trees have at most two children per node</li> <li>Tree variants include complete binary trees, perfect binary trees, and binary search trees</li> <li>Binary search trees (BSTs) maintain sorted order for efficient searching</li> <li>Tree traversal methods: pre-order, in-order, post-order, and level-order</li> <li>Heaps are complete binary trees with specific ordering properties</li> <li>Self-balancing trees like AVL and Red-Black trees maintain logarithmic performance</li> </ul>"},{"location":"AR250415/#tree-terminology-and-structure","title":"Tree Terminology and Structure","text":""},{"location":"AR250415/#basic-tree-concepts","title":"Basic Tree Concepts","text":"<p>Trees are hierarchical data structures consisting of nodes connected by edges. Unlike graphs, trees cannot contain cycles.</p> <p>Key terminology: - Root Node: The topmost node in a tree hierarchy (has no parent) - Leaf Node: Any node without children - Internal Node: A node with at least one child - Edge: Connection between two nodes - Depth: Length of the path from the root to a node - Height: Length of the longest path from a node to a leaf</p>"},{"location":"AR250415/#binary-trees","title":"Binary Trees","text":"<p>A binary tree is a tree where each node has at most two children, referred to as the left child and right child.</p> <pre><code>   A\n  / \\\n B   C\n/ \\ / \\\nD E F  G\n</code></pre>"},{"location":"AR250415/#complete-binary-tree-cbt","title":"Complete Binary Tree (CBT)","text":"<p>A complete binary tree fills levels from left to right before moving to the next level: - Nodes are added from left to right at each level - All levels except possibly the last are completely filled - The last level has all nodes as far left as possible</p> <pre><code>    1\n   / \\\n  2   3\n / \\\n4   5\n</code></pre>"},{"location":"AR250415/#perfect-binary-tree","title":"Perfect Binary Tree","text":"<p>A perfect binary tree is a complete binary tree where all levels are fully filled: - All internal nodes have exactly two children - All leaf nodes are at the same level</p> <pre><code>    1\n   / \\\n  2   3\n / \\ / \\\n4  5 6  7\n</code></pre> <p>Note: A perfect binary tree is a state or condition of a complete binary tree, not a separate structure.</p>"},{"location":"AR250415/#binary-search-trees-bst","title":"Binary Search Trees (BST)","text":"<p>A binary search tree is a binary tree with an ordering property: - For each node, all values in its left subtree are less than the node's value - For each node, all values in its right subtree are greater than the node's value</p> <pre><code>    8\n   / \\\n  3   10\n / \\    \\\n1   6    14\n   / \\   /\n  4   7 13\n</code></pre>"},{"location":"AR250415/#bst-operations-performance","title":"BST Operations Performance","text":"Operation Average Case Worst Case Insert O(log n) O(n) Delete O(log n) O(n) Search O(log n) O(n)"},{"location":"AR250415/#comparison-with-other-data-structures","title":"Comparison with Other Data Structures","text":"Structure Insert Indexing Delete Search Dynamic Array O(1) O(1) O(n) O(n) Linked List O(1) O(n) O(1) O(n) BST O(log n) O(n) O(log n) O(log n) <p>Note: The worst-case time complexity for BST operations becomes O(n) when the tree is unbalanced (e.g., when inserting sorted data).</p>"},{"location":"AR250415/#tree-traversal-methods","title":"Tree Traversal Methods","text":"<p>Tree traversal refers to the process of visiting each node in a tree data structure exactly once. The four main traversal methods are:</p>"},{"location":"AR250415/#1-pre-order-traversal-node-left-right","title":"1. Pre-Order Traversal (Node-Left-Right)","text":"<p>Algorithm: 1. Visit the current node 2. Recursively traverse the left subtree 3. Recursively traverse the right subtree</p> <p>Use cases: - Creating a copy of the tree - Getting prefix expression of an expression tree</p>"},{"location":"AR250415/#2-in-order-traversal-left-node-right","title":"2. In-Order Traversal (Left-Node-Right)","text":"<p>Algorithm: 1. Recursively traverse the left subtree 2. Visit the current node 3. Recursively traverse the right subtree</p> <p>Use cases: - BST traversal in sorted order - Infix expression evaluation</p>"},{"location":"AR250415/#3-post-order-traversal-left-right-node","title":"3. Post-Order Traversal (Left-Right-Node)","text":"<p>Algorithm: 1. Recursively traverse the left subtree 2. Recursively traverse the right subtree 3. Visit the current node</p> <p>Use cases: - Deleting or freeing nodes in a tree - Getting postfix expression of an expression tree</p>"},{"location":"AR250415/#4-level-order-traversal-breadth-first","title":"4. Level-Order Traversal (Breadth-First)","text":"<p>Algorithm: 1. Start at the root 2. Visit all nodes at the current level 3. Move to the next level</p> <p>Implementation typically uses a queue data structure.</p>"},{"location":"AR250415/#example-traversals","title":"Example Traversals","text":"<pre><code>Given the tree:\n    A\n   / \\\n  B   C\n / \\ / \nD  E F\n\nPre-Order:   A \u2192 B \u2192 D \u2192 E \u2192 C \u2192 F\nIn-Order:    D \u2192 B \u2192 E \u2192 A \u2192 F \u2192 C\nPost-Order:  D \u2192 E \u2192 B \u2192 F \u2192 C \u2192 A\nLevel-Order: A \u2192 B \u2192 C \u2192 D \u2192 E \u2192 F\n</code></pre>"},{"location":"AR250415/#heap-data-structures","title":"Heap Data Structures","text":"<p>A heap is a specialized tree-based data structure that satisfies the heap property:</p> <ul> <li>Min-Heap: For any node, the parent's value is less than or equal to its children's values</li> <li>Max-Heap: For any node, the parent's value is greater than or equal to its children's values</li> </ul> <p>Heaps are implemented as complete binary trees, which allows them to be efficiently represented using arrays:</p> <ul> <li>For a node at index <code>k</code>:</li> <li>Left child: <code>2k + 1</code></li> <li>Right child: <code>2k + 2</code></li> <li>Parent: <code>(k - 1) / 2</code></li> </ul> <p>Array representation of a max-heap: <pre><code>[10, 7, 9, 3, 2, 8, 1]\n\nVisualized as:\n     10\n    /  \\\n   7    9\n  / \\  / \\\n 3  2 8  1\n</code></pre></p>"},{"location":"AR250415/#heap-operations","title":"Heap Operations","text":"Operation Time Complexity Find Max/Min O(1) Insert O(log n) Extract Max/Min O(log n) Heapify O(n)"},{"location":"AR250415/#applications","title":"Applications","text":"<ol> <li>Heap Sort: An efficient sorting algorithm with O(n log n) time complexity</li> <li>Priority Queue: A data structure where the highest (or lowest) priority element is always removed first</li> </ol>"},{"location":"AR250415/#self-balancing-binary-search-trees","title":"Self-Balancing Binary Search Trees","text":"<p>When elements are inserted into a BST in sorted order, the tree can degenerate into a linked list, resulting in O(n) time complexity for operations instead of O(log n).</p> <p>Self-balancing BSTs automatically keep their height balanced after insertions and deletions:</p>"},{"location":"AR250415/#avl-trees","title":"AVL Trees","text":"<ul> <li>Named after inventors Adelson-Velsky and Landis</li> <li>Maintains the property that for every node, the heights of its left and right subtrees differ by at most 1</li> <li>Uses rotation operations to maintain balance</li> </ul>"},{"location":"AR250415/#red-black-trees","title":"Red-Black Trees","text":"<ul> <li>Each node is colored either red or black</li> <li>The root and leaves (NIL nodes) are black</li> <li>If a node is red, both its children are black</li> <li>All paths from a node to its NIL descendants contain the same number of black nodes</li> <li>Used in many standard library implementations (like <code>std::map</code> and <code>std::set</code>)</li> </ul>"},{"location":"AR250415/#comparison","title":"Comparison","text":"Tree Type Insert Delete Search Space Unbalanced BST O(n) O(n) O(n) O(n) AVL Tree O(log n) O(log n) O(log n) O(n) Red-Black Tree O(log n) O(log n) O(log n) O(n) <p>AVL trees maintain stricter balance than Red-Black trees, resulting in faster lookups but slower insertions and deletions due to more frequent rotations.</p>"},{"location":"AR250415/#c-standard-library-implementations","title":"C++ Standard Library Implementations","text":"<p>The C++ Standard Library includes several tree-based data structures:</p> <ul> <li><code>std::set</code>: A collection of unique keys, sorted by keys (typically implemented as a Red-Black Tree)</li> <li><code>std::map</code>: A collection of key-value pairs, sorted by keys (typically implemented as a Red-Black Tree)</li> <li><code>std::multiset</code>: A collection of keys, sorted by keys, allows duplicate keys</li> <li><code>std::multimap</code>: A collection of key-value pairs, sorted by keys, allows duplicate keys</li> </ul> <p>Example usage: <pre><code>std::set&lt;int&gt; setInt;\nsetInt.insert(1);\nsetInt.insert(5);\nsetInt.insert(3);\n\n// Iterating will access elements in sorted order (1, 3, 5)\nfor(std::set&lt;int&gt;::iterator setIter = setInt.begin(); \n    setIter != setInt.end(); \n    ++setIter)\n{\n    std::cout &lt;&lt; *setIter &lt;&lt; std::endl;\n}\n</code></pre></p>"},{"location":"AR250415/#interview-questions","title":"Interview Questions","text":"<p>Q: What is the difference between a complete binary tree and a perfect binary tree? A: A complete binary tree fills levels from left to right, with all levels except possibly the last completely filled, and the last level has nodes as far left as possible. A perfect binary tree is a complete binary tree where all levels are fully filled\u2014all internal nodes have exactly two children and all leaf nodes are at the same level.</p> <p>Q: In a binary search tree, how would you find the in-order successor of a given node? A: If the node has a right child, the in-order successor is the leftmost node in its right subtree. If it doesn't have a right child, the in-order successor is the lowest ancestor whose left child is also an ancestor of the given node.</p> <p>Q: What happens to a BST's performance if you insert elements in sorted order? A: If elements are inserted in sorted order (e.g., 1, 2, 3, 4, 5), the BST degenerates into a linked list, and the time complexity for operations becomes O(n) instead of O(log n). This is why self-balancing trees like AVL or Red-Black trees are important for maintaining logarithmic performance.</p> <p>Q: How is a heap different from a binary search tree? A: A heap is a complete binary tree that satisfies the heap property (parent values are greater/less than child values), optimized for finding min/max values quickly. A BST maintains left subtree values &lt; node value &lt; right subtree values, optimized for searching. Heaps are typically implemented using arrays, while BSTs use node structures with pointers.</p> <p>Q: Why might you choose a Red-Black tree over an AVL tree? A: Red-Black trees perform fewer rotations during insertion and deletion compared to AVL trees, making them more efficient for applications with frequent modifications. AVL trees maintain stricter balance, making them slightly better for read-heavy applications. Standard library containers like <code>std::map</code> and <code>std::set</code> typically use Red-Black trees for this reason.</p> <p>Q: What is the time complexity of each tree traversal method? A: All four traversal methods (pre-order, in-order, post-order, and level-order) have O(n) time complexity, where n is the number of nodes in the tree, as each node must be visited exactly once.</p> <p>Q: How would you implement level-order traversal of a binary tree? A: Level-order traversal can be implemented using a queue. Start by enqueuing the root node. Then, while the queue is not empty, dequeue a node, process it, and enqueue its children (if any). This process continues until the queue is empty.</p>"},{"location":"AR250415/#tree-algorithms-and-traversals_1","title":"Tree Algorithms and Traversals","text":""},{"location":"AR250415/#date-2025-04-15_1","title":"Date: 2025-04-15","text":""},{"location":"AR250415/#key-points_1","title":"Key Points","text":"<ul> <li>Trees are hierarchical data structures with a single root node</li> <li>Binary trees have at most two children per node</li> <li>Complete binary trees fill levels from left to right before proceeding to the next level</li> <li>Perfect binary trees are complete binary trees with all levels fully filled</li> <li>Binary search trees (BSTs) maintain sorted order for efficient searching</li> <li>Tree traversal methods include pre-order, in-order, post-order, and level-order</li> <li>Heaps are complete binary trees optimized for finding min/max values quickly</li> <li>Self-balancing trees prevent performance degradation</li> </ul>"},{"location":"AR250415/#tree-terminology-and-structure_1","title":"Tree Terminology and Structure","text":"<p>A tree is a hierarchical data structure consisting of nodes connected by edges. Unlike graphs, trees cannot contain cycles.</p>"},{"location":"AR250415/#basic-components","title":"Basic Components:","text":"<ul> <li>Root Node: The topmost node without any parent</li> <li>Leaf Node: Any node without children</li> <li>Internal Node: A node with at least one child</li> </ul> <p>In graph terminology, the highest node is referred to as a vertex, but in trees, the parentless top node is specifically called the root.</p>"},{"location":"AR250415/#binary-tree-types","title":"Binary Tree Types","text":"<p>A binary tree restricts each node to have at most two children. Several specialized forms exist:</p> <ul> <li>Complete Binary Tree (CBT): Nodes are filled from left to right at each level before moving down</li> <li>Perfect Binary Tree: A CBT where all levels are completely filled</li> </ul> <p>It's important to note that a perfect binary tree is a state of a complete binary tree, not a separate structure.</p>"},{"location":"AR250415/#binary-search-trees-bst_1","title":"Binary Search Trees (BST)","text":"<p>Binary search trees maintain a specific ordering property: - All values in a node's left subtree are less than the node's value - All values in a node's right subtree are greater than the node's value</p> <p>This property makes BSTs excellent for searching operations, as each comparison eliminates half of the remaining elements.</p>"},{"location":"AR250415/#performance-comparison","title":"Performance Comparison","text":"Structure Insert Indexing Delete Search Dynamic Array O(1) O(1) O(n) O(n) Linked List O(1) O(n) O(1) O(n) BST O(log n) O(n) O(log n) O(log n) <p>C++ Standard Library implementations: - <code>std::vector</code>: Dynamic array - <code>std::list</code>: Linked list - <code>std::set</code>, <code>std::map</code>: Binary search trees (typically Red-Black trees)</p>"},{"location":"AR250415/#tree-traversal-methods_1","title":"Tree Traversal Methods","text":"<p>The four main ways to traverse a tree are:</p>"},{"location":"AR250415/#1-pre-order-node-left-right","title":"1. Pre-Order (Node-Left-Right)","text":"<p>Visit the current node first, then traverse left subtree, then right subtree. Useful for creating a copy of the tree.</p>"},{"location":"AR250415/#2-in-order-left-node-right","title":"2. In-Order (Left-Node-Right)","text":"<p>Traverse left subtree, visit the current node, then traverse right subtree. For BSTs, this produces elements in sorted order.</p>"},{"location":"AR250415/#3-post-order-left-right-node","title":"3. Post-Order (Left-Right-Node)","text":"<p>Traverse left subtree, traverse right subtree, then visit the current node. Useful when deleting nodes or freeing memory.</p>"},{"location":"AR250415/#4-level-order-breadth-first","title":"4. Level-Order (Breadth-First)","text":"<p>Visit nodes level by level from top to bottom. Typically implemented using a queue.</p>"},{"location":"AR250415/#example","title":"Example","text":"<pre><code>Given the tree:\n    A\n   / \\\n  B   C\n / \\ / \nD  E F\n\nPre-Order:   A \u2192 B \u2192 D \u2192 E \u2192 C \u2192 F\nIn-Order:    D \u2192 B \u2192 E \u2192 A \u2192 F \u2192 C\nPost-Order:  D \u2192 E \u2192 B \u2192 F \u2192 C \u2192 A\nLevel-Order: A \u2192 B \u2192 C \u2192 D \u2192 E \u2192 F\n</code></pre>"},{"location":"AR250415/#heap-data-structures_1","title":"Heap Data Structures","text":"<p>Heaps are specialized complete binary trees that satisfy a specific property: - Min-heap: Parent values are less than or equal to child values - Max-heap: Parent values are greater than or equal to child values</p> <p>Heaps can be efficiently implemented using arrays, where for a node at index <code>k</code>: - Left child: <code>2k + 1</code> - Right child: <code>2k + 2</code> - Parent: <code>(k - 1) / 2</code></p> <p>This property allows heaps to be implemented without pointers, using array indexing instead.</p>"},{"location":"AR250415/#applications_1","title":"Applications","text":"<ul> <li>Heap Sort: An efficient O(n log n) sorting algorithm</li> <li>Priority Queue: Data structure where the highest priority element is always removed first</li> </ul>"},{"location":"AR250415/#self-balancing-binary-search-trees_1","title":"Self-Balancing Binary Search Trees","text":"<p>A major weakness of BSTs is that they can degenerate into linked lists if data is inserted in sorted order, reducing operation efficiency from O(log n) to O(n).</p> <p>Self-balancing trees address this issue:</p> <ul> <li>AVL Trees: Maintain strict balance where subtree heights differ by at most 1</li> <li>Red-Black Trees: Use color properties to maintain balance with fewer rotations</li> </ul> <p>Red-Black trees are commonly used in library implementations like <code>std::map</code> and <code>std::set</code> because they require fewer rotations than AVL trees, making them more efficient for insertions and deletions.</p>"},{"location":"AR250415/#interview-questions_1","title":"Interview Questions","text":"<p>Q: What is the difference between a complete binary tree and a perfect binary tree? A: A complete binary tree fills all levels from left to right before moving to the next level, with the last level potentially partially filled (but filled from left). A perfect binary tree is a complete binary tree where all levels are fully filled\u2014all internal nodes have exactly two children and all leaf nodes are at the same level.</p> <p>Q: How would you implement level-order traversal of a binary tree? A: Level-order traversal can be implemented using a queue. Start by enqueuing the root. While the queue isn't empty, dequeue a node, process it, and enqueue its children. This continues until the queue is empty.</p> <p>Q: What happens to a BST's performance if you insert elements in sorted order? A: If elements are inserted in sorted order (e.g., 1, 2, 3, 4, 5), the BST degenerates into a linked list, and the time complexity becomes O(n) instead of O(log n). This is why self-balancing trees are important for maintaining logarithmic performance.</p> <p>Q: How is a heap different from a binary search tree? A: A heap is a complete binary tree satisfying the heap property (parent values are greater/less than child values), optimized for finding min/max values quickly. A BST maintains left &lt; node &lt; right ordering for all nodes, optimized for searching. Heaps are typically implemented using arrays, while BSTs use node structures with pointers.</p> <p>Q: In a binary search tree, how would you find the in-order successor of a given node? A: If the node has a right child, the in-order successor is the leftmost node in its right subtree. If it doesn't have a right child, the in-order successor is the lowest ancestor whose left child is also an ancestor of the given node.</p> <p>Q: Why might you choose a Red-Black tree over an AVL tree? A: Red-Black trees perform fewer rotations during insertion and deletion compared to AVL trees, making them more efficient for applications with frequent modifications. AVL trees maintain stricter balance, making them slightly better for read-heavy applications.</p> <p>Q: Why is in-order traversal particularly important for binary search trees? A: In-order traversal of a BST visits nodes in sorted order (ascending). This property makes it useful for producing a sorted list of all elements in the tree and is why iterators in <code>std::set</code> and <code>std::map</code> follow in-order traversal.</p>"},{"location":"AR250416/","title":"Binary Search Tree: Study Guide","text":""},{"location":"AR250416/#date-2025-04-16","title":"Date: 2025-04-16","text":""},{"location":"AR250416/#overview","title":"Overview","text":"<p>A Binary Search Tree (BST) is a hierarchical structure that stores key-value pairs with strict ordering rules for efficient data manipulation. This guide walks through essential implementation elements, corner cases, and interview-related insights.</p>"},{"location":"AR250416/#bst-node-structure","title":"BST Node Structure","text":"<p>Each BST node includes: - A key-value pair used for storage and sorting. - Three pointers:   - <code>Parent</code> (index 0)   - <code>Left Child</code> (index 1)   - <code>Right Child</code> (index 2)</p> <pre><code>// Node structure for a BST\ntemplate&lt;typename T1, typename T2&gt;\nstruct Node {\n    Pair&lt;T1, T2&gt; pair;\n    Node* ptr[3];\n\n    Node() : pair(), ptr{nullptr, nullptr, nullptr} {}\n    Node(const Pair&lt;T1, T2&gt;&amp; _pair, Node* _Parent, Node* _LChild, Node* _RChild)\n        : pair(_pair), ptr{_Parent, _LChild, _RChild} {}\n};\n</code></pre>"},{"location":"AR250416/#bst-class-initialization","title":"BST Class &amp; Initialization","text":"<p>The BST class manages the root node and the size of the tree:</p> <pre><code>// BST class definition\ntemplate&lt;typename T1, typename T2&gt;\nclass BSTree {\nprivate:\n    Node&lt;T1, T2&gt;* m_Root;\n    int m_Size;\n\npublic:\n    BSTree() : m_Root(nullptr), m_Size(0) {}\n};\n</code></pre> <p><code>m_Root</code> must be declared inside the BST class to track the tree's entry point.</p> <p>In contrast, the Node structure includes: <pre><code>tBSTNode* pParent;\ntBSTNode* pLeftChild;\ntBSTNode* pRightChild;\n</code></pre> These pointers are naturally interpreted in context and ensure internal link integrity.</p>"},{"location":"AR250416/#insertion-operation","title":"Insertion Operation","text":"<p>The insert function ensures: - The first inserted node becomes the root. - Subsequent nodes are sorted left (smaller) or right (larger). - Duplicate keys are explicitly rejected via <code>assert(false)</code>.</p> <pre><code>// Inserting into BST\nvoid BSTree&lt;T1, T2&gt;::insert(const Pair&lt;T1, T2&gt;&amp; _pair) {\n    Node&lt;T1, T2&gt;* newNode = new Node&lt;T1, T2&gt;(_pair);\n    if (m_Root == nullptr) {\n        m_Root = newNode;\n        ++m_Size;\n        return;\n    }\n\n    Node&lt;T1, T2&gt;* itrNode = m_Root;\n    while (true) {\n        if (newNode-&gt;pair.key &lt; itrNode-&gt;pair.key) {\n            if (!itrNode-&gt;ptr[LCHILD]) {\n                itrNode-&gt;ptr[LCHILD] = newNode;\n                newNode-&gt;ptr[PARENT] = itrNode;\n                ++m_Size;\n                break;\n            } else {\n                itrNode = itrNode-&gt;ptr[LCHILD];\n            }\n        } else if (newNode-&gt;pair.key &gt; itrNode-&gt;pair.key) {\n            if (!itrNode-&gt;ptr[RCHILD]) {\n                itrNode-&gt;ptr[RCHILD] = newNode;\n                newNode-&gt;ptr[PARENT] = itrNode;\n                ++m_Size;\n                break;\n            } else {\n                itrNode = itrNode-&gt;ptr[RCHILD];\n            }\n        } else {\n            // Duplicate key detected\n            assert(false);\n        }\n    }\n}\n</code></pre>"},{"location":"AR250416/#common-mistake","title":"Common Mistake","text":"<p>In STL containers like <code>std::map</code>, inserting a key that already exists will simply ignore the new value. This leads to: - Untracked memory (if dynamic memory was used) - Potential memory leaks</p> <p>Always ensure duplicates are prevented, asserted, or handled using a container like <code>std::multimap</code>, which stores same-key elements in a linked fashion.</p>"},{"location":"AR250416/#clearing-the-bst","title":"Clearing the BST","text":"<p>To delete all nodes: - Perform level-order traversal using a queue (FIFO) structure. - This is known as Breadth-First Search (BFS) and guarantees all nodes are deleted without breaking pointer chains.</p> <pre><code>// Clearing all nodes using BFS\nvoid BSTree&lt;T1, T2&gt;::clear() {\n    if (!m_Root) return;\n\n    std::queue&lt;Node&lt;T1, T2&gt;*&gt; nodeQueue;\n    nodeQueue.push(m_Root);\n\n    while (!nodeQueue.empty()) {\n        Node&lt;T1, T2&gt;* current = nodeQueue.front();\n        nodeQueue.pop();\n\n        if (current-&gt;ptr[LCHILD]) nodeQueue.push(current-&gt;ptr[LCHILD]);\n        if (current-&gt;ptr[RCHILD]) nodeQueue.push(current-&gt;ptr[RCHILD]);\n\n        delete current;\n    }\n\n    m_Root = nullptr;\n    m_Size = 0;\n}\n</code></pre> <p>BFS is generally safer for tree deletion. For DFS-based deletion, a stack (LIFO) should be used.</p>"},{"location":"AR250416/#in-order-successor-predecessor","title":"In-Order Successor &amp; Predecessor","text":"<p>In-order traversal visits nodes in key-sorted order.</p>"},{"location":"AR250416/#successor","title":"Successor:","text":"<ul> <li>If the node has a right child: return the leftmost node in the right subtree.</li> <li>If not: move up until you find a node that is a left child of its parent.</li> </ul> <pre><code>// Find the in-order successor\nNode&lt;T1, T2&gt;* BSTree&lt;T1, T2&gt;::getInOrderSuccessor(Node&lt;T1, T2&gt;* node) {\n    if (node-&gt;HasRChild()) {\n        Node&lt;T1, T2&gt;* successor = node-&gt;ptr[RCHILD];\n        while (successor-&gt;ptr[LCHILD]) successor = successor-&gt;ptr[LCHILD];\n        return successor;\n    }\n\n    while (node-&gt;ptr[PARENT] &amp;&amp; node == node-&gt;ptr[PARENT]-&gt;ptr[RCHILD]) {\n        node = node-&gt;ptr[PARENT];\n    }\n\n    return node-&gt;ptr[PARENT];\n}\n</code></pre>"},{"location":"AR250416/#predecessor","title":"Predecessor:","text":"<ul> <li>If the node has a left child: return the rightmost node in the left subtree.</li> <li>Otherwise: move up to a parent node where the current node is in the right.</li> </ul>"},{"location":"AR250416/#stl-vs-custom-bst","title":"STL vs Custom BST","text":""},{"location":"AR250416/#stl-set-vs-map","title":"STL <code>set</code> vs <code>map</code>:","text":"<ul> <li><code>set&lt;T&gt;</code>: Sorted by element value (used as key).</li> <li><code>map&lt;K, V&gt;</code>: Sorted by key only, value follows.</li> </ul>"},{"location":"AR250416/#multimap","title":"Multimap:","text":"<ul> <li>Allows duplicate keys.</li> <li>Internally maintains multiple values for the same key using a structure like a linked list at each node.</li> </ul>"},{"location":"AR250416/#recommendation","title":"Recommendation:","text":"<ul> <li>Avoid duplicate keys unless using <code>multimap</code>.</li> <li>For standard BSTs, explicitly prevent duplicates to avoid memory issues.</li> </ul>"},{"location":"AR250416/#custom-utility-templates","title":"Custom Utility Templates","text":"<p>Helpful for wrapping key-value pairs in custom implementations:</p> <pre><code>// Pair creation helper\ntemplate&lt;typename T1, typename T2&gt;\ntPair MakePair(const T1&amp; _First, const T2&amp; _Second) {\n    tPair pair;\n    pair.first = _First;\n    pair.second = _Second;\n    return pair;\n}\n</code></pre>"},{"location":"AR250416/#interview-questions-and-answers","title":"Interview Questions and Answers","text":""},{"location":"AR250416/#q1-what-is-the-time-complexity-of-insertion-in-a-bst","title":"Q1: What is the time complexity of insertion in a BST?","text":"<p>A: Average case is O(log n), but worst-case (unbalanced tree) is O(n).</p>"},{"location":"AR250416/#q2-how-does-a-bst-handle-duplicate-keys","title":"Q2: How does a BST handle duplicate keys?","text":"<p>A: Standard BST (like <code>std::set</code>, <code>std::map</code>) does not allow duplicates. You must handle this explicitly or use <code>std::multimap</code>.</p>"},{"location":"AR250416/#q3-describe-how-in-order-traversal-works-in-bst","title":"Q3: Describe how in-order traversal works in BST.","text":"<p>A: It recursively visits left child, current node, and right child. This results in ascending order of keys.</p>"},{"location":"AR250416/#q4-how-do-you-find-the-in-order-successor-of-a-node","title":"Q4: How do you find the in-order successor of a node?","text":"<p>A: If right child exists, go to the leftmost node of the right subtree. Else, move up to the first ancestor where the node is in the left subtree.</p>"},{"location":"AR250416/#q5-why-use-bfs-for-deletion-in-a-destructor","title":"Q5: Why use BFS for deletion in a destructor?","text":"<p>A: It ensures each node is visited once and avoids deleting children of already deleted nodes.</p>"},{"location":"AR250416/#conclusion","title":"Conclusion","text":"<p>This study covers the foundational structure and behaviors of BSTs with emphasis on implementation challenges and common interview traps. Mastery of BST fundamentals, including memory safety and proper traversal strategies, sets the groundwork for working with balanced trees like AVL or Red-Black trees.</p>"},{"location":"AR250417/","title":"Binary Search Tree Iterator and Enum in C++","text":""},{"location":"AR250417/#date-2025-04-17","title":"Date: 2025-04-17","text":""},{"location":"AR250417/#key-points","title":"Key Points","text":"<ul> <li>Enums provide a way to create named constants and custom types</li> <li>Enum classes help avoid name collisions by scoping enum values</li> <li>BST iterators follow in-order traversal to access elements in sorted order</li> <li>Iterator implementation requires handling tree traversal logic for operations like <code>++</code>, <code>--</code></li> </ul>"},{"location":"AR250417/#enumerations-enum-in-c","title":"Enumerations (Enum) in C++","text":"<p>Enumerations in C++ provide a way to define named integer constants, making code more readable and self-documenting.</p>"},{"location":"AR250417/#basic-enum","title":"Basic Enum","text":"<pre><code>enum PLAYER_STATE \n{\n    IDLE,    // 0\n    MOVE,    // 1\n    JUMP,    // 2\n    ATTACK,  // 3\n    HURT,    // 4\n    DEATH,   // 5\n    FALL     // 6\n}; \n</code></pre> <p>Key characteristics: - Enum values are implicitly converted to integers - Occupies 4 bytes in memory (same as an int) - Values start from 0 by default and increment by 1</p>"},{"location":"AR250417/#advantages-over-macros","title":"Advantages over Macros","text":"<p>While macros can be used for similar purposes, enums offer several advantages:</p> <pre><code>// Using macros\n#define PLAYER_IDLE 0\n#define PLAYER_MOVE 1\n#define PLAYER_JUMP 2\n\n// Using enum\nenum PLAYER_STATE { IDLE, MOVE, JUMP };\n</code></pre> <p>Enums are: - Type-checked at compile time - Can be used to define custom types - Visible in debuggers with their symbolic names</p>"},{"location":"AR250417/#enum-class-c11","title":"Enum Class (C++11)","text":"<p>Enum classes provide scoped enumeration values, preventing name collisions:</p> <pre><code>enum class NEW_ENUM\n{\n    TYPE_1, \n    TYPE_2\n};\n\nenum class OTHER_ENUM\n{\n    TYPE_1,  // No collision with NEW_ENUM::TYPE_1\n    TYPE_2\n};\n\n// Usage\nNEW_ENUM NewType = NEW_ENUM::TYPE_1;\nOTHER_ENUM OtherType = OTHER_ENUM::TYPE_1;\n</code></pre>"},{"location":"AR250417/#binary-search-tree-iterator-implementation","title":"Binary Search Tree Iterator Implementation","text":""},{"location":"AR250417/#iterator-concept","title":"Iterator Concept","text":"<p>A BST iterator provides sequential access to BST elements in a specific order (typically in-order traversal):</p> <pre><code>        1000 \n      /      \\\n    500      1500\n</code></pre> <p>In-order traversal visits: 500 \u2192 1000 \u2192 1500</p>"},{"location":"AR250417/#begin-iterator-implementation","title":"Begin Iterator Implementation","text":"<p>To implement <code>begin()</code>, we need to find the leftmost node in the tree:</p> <pre><code>tBSTNode&lt;T1, T2&gt; * pBeginNode = m_Root;\nif(!m_Root) return end();  \nwhile(pBeginNode-&gt;arrPtr[LCHILD] != nullptr)\n{\n    pBeginNode = pBeginNode-&gt;arrPtr[LCHILD];\n}\n\nreturn iterator(this, pBeginNode);\n</code></pre>"},{"location":"AR250417/#end-iterator-implementation","title":"End Iterator Implementation","text":"<p>The <code>end()</code> iterator is represented by a nullptr:</p> <pre><code>return iterator(this, nullptr);\n</code></pre>"},{"location":"AR250417/#increment-operator-logic","title":"Increment (++) Operator Logic","text":"<p>For in-order traversal, the increment operation needs to find the \"next\" node according to these rules:</p> <ol> <li>If the current node has a right child:</li> <li>Go to the right child</li> <li> <p>Then go as far left as possible from that right child</p> </li> <li> <p>If the current node doesn't have a right child:</p> </li> <li>Go up to the parent (if any)</li> <li>If the current node is a left child of its parent, the parent is next</li> <li>If the current node is a right child, keep going up until finding a node that is a left child of its parent</li> </ol> <pre><code>// Pseudocode for ++ operator\nif (currentNode-&gt;right != nullptr) {\n    // Move to right child\n    currentNode = currentNode-&gt;right;\n\n    // Then go as far left as possible\n    while (currentNode-&gt;left != nullptr) {\n        currentNode = currentNode-&gt;left;\n    }\n    return currentNode;\n}\nelse {\n    // No right child, so go up to parent\n    while (currentNode is a right child of its parent) {\n        currentNode = parent;\n    }\n    if (currentNode is a left child) {\n        return parent;\n    }\n    else {\n        // We've reached the root and there's no next node\n        return nullptr;\n    }\n}\n</code></pre>"},{"location":"AR250417/#decrement-operator","title":"Decrement (--) Operator","text":"<p>The decrement operator follows similar logic but in reverse:</p> <ol> <li>If the current node has a left child:</li> <li>Go to the left child</li> <li> <p>Then go as far right as possible from that left child</p> </li> <li> <p>If the current node doesn't have a left child:</p> </li> <li>Go up to the parent</li> <li>If the current node is a right child of its parent, the parent is the previous node</li> <li>If the current node is a left child, keep going up until finding a node that is a right child of its parent</li> </ol>"},{"location":"AR250417/#usage-example","title":"Usage Example","text":"<pre><code>BST&lt;int, float&gt; myBST;\n\nmyBST.insert(MakePair(1000, 1.1f));\nmyBST.insert(MakePair(500, 2.2f));\nmyBST.insert(MakePair(1500, 3.3f));\n\nBST&lt;int, float&gt;::iterator iter = myBST.begin();\n\n// Accessing elements\nint First = (*iter).first;\nfloat Second = (*iter).second;\n\n// Finding elements\niter = myBST.find(1700);  // Returns end() if not found\n\n// Iterating through all elements\nfor (iter = myBST.begin(); iter != myBST.end(); ++iter)\n{\n    std::cout &lt;&lt; (*iter).first &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"AR250417/#tricky-cases-with-enums","title":"Tricky Cases with Enums","text":""},{"location":"AR250417/#force-casting-to-enum-values","title":"Force Casting to Enum Values","text":"<p>Enums can be force-cast to values not defined in the enumeration, but this can lead to undefined behavior:</p> <pre><code>PLAYER_STATE PlayerState = (PLAYER_STATE) 220;  // Valid but potentially dangerous\n</code></pre>"},{"location":"AR250417/#name-collisions","title":"Name Collisions","text":"<p>Without enum classes, name collisions can occur across different enums:</p> <pre><code>enum TYPE_A { RED, GREEN, BLUE };\nenum TYPE_B { RED, YELLOW, PURPLE };  // Compiler error: RED already defined\n\n// Solution with prefixes\nenum TYPE_A { TA_RED, TA_GREEN, TA_BLUE };\nenum TYPE_B { TB_RED, TB_YELLOW, TB_PURPLE };\n\n// Better solution with enum classes\nenum class TypeA { RED, GREEN, BLUE };\nenum class TypeB { RED, YELLOW, PURPLE };\n</code></pre>"},{"location":"AR250417/#interview-questions","title":"Interview Questions","text":"<p>Q: What is the difference between <code>enum</code> and <code>enum class</code> in C++? A: <code>enum</code> declares unscoped enumerations where enum values are placed in the enclosing scope, which can lead to name collisions. <code>enum class</code> (introduced in C++11) creates scoped enumerations where values must be accessed through the enum name (e.g., <code>NEW_ENUM::TYPE_1</code>), avoiding name collisions. Enum classes also don't implicitly convert to integers.</p> <p>Q: How would you implement the <code>find()</code> method for a Binary Search Tree? A: The <code>find()</code> method would recursively or iteratively traverse the tree, comparing the target key with the current node's key. If equal, return the current node. If less, search the left subtree. If greater, search the right subtree. Return null if the key is not found.</p> <p>Q: Explain the traversal logic for a binary search tree iterator's <code>++</code> operator. A: For in-order traversal, the increment operator first checks if the current node has a right child. If so, it moves to the right child and then goes as far left as possible. If there's no right child, it goes up to the parent, checking if the current node is a left child of its parent. If it is, the parent is the next node. If not, it continues up the tree until finding a node that is a left child of its parent.</p> <p>Q: How would you implement a binary search tree's <code>begin()</code> method for in-order traversal? A: The <code>begin()</code> method would start from the root and traverse left as far as possible to find the smallest value in the tree. If the tree is empty, it returns the <code>end()</code> iterator.</p> <p>Q: What would be the output of iterating through a BST with nodes 1000, 500, and 1500 using in-order traversal? A: The output would be: 500, 1000, 1500 (sorted in ascending order).</p> <p>Q: What are the advantages of using enum over #define macros in C++? A: Enums are type-checked at compile time, can be used with debuggers (showing symbolic names instead of raw values), can be used as custom types, and are processed by the compiler rather than the preprocessor. This makes them safer and more maintainable than macros.</p>"},{"location":"AR250417/#common-mistakes","title":"Common Mistakes","text":"<p>Using raw enum values without understanding their meaning: <pre><code>int iState = 0;  // Unclear what state this represents\niState = 1;      // Other developers can't understand the meaning\n\n// Better approach\nPLAYER_STATE state = IDLE;\nstate = MOVE;    // Much clearer meaning\n</code></pre></p> <p>Forgetting scoping for enum classes: <pre><code>enum class Direction { UP, DOWN, LEFT, RIGHT };\n\nDirection dir = UP;                  // Error: UP not in scope\nDirection dir = Direction::UP;       // Correct\n</code></pre></p> <p>Assuming enum values have specific numeric values: <pre><code>enum Color { RED, GREEN = 10, BLUE };  // RED is 0, GREEN is 10, BLUE is 11\n</code></pre></p> <p>Always check the actual values when relying on the numeric representation of enums.</p>"},{"location":"AR250418/","title":"Compiler Knowledge for Game Developers","text":"<p>This guide summarizes essential compiler-related knowledge for aspiring video game developers. While deep compiler theory isn't necessary for game development, understanding how your code is built, optimized, and run is absolutely crucial for building efficient, cross-platform games.</p>"},{"location":"AR250418/#1-c-compilation-pipeline","title":"1. C++ Compilation Pipeline","text":"<p>Understanding how your C++ code turns into an executable is foundational.</p>"},{"location":"AR250418/#compilation-steps","title":"Compilation Steps:","text":"<ol> <li>Preprocessing (<code>.cpp</code> -&gt; <code>.i</code>):</li> <li>Expands macros, includes headers.</li> <li> <p>Handles <code>#define</code>, <code>#include</code>, and conditional compilation.</p> </li> <li> <p>Compilation (<code>.i</code> -&gt; <code>.s</code>):</p> </li> <li>Translates preprocessed code into assembly.</li> <li> <p>Performs syntax and type checking.</p> </li> <li> <p>Assembly (<code>.s</code> -&gt; <code>.o</code>):</p> </li> <li> <p>Converts assembly to machine code in an object file.</p> </li> <li> <p>Linking (<code>.o</code> -&gt; <code>.exe</code>):</p> </li> <li>Combines object files and libraries into an executable.</li> <li>Resolves symbols and sets up the entry point.</li> </ol>"},{"location":"AR250418/#2-key-concepts-for-game-developers","title":"2. Key Concepts for Game Developers","text":""},{"location":"AR250418/#must-know","title":"Must-Know:","text":"<ul> <li>C++ syntax and build systems (Make, CMake, Visual Studio projects).</li> <li>Common linker errors and how to resolve them.</li> <li>Compilation units and header management.</li> </ul>"},{"location":"AR250418/#very-useful","title":"Very Useful:","text":"<ul> <li>Compiler optimization flags: <code>-O0</code>, <code>-O2</code>, <code>-O3</code>, <code>-g</code>, <code>-Wall</code>.</li> <li>Debug vs Release build differences.</li> <li>Profiling and debugging tools: GDB, Visual Studio Debugger, Valgrind, perf.</li> </ul>"},{"location":"AR250418/#optional-deeper-knowledge","title":"Optional (Deeper Knowledge):","text":"<ul> <li>Understanding intermediate representations (GIMPLE, LLVM IR).</li> <li>Assembly and disassembly for performance tuning.</li> <li>Differences between compilers (GCC, Clang, MSVC).</li> </ul>"},{"location":"AR250418/#3-common-c-compilers-and-toolchains","title":"3. Common C++ Compilers and Toolchains","text":""},{"location":"AR250418/#gcc-gnu-compiler-collection","title":"GCC (GNU Compiler Collection)","text":"<ul> <li>Open-source and cross-platform.</li> <li>Common on Linux and embedded systems.</li> </ul>"},{"location":"AR250418/#clang","title":"Clang","text":"<ul> <li>LLVM-based, modern, and modular.</li> <li>Very fast with better error messages.</li> <li>Often used with Apple platforms and modern C++ tooling.</li> </ul>"},{"location":"AR250418/#msvc-microsoft-visual-c","title":"MSVC (Microsoft Visual C++)","text":"<ul> <li>The default compiler in Visual Studio on Windows.</li> <li>Deep integration with the Windows ecosystem.</li> </ul>"},{"location":"AR250418/#mingw-mingw-w64","title":"MinGW / MinGW-w64","text":"<ul> <li>\"Minimalist GNU for Windows\": A Windows port of GCC.</li> <li>Allows you to use <code>g++</code> on Windows and build Windows executables.</li> <li>Great for cross-platform development or when avoiding MSVC.</li> </ul>"},{"location":"AR250418/#key-differences-mingw-vs-msvc","title":"Key Differences (MinGW vs MSVC):","text":"<ul> <li>MSVC: Tightly coupled with Visual Studio IDE, uses Microsoft's C++ runtime, and generates PE files with native Windows linkage.</li> <li>MinGW: Uses GCC toolchain, can produce smaller binaries, and follows more POSIX-like behavior.</li> <li>Use Case: MSVC for deep Windows integration (e.g., DirectX, UWP). MinGW for portable or cross-compiled apps.</li> </ul>"},{"location":"AR250418/#4-useful-tools","title":"4. Useful Tools","text":"<ul> <li>GCC/g++: Common open-source compiler for Linux.</li> <li>MSVC: Visual Studio's compiler for Windows.</li> <li>Clang: Modern, fast, and modular compiler.</li> <li>CMake: Cross-platform build system.</li> <li>Valgrind, perf: Profiling and debugging tools for Linux.</li> <li>GDB: GNU Debugger for C++.</li> </ul>"},{"location":"AR250418/#5-summary-what-to-learn-and-why","title":"5. Summary: What to Learn (and Why)","text":""},{"location":"AR250418/#focus-on","title":"Focus On:","text":"<ul> <li>C++ compilation steps and how to build with <code>g++</code>, <code>clang</code>, or Visual Studio.</li> <li>How to use and understand build systems (Make, CMake, etc.).</li> <li>How to debug builds, fix linker errors, and use compiler flags.</li> <li>Tools for profiling and memory checking.</li> </ul>"},{"location":"AR250418/#optional-but-beneficial","title":"Optional but Beneficial:","text":"<ul> <li>Disassembling <code>.o</code> files for optimization.</li> <li>Intermediate compiler layers if you're into deep systems or engine development.</li> </ul> <p>Game developers do not need to master compiler internals, but understanding how your code is turned into a game-ready executable can give you a major edge in performance, debugging, and cross-platform development.</p>"},{"location":"AR250421/","title":"Binary Search Tree Erase Logic","text":""},{"location":"AR250421/#date-2025-04-21","title":"Date: 2025-04-21","text":""},{"location":"AR250421/#key-points","title":"Key Points","text":"<ul> <li><code>find</code> locates a node using binary search logic.</li> <li>Iterators traverse the BST in-order using <code>++</code> and <code>--</code> operators.</li> <li><code>erase</code> supports deletion of:</li> <li>Leaf nodes</li> <li>Nodes with one child</li> <li>Nodes with two children (replaced by inorder successor)</li> </ul>"},{"location":"AR250421/#overview","title":"Overview","text":"<p>This study note focuses on the implementation of <code>find</code>, iterator behavior, and the <code>erase</code> operation in a templated Binary Search Tree (BST). The BST manages memory explicitly, with pointer-based node structures and recursive logic for insertion and traversal.</p>"},{"location":"AR250421/#find-and-iterator-basics","title":"Find and Iterator Basics","text":"<pre><code>BST&lt;int, int&gt; bst;\nbst.insert(MakePair(8, 0));\nbst.insert(MakePair(4, 0));\nbst.insert(MakePair(12, 0));\n\nBST&lt;int, int&gt;::iterator iter = bst.find(8);\nif (iter != bst.end()) {\n    std::cout &lt;&lt; (*iter).first &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"AR250421/#erase-function-explanation","title":"<code>erase</code> Function Explanation","text":"<p>The <code>erase</code> function is responsible for removing a node from a Binary Search Tree (BST) while maintaining the tree\u2019s structure. Let\u2019s go through each scenario and corresponding code:</p>"},{"location":"AR250421/#1-precondition-and-validation","title":"1. Precondition and Validation","text":"<p>Before any deletion logic begins, the function checks that the iterator is valid: <pre><code>assert(_iter.m_Owner == this &amp;&amp; _iter.m_Target != nullptr);\n</code></pre> - Explanation:   This ensures that the iterator belongs to the current BST instance and that it points to a valid node. If either condition fails, the program will stop, preventing undefined behavior.</p>"},{"location":"AR250421/#2-deleting-a-leaf-node-no-children","title":"2. Deleting a Leaf Node (No Children)","text":"<p>If the node is a leaf (i.e., it has no children), it\u2019s the simplest case: <pre><code>if (_iter.m_Target-&gt;IsLeaf())\n{\n    pSuccessor = GetInorderSuccessor(_iter.m_Target);\n\n    if (_iter.m_Target == m_Root)\n    {\n        m_Root = nullptr;\n    }\n    else\n    {\n        if (_iter.m_Target-&gt;IsLChild())\n            _iter.m_Target-&gt;GetNode(PARENT)-&gt;arrPtr[LCHILD] = nullptr;\n        else\n            _iter.m_Target-&gt;GetNode(PARENT)-&gt;arrPtr[RCHILD] = nullptr;            \n    }        \n\n    delete _iter.m_Target;\n    --m_Size;    \n}\n</code></pre> - Explanation:   - If the node is the root and has no children, the root pointer is simply set to <code>nullptr</code>.   - If the node has a parent, the parent\u2019s pointer to this node is cleared. The <code>IsLChild</code> check determines if the node is a left or right child and updates the appropriate pointer in the parent node.   - Finally, the node\u2019s memory is deallocated and the size of the BST is decremented.</p>"},{"location":"AR250421/#3-deleting-a-node-with-one-child","title":"3. Deleting a Node with One Child","text":"<p>If the node has one child (either left or right), the child is promoted to the node\u2019s position: <pre><code>else if (!_iter.m_Target-&gt;IsFull())\n{\n    pSuccessor = GetInorderSuccessor(_iter.m_Target);\n\n    if (_iter.m_Target == m_Root)\n    {\n        if (_iter.m_Target-&gt;HasLChild())\n            m_Root = _iter.m_Target-&gt;GetNode(LCHILD);\n        else\n            m_Root = _iter.m_Target-&gt;GetNode(RCHILD);\n        m_Root-&gt;arrPtr[PARENT] = nullptr;\n    }\n    else\n    {\n        NODE_TYPE ChildType = _iter.m_Target-&gt;HasLChild() ? LCHILD : RCHILD;\n        NODE_TYPE TargetType = _iter.m_Target-&gt;IsLChild() ? LCHILD : RCHILD;\n\n        _iter.m_Target-&gt;GetNode(PARENT)-&gt;arrPtr[TargetType] = _iter.m_Target-&gt;GetNode(ChildType);\n        _iter.m_Target-&gt;GetNode(ChildType)-&gt;arrPtr[PARENT] = _iter.m_Target-&gt;GetNode(PARENT);\n    }\n\n    delete _iter.m_Target;\n    --m_Size;\n}\n</code></pre> - Explanation:   - If the node to be deleted is the root, the child simply becomes the new root.   - If it is not the root, the parent\u2019s pointer to the node is redirected to the node\u2019s only child. The child\u2019s parent pointer is updated to point to the node\u2019s parent.   - Memory is deallocated, and the size is reduced.</p>"},{"location":"AR250421/#4-deleting-a-node-with-two-children","title":"4. Deleting a Node with Two Children","text":"<p>If the node has two children, it is more complex: <pre><code>else\n{\n    pSuccessor = GetInorderSuccessor(_iter.m_Target);\n    _iter.m_Target-&gt;pair = pSuccessor-&gt;pair;\n\n    iterator pNextIter(this, pSuccessor);\n    erase(pNextIter);\n\n    pSuccessor = _iter.m_Target;\n}\n</code></pre> - Explanation:   - Find the inorder successor:     The inorder successor is the smallest node in the node\u2019s right subtree. This node will replace the current node\u2019s data while maintaining the BST\u2019s order.   - Copy data from successor:     The successor\u2019s key-value pair is copied to the current node.   - Recursive deletion:     The successor is a simpler node to remove (usually a leaf or a node with one child), so the function calls <code>erase()</code> recursively on the successor.   - Update successor pointer:     After the recursive call, the successor pointer is adjusted to point to the updated node.</p>"},{"location":"AR250421/#5-final-steps","title":"5. Final Steps","text":"<p>After the deletion logic, the iterator that was passed in is invalidated: <pre><code>_iter.m_Owner = nullptr;\n_iter.m_Target = nullptr;\n</code></pre> - Explanation:   This ensures that the caller cannot use the iterator to access the now-deleted node.</p> <p>Finally, the function returns an iterator pointing to the successor node: <pre><code>return iterator(this, pSuccessor);\n</code></pre> - Explanation:   This allows the caller to continue traversal seamlessly after deletion.</p>"},{"location":"AR250421/#summary","title":"Summary","text":"<ul> <li>Leaf Nodes: Simply detach and delete.</li> <li>Nodes with One Child: Promote the child to the current node\u2019s position.</li> <li>Nodes with Two Children: Replace data with inorder successor\u2019s data, then recursively delete the successor.</li> <li>Safety Checks: Ensures the iterator is valid and prevents dangling references.</li> </ul> <p>This detailed walkthrough should help clarify the logic behind each part of the <code>erase</code> function.</p>"},{"location":"AR250421/#code-demonstration","title":"Code Demonstration","text":"<pre><code>BST&lt;int, int&gt; bst;\nbst.insert(MakePair(8, 0));\nbst.insert(MakePair(4, 0));\nbst.insert(MakePair(12, 0));\nbst.insert(MakePair(2, 0));\nbst.insert(MakePair(10, 0));\n\nBST&lt;int, int&gt;::iterator iter = bst.find(8);\nif (iter != bst.end()) {\n    iter = bst.erase(iter);  // safely returns iterator to next valid node\n}\n</code></pre>"},{"location":"AR250421/#references","title":"References","text":"<p>BST.h</p>"},{"location":"AR250422/","title":"Inheritance and Object Lifecycle","text":"<p>Last updated: April 22, 2025</p> <p>This article provides a thorough explanation of C++ inheritance mechanics, with special focus on the object lifecycle, memory management, and common pitfalls. It's designed as a study resource for game programming interviews where these concepts frequently appear.</p>"},{"location":"AR250422/#introduction-to-inheritance","title":"Introduction to Inheritance","text":"<p>Inheritance is a fundamental object-oriented programming concept that allows classes to derive properties and behaviors from other classes. In C++, it enables code reuse, extensibility, and the establishment of hierarchical relationships between classes.</p> <p>A derived class (or child class) inherits accessible members from a base class (or parent class), extending its functionality while maintaining the core characteristics of the parent.</p>"},{"location":"AR250422/#visual-uml-diagram-of-inheritance","title":"Visual: UML Diagram of Inheritance","text":"<pre><code>classDiagram\n    class CParent {\n        -int m_I\n        -int* m_pData\n        +SetData(int)\n        +GetData() : int\n        +CParent()\n        +CParent(int)\n        +~CParent()\n    }\n\n    class CChild {\n        -float m_F\n        -float* m_pFloatData\n        +SetFloat(float)\n        +GetFloat() : float\n        +CChild()\n        +CChild(int, float)\n        +~CChild()\n    }\n\n    CChild --|&gt; CParent\n</code></pre> <p>This UML diagram provides a quick reference to the relationship between <code>CParent</code> and <code>CChild</code>, highlighting member variables and methods.</p>"},{"location":"AR250422/#class-structure-and-access-control","title":"Class Structure and Access Control","text":"<p>In C++, the access specifier used in inheritance dictates how base class members can be accessed by the derived class:</p> <ul> <li>public inheritance: The most common form, preserving the access level of base class members</li> <li>protected inheritance: All public members of the base class become protected in the derived class</li> <li>private inheritance: All public and protected members of the base class become private in the derived class</li> </ul> <p>Let's examine a practical example using <code>CParent</code> as our base class and <code>CChild</code> as the derived class:</p> <pre><code>class CParent {\nprotected:\n    int m_I;\n    int* m_pData;\n\npublic:\n    void SetData(int _Data) { m_I = _Data; }\n    int GetData() { return m_I; }\n\n    CParent() : m_I(0), m_pData(new int[100]) {}\n    CParent(int _Data) : m_I(_Data), m_pData(new int[100]) {}\n\n    ~CParent() {\n        if (m_pData) delete[] m_pData;\n    }\n};\n\nclass CChild : public CParent {\nprivate:\n    float m_F;\n    float* m_pFloatData;\n\npublic:\n    void SetFloat(float _F) {\n        m_I = 100; // accessing protected member from base class\n        m_F = _F;\n    }\n    float GetFloat() { return m_F; }\n\n    CChild() : m_F(0.f), m_pFloatData(new float[1000]) {}\n    CChild(int _IntData, float _FloatData)\n        : CParent(_IntData), m_F(_FloatData), m_pFloatData(new float[1000]) {}\n\n    ~CChild() {\n        if (m_pFloatData) delete[] m_pFloatData;\n        // CParent destructor called automatically\n    }\n};\n</code></pre> <p>Notice how: - The <code>CParent</code> class uses the <code>protected</code> access modifier for member variables, allowing derived classes to access them directly - <code>CChild</code> can access the protected <code>m_I</code> member from <code>CParent</code> - Both classes properly manage their dynamically allocated memory</p>"},{"location":"AR250422/#object-lifecycle-in-inheritance","title":"Object Lifecycle in Inheritance","text":"<p>Understanding the precise order of construction and destruction is crucial for proper resource management in C++.</p>"},{"location":"AR250422/#construction-order","title":"Construction Order","text":"<p>When a derived class object is created, the construction sequence follows a specific order:</p> <ol> <li>Base class constructor is called first</li> <li>Derived class constructor is called after</li> </ol> <p>Example:</p> <pre><code>CChild child;  // First calls CParent(), then CChild()\nCChild child1(100, 2.2f);  // First calls CParent(100), then CChild's constructor\n</code></pre>"},{"location":"AR250422/#initialization-lists","title":"Initialization Lists","text":"<p>An important detail: derived class constructors can only initialize their own members directly in the initialization list. Base class members must be initialized by calling the appropriate base class constructor:</p> <pre><code>CChild(int _IntData, float _FloatData)\n    : CParent(_IntData),  // Call base constructor to initialize base members\n      m_F(_FloatData),    // Initialize own members\n      m_pFloatData(new float[1000]) {}\n</code></pre>"},{"location":"AR250422/#destruction-order","title":"Destruction Order","text":"<p>When objects are destroyed, the order is reversed:</p> <ol> <li>Derived class destructor executes first</li> <li>Base class destructor executes after</li> </ol> <p>This reverse order ensures that derived class resources are cleaned up before base class resources.</p>"},{"location":"AR250422/#memory-management-in-derived-classes","title":"Memory Management in Derived Classes","text":"<p>Proper memory management is critical in C++ inheritance hierarchies to prevent memory leaks and undefined behavior.</p>"},{"location":"AR250422/#key-points","title":"Key Points:","text":"<ol> <li>Constructor/Destructor Pairing: Every constructor that allocates resources must have a corresponding destructor that deallocates them.</li> <li>Resource Ownership: Be clear about which class owns which resources.</li> <li>Destructor Chain: Destructors are called automatically in reverse order of inheritance.</li> </ol> <p>For example, in our sample code:</p> <pre><code>~CChild() {\n    // Clean up resources owned by CChild\n    if (m_pFloatData) delete[] m_pFloatData;\n    // CParent destructor is called automatically after this\n}\n</code></pre> <p>This ensures that the <code>m_pFloatData</code> resource is freed before the base class destructor runs to free <code>m_pData</code>.</p>"},{"location":"AR250422/#copy-construction-in-inheritance","title":"Copy Construction in Inheritance","text":"<p>The compiler automatically generates a copy constructor if one isn't explicitly defined. However, this default copy constructor performs a shallow copy, which can lead to problems with dynamically allocated resources.</p>"},{"location":"AR250422/#default-copy-constructor-issue","title":"Default Copy Constructor Issue","text":"<p>In our class hierarchy, the default copy constructor would look something like:</p> <pre><code>CChild(const CChild&amp; _Other)\n    : CParent(),  // Default constructor, not copy constructor!\n    m_F(_Other.m_F),\n    m_pFloatData(new float[1000]) {\n    // Copy values from _Other.m_pFloatData\n}\n</code></pre> <p>This is problematic because it calls the default constructor for <code>CParent</code>, not its copy constructor.</p>"},{"location":"AR250422/#correct-copy-constructor","title":"Correct Copy Constructor","text":"<p>A proper copy constructor should explicitly call the base class copy constructor:</p> <pre><code>CChild(const CChild&amp; _Other)\n    : CParent(_Other),  // Call base copy constructor\n    m_F(_Other.m_F),\n    m_pFloatData(new float[1000]) {\n    // Deep copy values from _Other.m_pFloatData\n    for (int i = 0; i &lt; 1000; i++) {\n        m_pFloatData[i] = _Other.m_pFloatData[i];\n    }\n}\n</code></pre>"},{"location":"AR250422/#polymorphism-and-virtual-functions","title":"Polymorphism and Virtual Functions","text":"<p>When working with inheritance, polymorphism allows derived classes to override base class methods and for those overridden methods to be called correctly even through a base class pointer.</p> <p>In C++, this requires the use of the <code>virtual</code> keyword:</p> <pre><code>class Base {\npublic:\n    virtual void Method() { /* base implementation */ }\n    virtual ~Base() {}  // Virtual destructor is crucial!\n};\n\nclass Derived : public Base {\npublic:\n    void Method() override { /* derived implementation */ }\n    ~Derived() {}\n};\n</code></pre>"},{"location":"AR250422/#virtual-destructors","title":"Virtual Destructors","text":"<p>A common mistake is forgetting to declare destructors as virtual in base classes intended for polymorphic use. Without a virtual destructor, deleting a derived object through a base pointer leads to undefined behavior:</p> <pre><code>Base* ptr = new Derived();\ndelete ptr;  // Without virtual destructor, only ~Base() is called, leaking resources\n</code></pre>"},{"location":"AR250422/#random-number-generation","title":"Random Number Generation","text":"<p>While not directly related to inheritance, the notes also included information about random number generation in C++, which is often used in game programming:</p> <pre><code>// Seed the random number generator\nsrand(time(nullptr));  // Uses current time as seed for randomization\n\n// Generate random numbers between 1 and 100\nint random_number = rand() % 100 + 1;  // Returns 1-100\n</code></pre> <p>This technique creates a random number between 1 and 100 by: 1. Using <code>rand()</code> to generate a pseudo-random integer 2. Taking the modulo (%) to restrict it to a range (0-99) 3. Adding 1 to shift the range to 1-100</p> <p>For more complex game systems, using the C++11 random library provides better statistical properties:</p> <pre><code>#include &lt;random&gt;\n#include &lt;chrono&gt;\n\nunsigned seed = std::chrono::system_clock::now().time_since_epoch().count();\nstd::default_random_engine generator(seed);\nstd::uniform_int_distribution&lt;int&gt; distribution(1, 100);\n\nint random_number = distribution(generator);  // More robust randomization\n</code></pre>"},{"location":"AR250422/#interview-questions-and-exercises","title":"Interview Questions and Exercises","text":"<p>Here are some common interview questions related to C++ inheritance, with answers based on the material covered:</p> <p>Q: What's the order of constructor and destructor calls in inheritance? A: Constructors execute from base to derived. Destructors execute from derived to base.</p> <p>Q: What happens if a derived class allocates memory but doesn't define a destructor? A: Memory leaks may occur if the derived class allocates resources but doesn't clean them up in its destructor.</p> <p>Q: Why use protected instead of private? A: Protected members allow access from derived classes while still hiding them from external code. Private members are inaccessible to derived classes.</p> <p>Q: Can derived constructors initialize base members directly? A: No, derived constructors must use the initialization list to call base constructors for initializing base class members.</p> <p>Q: What's the purpose of a virtual destructor? A: Virtual destructors ensure that the proper destructor chain is called when deleting a derived object through a base class pointer.</p>"},{"location":"AR250422/#common-mistakes-and-pitfalls","title":"Common Mistakes and Pitfalls","text":"<ol> <li> <p>Forgetting virtual destructors in polymorphic base classes    <pre><code>class Base {\npublic:\n    virtual ~Base() {}  // Required for proper cleanup\n};\n</code></pre></p> </li> <li> <p>Attempting to access private base members from derived classes</p> </li> <li> <p>Only protected or public members are accessible to derived classes</p> </li> <li> <p>Leaking memory by skipping cleanup</p> </li> <li>Always match each <code>new[]</code> with a corresponding <code>delete[]</code></li> <li> <p>Each allocation in a constructor should have a corresponding deallocation in the destructor</p> </li> <li> <p>Incorrect copy constructor implementation</p> </li> <li>Not calling the base class copy constructor</li> <li> <p>Performing shallow copies of pointer members</p> </li> <li> <p>Improperly initializing base class members</p> </li> <li>Base class members must be initialized through base class constructors</li> <li>Derived class constructors cannot directly initialize base class members in their initialization lists</li> </ol>"},{"location":"AR250422/#practice-exercises","title":"Practice Exercises","text":"<p>1. Spot the Bug: Copy Constructor What's wrong with this implementation? <pre><code>CChild(const CChild&amp; other)\n    : m_F(other.m_F), m_pFloatData(new float[1000]) {}\n</code></pre> Hint: Did you initialize the base class properly?</p> <p>2. Lifecycle Challenge Given the class structure, explain the order of construction and destruction in this code: <pre><code>CChild child1;\n</code></pre> Write down the sequence and verify your answer.</p> <p>3. Manual Memory Cleanup Modify the following class to prevent memory leaks: <pre><code>class Buggy {\n    int* data;\npublic:\n    Buggy() { data = new int[10]; }\n    // No destructor!\n};\n</code></pre></p>"},{"location":"AR250422/#visual-object-lifetime-in-inheritance","title":"Visual: Object Lifetime in Inheritance","text":"<pre><code>Construction:\nCParent() -&gt; CChild()\n\nDestruction:\n~CChild() -&gt; ~CParent()\n</code></pre> <p>Understanding this sequence is crucial for managing resources and preventing undefined behavior in C++ inheritance hierarchies.</p>"},{"location":"AR250422/#further-reading","title":"Further Reading","text":"<p>To deepen your understanding of C++ inheritance and its application in game development, check out the following resources:</p> <ul> <li>C++ Inheritance - cppreference.com</li> <li>Effective C++ by Scott Meyers</li> <li>Unreal Engine C++ Documentation</li> <li>Game Developer Conference (GDC) Talks</li> <li>Herb Sutter: C++ and Beyond</li> </ul> <p>These resources are invaluable for advanced understanding and staying current with best practices in modern C++ and game engine development.</p>"},{"location":"AR250423/","title":"Inheritance, Polymorphism, Virtual Functions, Overriding","text":"<p>Last updated: April 23, 2025</p> <p>This comprehensive guide explores advanced inheritance concepts in C++, focusing on polymorphism, virtual functions, and function overriding. These concepts are crucial for game programmers to master, as they form the foundation of object-oriented game architecture.</p>"},{"location":"AR250423/#function-overriding-vs-overloading","title":"Function Overriding vs. Overloading","text":"<p>These are two different concepts that are often confused but serve distinct purposes in C++.</p>"},{"location":"AR250423/#function-overriding","title":"Function Overriding","text":"<p>Function overriding occurs when a derived class redefines a function that already exists in its base class, using the same function signature (name and parameters). The purpose is to provide a specialized implementation for an inherited method.</p> <p>Key characteristics of function overriding: - Requires inheritance relationship between classes - Same function name and parameter list - Occurs between base and derived classes - Base class function can still be accessed explicitly</p> <p>Example of function overriding:</p> <pre><code>class Base {\npublic:\n    void Output() {\n        cout &lt;&lt; \"Base Class\" &lt;&lt; endl;\n    }\n};\n\nclass Child : public Base {\npublic:\n    void Output() {  // Overrides Base::Output()\n        cout &lt;&lt; \"Child Class\" &lt;&lt; endl;\n    }\n};\n</code></pre> <p>When we create a <code>Child</code> object and call <code>Output()</code>, the child's version is called by default. However, we can still access the parent's version when needed:</p> <pre><code>Child child;\nchild.Output();       // Calls Child::Output()\nchild.Base::Output(); // Explicitly calls Base::Output()\n</code></pre>"},{"location":"AR250423/#function-overloading","title":"Function Overloading","text":"<p>Function overloading occurs when multiple functions in the same scope have the same name but different parameter lists. The compiler determines which function to call based on the arguments provided.</p> <p>Example of function overloading:</p> <pre><code>class MyClass {\npublic:\n    void Func();                // Version with no parameters\n    void Func(int input);       // Version with one int parameter\n    void Func(int input1, int input2); // Version with two int parameters\n};\n</code></pre> <p>The key difference: overriding is about providing different implementations of the same function in an inheritance hierarchy, while overloading is about providing multiple functions with the same name but different parameters in the same scope.</p>"},{"location":"AR250423/#polymorphism-in-c","title":"Polymorphism in C++","text":"<p>Polymorphism is one of the core principles of object-oriented programming. In C++, it allows us to treat objects of derived classes as objects of their base class, while still maintaining their unique behaviors.</p>"},{"location":"AR250423/#pointer-based-polymorphism","title":"Pointer-Based Polymorphism","text":"<p>A key feature of C++ is that a pointer to a base class can point to any object of a derived class:</p> <pre><code>class Parent {\nprivate:\n    float m_P;\n};\n\nclass Child : public Parent {\nprivate:\n    short m_S;\n};\n\nint main() {\n    Parent P;\n    Child C;\n\n    Parent* pParent = &amp;P;  // Parent pointer to Parent object - always works\n    Child* pChild = &amp;C;    // Child pointer to Child object - always works\n\n    pParent = &amp;C;  // Parent pointer to Child object - works due to polymorphism\n    // pChild = &amp;P;  // Child pointer to Parent object - DOES NOT WORK\n\n    return 0;\n}\n</code></pre> <p>This demonstrates that a base class pointer can point to a derived class object, but not vice versa. This is because a derived class object contains all the members of its base class (and potentially more), so a base class pointer can safely access the base class portion of a derived class object.</p>"},{"location":"AR250423/#memory-layout","title":"Memory Layout","text":"<p>Understanding memory layout helps explain why polymorphism works this way:</p> <pre><code>Parent object: [m_P (4 bytes)]\nChild object:  [m_P (4 bytes)][m_S (2 bytes, padded to 4)]\n</code></pre> <p>When <code>pParent = &amp;C</code>, the pointer points to the start of the <code>Child</code> object, which contains the <code>Parent</code> portion. The pointer only \"sees\" the <code>Parent</code> portion of the object, ignoring any additional members that the <code>Child</code> may have.</p>"},{"location":"AR250423/#benefits-of-polymorphism-in-game-programming","title":"Benefits of Polymorphism in Game Programming","text":"<p>In game development, polymorphism allows for elegant design patterns. Consider a game engine with various actor types:</p> <pre><code>class Actor {\npublic:\n    virtual void Tick() { /* Base implementation */ }\n};\n\nclass Player : public Actor {\npublic:\n    virtual void Tick() override { /* Player-specific logic */ }\n};\n\nclass Monster : public Actor {\npublic:\n    virtual void Tick() override { /* Monster-specific logic */ }\n};\n\n// In game level:\nstd::vector&lt;Actor*&gt; gameActors;  // Container for all actors\n</code></pre> <p>With polymorphism, we can store pointers to different derived classes (<code>Player</code>, <code>Monster</code>, etc.) in a single container of base class pointers (<code>Actor*</code>). This simplifies game architecture significantly compared to maintaining separate containers for each type:</p> <pre><code>// Without polymorphism, we would need:\nstd::vector&lt;Player*&gt; players;\nstd::vector&lt;Monster*&gt; monsters;\n// And so on for each type...\n</code></pre>"},{"location":"AR250423/#virtual-functions","title":"Virtual Functions","text":"<p>While polymorphism allows us to use a base class pointer to point to derived class objects, there's a problem: by default, calling a method through a base class pointer will invoke the base class version of that method, even if the derived class has overridden it.</p>"},{"location":"AR250423/#the-polymorphism-problem","title":"The Polymorphism Problem","text":"<pre><code>class Parent {\npublic:\n    void Move() {\n        cout &lt;&lt; \"!!Parent Move!!\" &lt;&lt; endl;\n    }\n};\n\nclass Child : public Parent {\npublic:\n    void Move() {\n        cout &lt;&lt; \"!!Child Move!!\" &lt;&lt; endl;\n    }\n};\n\nint main() {\n    Parent P;\n    Child C;\n\n    Parent* pParent = &amp;P;\n    pParent-&gt;Move();  // Calls Parent::Move() - expected\n\n    pParent = &amp;C;\n    pParent-&gt;Move();  // Still calls Parent::Move() - NOT what we want!\n\n    return 0;\n}\n</code></pre> <p>This behavior occurs because the compiler performs static binding at compile time based on the pointer type, not the object type. For game engines that rely on polymorphism, this is problematic.</p>"},{"location":"AR250423/#virtual-functions-to-the-rescue","title":"Virtual Functions to the Rescue","text":"<p>The <code>virtual</code> keyword changes this behavior by enabling dynamic binding, where the function call is resolved at runtime based on the actual object type:</p> <pre><code>class Parent {\npublic:\n    virtual void Move() {\n        cout &lt;&lt; \"!!Parent Move!!\" &lt;&lt; endl;\n    }\n};\n\nclass Child : public Parent {\npublic:\n    void Move() override {  // 'override' keyword is optional but recommended\n        cout &lt;&lt; \"!!Child Move!!\" &lt;&lt; endl;\n    }\n};\n\nint main() {\n    Parent P;\n    Child C;\n\n    Parent* pParent = &amp;P;\n    pParent-&gt;Move();  // Calls Parent::Move()\n\n    pParent = &amp;C;\n    pParent-&gt;Move();  // Now calls Child::Move() - correct polymorphic behavior!\n\n    return 0;\n}\n</code></pre> <p>The <code>virtual</code> keyword tells the compiler to look up the function implementation at runtime rather than compile time, ensuring that the overridden version in the derived class is called.</p>"},{"location":"AR250423/#memory-layout-and-virtual-function-tables","title":"Memory Layout and Virtual Function Tables","text":"<p>Understanding how virtual functions work requires delving into the C++ object memory layout.</p>"},{"location":"AR250423/#virtual-function-tables-vtables","title":"Virtual Function Tables (VTables)","text":"<p>When a class contains at least one virtual function, the compiler creates a special data structure called a virtual function table (VTable) for that class:</p> <ol> <li>Each class with virtual functions gets its own VTable</li> <li>The VTable contains function pointers to the actual implementations</li> <li>Each object of the class stores a hidden pointer (often called <code>__vfptr</code>) to its class's VTable</li> </ol> <p>This explains why classes with virtual functions often have a larger memory footprint:</p> <pre><code>class NoVirtual {\n    float m_Value;  // 4 bytes\n};  // sizeof(NoVirtual) = 4 bytes\n\nclass WithVirtual {\n    float m_Value;  // 4 bytes\n    // Plus hidden vptr (8 bytes on x64)\n    virtual void SomeFunc() {}\n};  // sizeof(WithVirtual) = 16 bytes (with padding)\n</code></pre>"},{"location":"AR250423/#how-virtual-function-dispatch-works","title":"How Virtual Function Dispatch Works","text":"<p>When calling a virtual function through a pointer or reference:</p> <ol> <li>The compiler generates code to access the object's <code>__vfptr</code></li> <li>The code looks up the appropriate function in the VTable (each virtual function has an index)</li> <li>The function at that index is called</li> </ol> <p>This runtime lookup allows the correct overridden method to be called regardless of the pointer type.</p>"},{"location":"AR250423/#vtable-inheritance","title":"VTable Inheritance","text":"<p>In an inheritance hierarchy:</p> <ol> <li>A derived class inherits the VTable structure from its base class</li> <li>When a derived class overrides a virtual function, its VTable entry is updated to point to the derived implementation</li> <li>When a derived class doesn't override a virtual function, its VTable entry points to the base class implementation</li> </ol> <p>This mechanism enables the correct function to be called based on the actual object type at runtime.</p>"},{"location":"AR250423/#copy-constructor-in-inheritance","title":"Copy Constructor in Inheritance","text":"<p>When working with inheritance, proper implementation of copy constructors is critical to ensure that the entire object, including the base class portion, is correctly copied.</p>"},{"location":"AR250423/#the-default-copy-constructor-problem","title":"The Default Copy Constructor Problem","text":"<p>By default, if you don't define a copy constructor in a derived class, the compiler generates one that:</p> <ol> <li>Calls the base class's default constructor (not its copy constructor)</li> <li>Makes member-by-member copies of the derived class's own members</li> </ol> <p>This can lead to incomplete copying of objects:</p> <pre><code>class Base {\npublic:\n    int m_a;\n    float m_f;\n\n    Base() : m_a(0), m_f(0.f) {}\n\n    Base(const Base&amp; other) \n        : m_a(other.m_a), m_f(other.m_f) {}\n};\n\nclass Child : public Base {\npublic:\n    long long m_Child;\n\n    Child() : m_Child(0) {}\n\n    // Incorrect (automatic) copy constructor:\n    // Child(const Child&amp; other) : Base(), m_Child(other.m_Child) {}\n};\n</code></pre> <p>In this example, the automatic copy constructor would initialize the <code>Base</code> portion using the default constructor, losing the values from the original <code>Base</code> portion.</p>"},{"location":"AR250423/#correctly-implementing-copy-constructors","title":"Correctly Implementing Copy Constructors","text":"<p>To properly implement a copy constructor in a derived class, explicitly call the base class's copy constructor:</p> <pre><code>class Child : public Base {\npublic:\n    long long m_Child;\n\n    Child() : m_Child(0) {}\n\n    // Correct copy constructor:\n    Child(const Child&amp; other)\n        : Base(other),  // Call base copy constructor with the other object\n          m_Child(other.m_Child) {}\n};\n</code></pre> <p>This ensures that both the base and derived portions of the object are properly copied.</p>"},{"location":"AR250423/#practical-examples","title":"Practical Examples","text":"<p>Let's examine a complete implementation demonstrating polymorphism and virtual functions:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass Parent {\nprivate:\n    float m_P;\n\npublic:\n    virtual void Move() {\n        cout &lt;&lt; \"!!Parent Move!!\" &lt;&lt; endl;\n    }\n\n    virtual void Test() {\n        // Base implementation\n    }\n};\n\nclass Child : public Parent {\nprivate:\n    short m_S;\n\npublic:\n    void Move() override {\n        cout &lt;&lt; \"!!Child Move!!\" &lt;&lt; endl;\n    }\n\n    void Test() override {\n        // Child implementation\n    }\n};\n\nint main() {\n    Parent P;\n    Child C;\n\n    // Size affected by virtual function table pointer\n    int size = sizeof(P);  // Larger than just float due to __vfptr\n    size = sizeof(C);      // Even larger - includes parent + own members + __vfptr\n\n    Parent* pParent = &amp;P;\n    Child* pChild = &amp;C;\n\n    // Polymorphism allows this\n    pParent = &amp;C;  // Parent pointer to Child object\n\n    // Virtual function ensures proper dispatch\n    pParent-&gt;Move();  // Calls Child::Move() due to virtual function\n    pParent-&gt;Test();  // Calls Child::Test() due to virtual function\n\n    return 0;\n}\n</code></pre> <p>And here's an example of proper copy constructor implementation:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass Base {\npublic:\n    int m_a;\n    float m_f;\n\npublic:\n    Base() : m_a(0), m_f(0.f) {}\n\n    Base(const Base&amp; other)\n        : m_a(other.m_a), m_f(other.m_f) {}\n};\n\nclass Child : public Base {\npublic:\n    long long m_Child;\n\npublic:\n    Child() : m_Child(0) {}\n\n    // Proper copy constructor implementation\n    Child(const Child&amp; other)\n        : Base(other),  // Call base copy constructor\n          m_Child(other.m_Child) {}\n};\n\nint main() {\n    Base b1;\n    b1.m_a = 10;\n    b1.m_f = 3.33f;\n\n    Base b2 = b1;  // Uses Base copy constructor\n\n    Child c1;\n    c1.m_a = 1;\n    c1.m_f = 2.f;\n    c1.m_Child = 3;\n\n    Child c2(c1);  // Uses our properly implemented Child copy constructor\n                   // Both Base and Child portions are copied correctly\n\n    return 0;\n}\n</code></pre>"},{"location":"AR250423/#interview-questions","title":"Interview Questions","text":"<p>Here are some common interview questions related to inheritance, polymorphism, and virtual functions:</p> <p>Q: What is the difference between function overloading and function overriding? A: Overloading is defining multiple functions with the same name but different parameters in the same scope. Overriding is redefining a virtual function in a derived class with the same signature as in the base class to provide specialized behavior.</p> <p>Q: Why can a base class pointer point to a derived class object but not vice versa? A: A base class pointer can point to a derived class object because the derived class contains all the members of the base class. The reverse isn't possible because a derived class might have additional members that a base class object doesn't contain.</p> <p>Q: How do virtual functions work under the hood? A: Virtual functions work through virtual function tables (VTables). Each class with virtual functions has a VTable containing function pointers. Objects of such classes contain a hidden pointer to their class's VTable. When a virtual function is called, the appropriate function is looked up in the VTable at runtime, enabling dynamic binding.</p> <p>Q: What's the difference between calling a virtual function and a non-virtual function through a base class pointer? A: When calling a non-virtual function through a base class pointer, the function called is determined by the pointer type at compile time (static binding). For virtual functions, the function called is determined by the actual object type at runtime (dynamic binding).</p> <p>Q: Why should base class destructors be virtual in polymorphic code? A: If a derived class object is deleted through a base class pointer and the destructor isn't virtual, only the base class destructor will be called, potentially leading to resource leaks. Making the destructor virtual ensures that the proper destructor chain is called.</p> <p>Q: What happens in the default copy constructor of a derived class? A: The default copy constructor of a derived class calls the default constructor (not the copy constructor) of the base class and then copies the derived class's members. This often leads to incomplete copying of the object.</p> <p>Q: How do you correctly implement a copy constructor in a derived class? A: By explicitly calling the base class's copy constructor in the initialization list and then handling the derived class's members: <code>Derived(const Derived&amp; other) : Base(other), /* derived members */ {}</code>.</p> <p>Understanding these advanced C++ inheritance concepts is essential for game programmers who need to create flexible, maintainable game architectures. Virtual functions and polymorphism are particularly important in game engines, where they enable systems that can process many different types of game objects without needing to know their specific types.</p>"},{"location":"AR250424/","title":"Virtual Function Override, Static and const","text":""},{"location":"AR250424/#date-2025-04-24","title":"Date: 2025-04-24","text":""},{"location":"AR250424/#key-points","title":"Key Points","text":"<ul> <li>Polymorphism allows one interface to represent different underlying types</li> <li>Virtual functions enable runtime binding of function calls to the correct implementation</li> <li>The <code>override</code> keyword ensures correct method overriding in derived classes</li> <li>Pure virtual functions and abstract classes define interfaces that derived classes must implement</li> <li>Const member functions guarantee they won't modify object state</li> <li>Static variables and functions provide class-wide storage and functionality</li> <li>Static member variables are shared across all instances of a class</li> </ul>"},{"location":"AR250424/#polymorphism-and-virtual-functions","title":"Polymorphism and Virtual Functions","text":"<p>Polymorphism is a core concept in object-oriented programming that allows us to treat objects of derived classes as objects of a base class. This enables writing more flexible and maintainable code, especially in game development where entity hierarchies are common.</p>"},{"location":"AR250424/#the-basics-of-polymorphism","title":"The Basics of Polymorphism","text":"<p>Polymorphism in C++ depends on three key elements: 1. Inheritance  2. Pointers/references to base classes 3. Virtual functions</p> <pre><code>class Parent {\npublic:\n    virtual void Move() {\n        std::cout &lt;&lt; \"!!Parent Move!!\" &lt;&lt; std::endl;\n    }\n\n    virtual void Test() {\n        std::cout &lt;&lt; \"!!Parent Test!!\" &lt;&lt; std::endl;\n    }\n\n    // Pure virtual function\n    virtual void Fly() = 0;\n};\n\nclass Child : public Parent {\nprivate:\n    short m_S;\n\npublic:\n    virtual void Move() override {\n        std::cout &lt;&lt; \"!!Child Move!!\" &lt;&lt; std::endl;\n    }\n\n    virtual void SetShort(short _Short) {\n        m_S = _Short;\n    }\n};\n</code></pre> <p>A key property of polymorphism is that a parent class pointer can point to a child class object, but not vice versa:</p> <pre><code>Parent* pParent = &amp;C;  // Valid: Parent pointer can point to Child object\n// Child* pChild = &amp;P;  // Invalid: Child pointer cannot point to Parent object\n</code></pre> <p>This is because a parent pointer can only access the parent's portion of the child object. Since every child object contains a complete parent object as its first portion, a parent pointer can safely point to a child object.</p>"},{"location":"AR250424/#virtual-function-mechanism","title":"Virtual Function Mechanism","text":"<p>Without virtual functions, a significant issue arises: when calling a method through a base class pointer, the compiler would always call the base class version of the method, regardless of the actual object type. This is called static binding.</p> <p>Virtual functions solve this problem by implementing dynamic binding (runtime binding). When a function is declared as <code>virtual</code>, the compiler creates a special mechanism that determines the correct function to call based on the actual object type at runtime.</p> <pre><code>Parent P;\nChild C;\nParent* pParent;\n\npParent = &amp;P;\npParent-&gt;Move();  // Calls Parent::Move()\n\npParent = &amp;C;\npParent-&gt;Move();  // Calls Child::Move() because of virtual function mechanism\n</code></pre>"},{"location":"AR250424/#virtual-function-table-vtable","title":"Virtual Function Table (VTable)","text":"<p>When a class has virtual functions, the compiler creates a hidden structure called a virtual function table (VTable) for that class. Each class with virtual functions gets its own VTable containing function pointers to its virtual methods.</p> <p>Additionally, every object of a class with virtual functions contains a hidden pointer (often called <code>__vfptr</code> or virtual function table pointer) that points to the VTable for its class.</p> <p>During runtime, when a virtual function is called through a base class pointer, the system: 1. Accesses the object's <code>__vfptr</code> to locate its VTable 2. Looks up the appropriate function pointer in the VTable 3. Calls the function corresponding to the actual object type</p> <p>This behind-the-scenes mechanism enables polymorphic behavior where the correct version of an overridden function is called based on the actual object type.</p>"},{"location":"AR250424/#the-override-keyword","title":"The Override Keyword","text":"<p>The <code>override</code> keyword, introduced in C++11, helps prevent errors by explicitly declaring that a function is intended to override a virtual function from a base class:</p> <pre><code>virtual void Move() override {\n    std::cout &lt;&lt; \"!!Child Move!!\" &lt;&lt; std::endl;\n}\n</code></pre> <p>Using <code>override</code> provides two key benefits: 1. It clearly communicates intent to readers of the code 2. The compiler will generate an error if the function doesn't actually override a virtual function from the base class</p> <p>While <code>override</code> is technically optional, using it is considered a best practice that helps catch errors early.</p>"},{"location":"AR250424/#pure-virtual-functions-and-abstract-classes","title":"Pure Virtual Functions and Abstract Classes","text":""},{"location":"AR250424/#pure-virtual-functions","title":"Pure Virtual Functions","text":"<p>A pure virtual function is a virtual function that has no implementation in the base class and must be implemented by any concrete derived class:</p> <pre><code>// Pure virtual function declaration\nvirtual void Fly() = 0;\n</code></pre> <p>The <code>= 0</code> syntax marks a function as pure virtual, indicating: 1. The function has no implementation in this class 2. Derived classes must provide an implementation (unless they also want to be abstract) 3. The class containing the pure virtual function cannot be instantiated directly</p>"},{"location":"AR250424/#abstract-classes","title":"Abstract Classes","text":"<p>A class with at least one pure virtual function is called an abstract class. Abstract classes:</p> <ul> <li>Cannot be instantiated directly</li> <li>Serve as interfaces that derived classes must implement</li> <li>Define a common interface for a family of classes</li> </ul> <p>Abstract classes are particularly useful in game development for creating entity hierarchies. For example, a <code>GameObject</code> abstract class might define pure virtual functions like <code>Update()</code> and <code>Render()</code> that all game objects must implement.</p> <pre><code>// Abstract class (cannot be instantiated)\nclass GameObject {\npublic:\n    virtual void Update(float deltaTime) = 0;\n    virtual void Render() = 0;\n    virtual ~GameObject() {}\n};\n\n// Concrete class (can be instantiated)\nclass Player : public GameObject {\npublic:\n    void Update(float deltaTime) override {\n        // Implementation\n    }\n\n    void Render() override {\n        // Implementation\n    }\n};\n</code></pre> <p>If a derived class doesn't implement all pure virtual functions from its base class, it remains abstract and cannot be instantiated.</p>"},{"location":"AR250424/#const-member-variables-and-functions","title":"Const Member Variables and Functions","text":""},{"location":"AR250424/#const-member-variables","title":"Const Member Variables","text":"<p>Const member variables are variables whose values cannot be changed after initialization. They must be initialized in the constructor's initializer list, as they cannot be assigned values in the constructor body:</p> <pre><code>class CMyClass {\nprivate:\n    int m_i;\n    const char m_C;\n\npublic:\n    CMyClass()\n        : m_i(0)\n        , m_C(100)  // Const member must be initialized here\n    {\n        m_i = 10;   // This is fine\n        // m_C = 200;  // ERROR: Cannot modify const member\n    }\n};\n</code></pre> <p>Const member variables help enforce immutability within a class and catch potential errors at compile time.</p>"},{"location":"AR250424/#const-member-functions","title":"Const Member Functions","text":"<p>A const member function is a function that guarantees it won't modify the state of the object on which it's called. These functions are declared with the <code>const</code> keyword after the parameter list:</p> <pre><code>class CMyClass {\nprivate:\n    int m_i;\n    const char m_C;\n\npublic:\n    void SetIntData(int _Data) {\n        m_i = _Data;  // Modifies the object\n    }\n\n    // Const member function guarantees it won't modify the object\n    int GetIntData() const {\n        return m_i;\n        // m_i = 100;  // ERROR: Cannot modify member in const function\n    }\n\n    char GetCharData() const {\n        return m_C;\n    }\n};\n</code></pre> <p>Const member functions are important for: 1. Documenting and enforcing which functions don't modify the object 2. Allowing functions to be called on const objects 3. Preventing accidental modifications</p>"},{"location":"AR250424/#const-pointers-to-objects","title":"Const Pointers to Objects","text":"<p>When using a const pointer to an object, only const member functions can be called on that object:</p> <pre><code>const CMyClass* pMy = &amp;c;\npMy-&gt;GetIntData();    // OK: const function can be called\n// pMy-&gt;SetIntData(100);  // ERROR: non-const function cannot be called on const object\n</code></pre> <p>This provides another layer of safety by ensuring that objects aren't modified through specific pointers.</p>"},{"location":"AR250424/#static-variables-and-functions","title":"Static Variables and Functions","text":""},{"location":"AR250424/#static-variables-in-functions","title":"Static Variables in Functions","text":"<p>Static variables declared inside a function retain their values between function calls. They're initialized only once when the function is first called and persist for the program's lifetime:</p> <pre><code>int* StaticFunc() {\n    static int iStatic = 0;  // Initialized only once, on first function call\n    iStatic = 100;\n    return &amp;iStatic;  // Safe to return address of static variable\n}\n\nint main() {\n    int* pStatic = StaticFunc();  // iStatic becomes 100\n    *pStatic = 300;               // Modifies iStatic to 300\n    StaticFunc();                 // Returns the address of iStatic (still 300)\n}\n</code></pre> <p>Static variables in functions are stored in the data segment of memory rather than the stack, making them accessible throughout the program's lifetime.</p>"},{"location":"AR250424/#static-global-variables","title":"Static Global Variables","text":"<p>When a global variable is declared as static, its scope is limited to the file in which it's declared:</p> <pre><code>// In file1.cpp\nstatic int g_static = 0;  // Only accessible within file1.cpp\n\n// In file2.cpp\nstatic int g_static = 10;  // Different variable, only accessible within file2.cpp\n</code></pre> <p>This file-level encapsulation helps prevent naming conflicts between different source files.</p>"},{"location":"AR250424/#static-member-variables","title":"Static Member Variables","text":"<p>Static member variables belong to the class itself, not to any specific instance:</p> <pre><code>class CTestClass {\npublic:\n    static int m_StaticMember;  // Declaration only\nprivate:\n    int m_Member;\n\npublic:\n    CTestClass() : m_Member(0) {\n        m_StaticMember = 20;  // Accessible from any instance\n    }\n};\n\n// Definition required in a source file\nint CTestClass::m_StaticMember = 0;\n</code></pre> <p>Key characteristics of static member variables: 1. Only one copy exists for the entire class, shared among all instances 2. They must be defined outside the class definition (typically in a .cpp file) 3. They're not part of the object's memory layout 4. They follow the class's access control rules (private, protected, public)</p> <pre><code>int main() {\n    CTestClass inst;\n    CTestClass inst1;\n    CTestClass inst2;\n\n    inst.m_StaticMember = 10;    // All instances share the same static member\n    inst1.m_StaticMember = 20;   // Changes the value for all instances\n    inst2.m_StaticMember = 30;   // Changes the value for all instances\n\n    CTestClass::m_StaticMember = 40;  // Can access without an instance if public\n}\n</code></pre>"},{"location":"AR250424/#static-member-functions","title":"Static Member Functions","text":"<p>Static member functions belong to the class itself, not to any specific instance. They can be called without creating an object:</p> <pre><code>class CTest {\nprivate:\n    static int m_Static;\n    int m_i;\n\npublic:\n    void SetData(int _Data) {\n        this-&gt;m_i = _Data;    // Can access instance members\n        m_Static = 20;        // Can access static members\n    }\n\n    // Static member function - no 'this' pointer\n    static void StaticFunc() {\n        m_Static = 100;       // Can access static members\n        // m_i = 10;          // ERROR: Cannot access instance members\n    }\n};\n\nint CTest::m_Static = 0;  // Definition required in a source file\n\nint main() {\n    CTest::StaticFunc();  // Call without creating an object\n\n    CTest t1;\n    t1.StaticFunc();      // Can also call through an instance, but discouraged\n}\n</code></pre> <p>Key characteristics of static member functions: 1. They don't have a <code>this</code> pointer 2. They cannot access non-static member variables or call non-static member functions 3. They can access static member variables, including private ones 4. They can be called without creating an instance of the class</p>"},{"location":"AR250424/#static-member-functions-vs-global-functions","title":"Static Member Functions vs. Global Functions","text":"<p>Static member functions differ from global functions in several ways: 1. Static member functions are part of the class's scope and can access its private static members 2. They provide namespace functionality while maintaining the class's access control 3. They make the code more organized by grouping class-related functionality</p> <pre><code>// Global function cannot access private static members\nvoid GlobalFunc() {\n    // CTest::m_Static = 100;  // ERROR: Cannot access private member\n}\n</code></pre>"},{"location":"AR250424/#visual-memory-layout","title":"Visual: Memory Layout","text":"<pre><code>Instance Variables vs. Static Variables\n--------------------------------------\n\nClass CTest {\n    static int m_Static;  // One copy in data segment\n    int m_i;             // One copy per instance\n};\n\nMemory Layout:\n-------------\nData Segment:         Heap/Stack:\n+------------+        +-----------+\n| m_Static=0 |        | Object t1 |\n+------------+        | m_i=100   |\n                      +-----------+\n                      | Object t2 |\n                      | m_i=200   |\n                      +-----------+\n                      | Object t3 |\n                      | m_i=300   |\n                      +-----------+\n\nWhen static member is modified:\nCTest::m_Static = 50;\n\nUpdated Memory:\n-------------\nData Segment:         Heap/Stack:\n+------------+        +-----------+\n| m_Static=50|        | Object t1 |\n+------------+        | m_i=100   |\n                      +-----------+\n                      | Object t2 |\n                      | m_i=200   |\n                      +-----------+\n                      | Object t3 |\n                      | m_i=300   |\n                      +-----------+\n</code></pre>"},{"location":"AR250424/#tricky-case-virtual-function-tables","title":"Tricky Case: Virtual Function Tables","text":"<p>One of the trickiest aspects of virtual functions is understanding how they affect object size and memory layout. Consider:</p> <pre><code>class Parent {\n    float m_P;\npublic:\n    virtual void Move();\n};\n\nclass Child : public Parent {\n    short m_S;\npublic:\n    virtual void Move() override;\n};\n</code></pre> <p>The <code>sizeof(Parent)</code> will be greater than just the size of a <code>float</code> because the compiler adds a hidden virtual function table pointer (<code>__vfptr</code>). Similarly, the size of <code>Child</code> includes the <code>Parent</code> part, the <code>short</code> member, and potentially its own virtual function information.</p> <p>When a parent class pointer points to a child object, the virtual function mechanism allows the correct overridden function to be called:</p> <pre><code>Parent* pParent = &amp;childObject;\npParent-&gt;Move();  // Calls Child::Move(), not Parent::Move()\n</code></pre>"},{"location":"AR250424/#common-mistakes","title":"Common Mistakes","text":""},{"location":"AR250424/#forgetting-to-mark-overridden-functions-as-virtual","title":"Forgetting to Mark Overridden Functions as Virtual","text":"<p>If a base class function isn't marked as <code>virtual</code>, derived classes can still redefine it, but polymorphism won't work:</p> <pre><code>class Base {\npublic:\n    void NonVirtualFunc() { /* ... */ }  // Not virtual\n};\n\nclass Derived : public Base {\npublic:\n    void NonVirtualFunc() { /* ... */ }  // Redefines but doesn't override\n};\n\n// Later:\nBase* ptr = new Derived();\nptr-&gt;NonVirtualFunc();  // Calls Base::NonVirtualFunc(), not Derived::NonVirtualFunc()\n</code></pre>"},{"location":"AR250424/#not-understanding-when-objects-are-sliced","title":"Not Understanding When Objects Are Sliced","text":"<p>When a derived class object is assigned to a base class object (not a pointer or reference), the derived part is \"sliced off\":</p> <pre><code>Child childObj;\nParent parentObj = childObj;  // Object slicing: derived parts are lost\nparentObj.Move();  // Always calls Parent::Move()\n</code></pre>"},{"location":"AR250424/#misusing-static-member-variables","title":"Misusing Static Member Variables","text":"<p>A common mistake is treating static member variables as if they belonged to individual instances:</p> <pre><code>CTest::m_Static = 0;\nCTest t1, t2;\n\nt1.SetData(100);  // Sets m_Static to 20\nt2.SetData(200);  // Sets m_Static to 20 again\n\n// Now m_Static is 20 for ALL instances, not just t2\n</code></pre>"},{"location":"AR250424/#interview-questions","title":"Interview Questions","text":"<p>Q: What is the difference between function overloading and function overriding? A: Function overloading refers to defining multiple functions with the same name but different parameters within the same scope. Function overriding happens when a derived class provides a new implementation for a virtual function that was already defined in the base class.</p> <p>Q: What happens if a derived class doesn't override all pure virtual functions from its base class? A: The derived class also becomes an abstract class and cannot be instantiated.</p> <p>Q: What is the purpose of the <code>override</code> keyword? A: The <code>override</code> keyword explicitly indicates that a function is intended to override a virtual function from a base class. It helps catch errors at compile time if the function signature doesn't match any virtual function in the base class.</p> <p>Q: What's the difference between a static member function and a global function? A: A static member function is part of a class's scope and can access the class's private static members. A global function isn't associated with any class and can only access public members.</p> <p>Q: Why must static member variables be defined outside the class definition? A: Static member variables are shared by all instances of a class and must exist even if no instances are created. The class definition only declares the variable, while the definition outside the class allocates memory for it.</p> <p>Q: What happens when a const object calls a non-const member function? A: It results in a compile error because non-const member functions don't guarantee they won't modify the object, which violates the const contract.</p> <p>Q: How do virtual functions affect the memory layout of an object? A: Classes with virtual functions contain an additional hidden pointer (<code>__vfptr</code>) that points to the virtual function table (vtable) for that class. This increases the size of the object.</p> <p>Q: What is object slicing and when does it occur? A: Object slicing occurs when a derived class object is assigned to a base class object (not a pointer or reference). Only the base class portion of the derived object is copied, while the derived class-specific members are \"sliced off.\"</p> <p>Q: What is the purpose of a pure virtual function? A: Pure virtual functions define an interface that derived classes must implement. They also make the class abstract, preventing direct instantiation.</p> <p>Q: How would you implement a singleton pattern using static members? A: A singleton can be implemented using a private static member to hold the single instance, along with a public static function to access it.</p>"},{"location":"AR250424/#code-demonstration","title":"Code Demonstration","text":""},{"location":"AR250424/#polymorphism-in-action","title":"Polymorphism in Action","text":"<pre><code>#include &lt;iostream&gt;\n\nclass Enemy {\npublic:\n    virtual void Attack() {\n        std::cout &lt;&lt; \"Generic enemy attack!\" &lt;&lt; std::endl;\n    }\n\n    virtual void TakeDamage(int amount) {\n        std::cout &lt;&lt; \"Enemy takes \" &lt;&lt; amount &lt;&lt; \" damage\" &lt;&lt; std::endl;\n    }\n};\n\nclass Orc : public Enemy {\npublic:\n    void Attack() override {\n        std::cout &lt;&lt; \"Orc swings axe!\" &lt;&lt; std::endl;\n    }\n};\n\nclass Dragon : public Enemy {\npublic:\n    void Attack() override {\n        std::cout &lt;&lt; \"Dragon breathes fire!\" &lt;&lt; std::endl;\n    }\n\n    void TakeDamage(int amount) override {\n        std::cout &lt;&lt; \"Dragon takes \" &lt;&lt; amount/2 &lt;&lt; \" damage (50% resistance)\" &lt;&lt; std::endl;\n    }\n};\n\n// Game function that works with any Enemy type\nvoid ProcessEnemy(Enemy* enemy) {\n    enemy-&gt;Attack();\n    enemy-&gt;TakeDamage(10);\n}\n\nint main() {\n    Enemy* enemies[3];\n    enemies[0] = new Enemy();\n    enemies[1] = new Orc();\n    enemies[2] = new Dragon();\n\n    for (int i = 0; i &lt; 3; i++) {\n        ProcessEnemy(enemies[i]);\n    }\n\n    // Clean up\n    for (int i = 0; i &lt; 3; i++) {\n        delete enemies[i];\n    }\n\n    return 0;\n}\n</code></pre> <p>Output: <pre><code>Generic enemy attack!\nEnemy takes 10 damage\nOrc swings axe!\nEnemy takes 10 damage\nDragon breathes fire!\nDragon takes 5 damage (50% resistance)\n</code></pre></p> <p>This demonstrates polymorphism in action with virtual functions being dynamically bound at runtime.</p>"},{"location":"AR250424/#modern-c-considerations","title":"Modern C++ Considerations","text":""},{"location":"AR250424/#using-override-to-catch-errors","title":"Using <code>override</code> to Catch Errors","text":"<pre><code>class Base {\npublic:\n    virtual void Function(int x) { /* ... */ }\n};\n\nclass Derived : public Base {\npublic:\n    void Function(float x) override { /* ... */ }  // Compile error: doesn't override base method\n    void Function(int x) override { /* ... */ }    // Correct\n};\n</code></pre>"},{"location":"AR250424/#using-final-to-prevent-further-overriding","title":"Using <code>final</code> to Prevent Further Overriding","text":"<pre><code>class Base {\npublic:\n    virtual void Function() { /* ... */ }\n};\n\nclass Derived : public Base {\npublic:\n    void Function() override final { /* ... */ }  // Cannot be overridden by further derived classes\n};\n</code></pre>"},{"location":"AR250424/#smart-pointers-and-polymorphism","title":"Smart Pointers and Polymorphism","text":"<pre><code>#include &lt;memory&gt;\n#include &lt;vector&gt;\n\nint main() {\n    std::vector&lt;std::unique_ptr&lt;Enemy&gt;&gt; enemies;\n\n    enemies.push_back(std::make_unique&lt;Enemy&gt;());\n    enemies.push_back(std::make_unique&lt;Orc&gt;());\n    enemies.push_back(std::make_unique&lt;Dragon&gt;());\n\n    for (const auto&amp; enemy : enemies) {\n        enemy-&gt;Attack();  // Polymorphic call\n    }\n\n    // No manual cleanup needed - unique_ptr handles deletion\n    return 0;\n}\n</code></pre> <p>Remember that a solid understanding of these C++ concepts is essential for game programming interviews. The ability to explain how polymorphism works, when to use static members, and how to properly implement const correctness demonstrates a deep understanding of the language and can set you apart as a candidate.</p>"},{"location":"AR250425/","title":"Singleton Design Pattern","text":""},{"location":"AR250425/#introduction-to-the-singleton-pattern","title":"Introduction to the Singleton Pattern","text":"<p>The Singleton design pattern is a creational pattern that restricts the instantiation of a class to a single instance. This pattern is particularly useful when exactly one object is needed to coordinate actions across a system. In game programming, Singleton patterns are often employed for manager or administrator classes that need global access but controlled instantiation.</p>"},{"location":"AR250425/#core-concept","title":"Core Concept","text":"<p>The primary goal of the Singleton pattern is to: - Ensure a class has only one instance - Provide a global point of access to that instance - Control when and how that instance is created</p>"},{"location":"AR250425/#implementation-approaches","title":"Implementation Approaches","text":"<p>There are several ways to implement the Singleton pattern in C++. Let's explore two common approaches.</p>"},{"location":"AR250425/#approach-1-dynamic-allocation-with-static-pointer","title":"Approach 1: Dynamic Allocation with Static Pointer","text":"<p>This approach stores a pointer to the single instance in a static member variable and dynamically allocates memory for the instance.</p>"},{"location":"AR250425/#key-components","title":"Key Components:","text":"<ol> <li>Private Constructor: Prevents external instantiation</li> <li>Static Member Variable: Holds the instance pointer</li> <li>Static Access Method: Returns the instance</li> <li>Destruction Method: Properly cleans up the instance</li> </ol> <p>Let's examine the implementation:</p> <pre><code>// CEngine.h\n#pragma once\n\nclass CEngine\n{\nprivate:\n    // Static member variable - stored in data area, class-specific\n    // Only accessible from static member functions\n    static CEngine* m_This;\n\nprivate:\n    int m_Engine;\n\npublic:\n    // Static member function - can be called without an object\n    // Can access the class's private members\n    static CEngine* GetEngine();\n    static void Destroy();\n\nprivate:\n    // Private constructor prevents external instantiation\n    CEngine();\n\npublic:\n    ~CEngine();\n};\n</code></pre> <pre><code>// CEngine.cpp\n#include \"CEngine.h\"\n\n// Initialize static member\nCEngine* CEngine::m_This = nullptr;\n\nCEngine::CEngine()\n    : m_Engine(0)\n{\n}\n\nCEngine::~CEngine()\n{\n}\n\nCEngine* CEngine::GetEngine()\n{    \n    if (nullptr == m_This)\n    {\n        m_This = new CEngine;\n    }\n\n    return m_This;\n}\n\nvoid CEngine::Destroy()\n{\n    if (nullptr != m_This)\n    {\n        delete m_This;\n        m_This = nullptr;\n    }    \n}\n</code></pre>"},{"location":"AR250425/#usage","title":"Usage:","text":"<pre><code>// Get the singleton instance\nCEngine* pEngine = CEngine::GetEngine();\n\n// Use the instance\n// ...\n\n// Clean up when done\nCEngine::Destroy();\n</code></pre>"},{"location":"AR250425/#approach-2-static-local-variable","title":"Approach 2: Static Local Variable","text":"<p>This approach creates the instance as a static local variable within the access method, leveraging C++'s guarantee that static local variables are initialized only once.</p> <pre><code>// CSingle.h\n#pragma once\n\nclass CSingle\n{\npublic:\n    static CSingle* GetInst();\n\nprivate:\n    CSingle();\n};\n</code></pre> <pre><code>// CSingle.cpp\n#include \"CSingle.h\"\n\nCSingle::CSingle()\n{\n}\n\nCSingle* CSingle::GetInst()\n{\n    static CSingle single;  // Static local variable stays in data area\n    return &amp;single;         // Return address of the static instance\n}\n</code></pre>"},{"location":"AR250425/#usage_1","title":"Usage:","text":"<pre><code>// Get the singleton instance\nCSingle* pSingle = CSingle::GetInst();\n\n// No explicit destruction required\n</code></pre>"},{"location":"AR250425/#memory-management-and-allocation","title":"Memory Management and Allocation","text":"<p>Understanding the memory implications of these two approaches is crucial:</p>"},{"location":"AR250425/#approach-1-dynamic-allocation","title":"Approach 1 (Dynamic Allocation)","text":"<ul> <li>The pointer is stored in the data area (static memory)</li> <li>The actual instance is stored in heap memory</li> <li>Requires explicit destruction to prevent memory leaks</li> <li>More flexible for controlling instance lifetime</li> </ul>"},{"location":"AR250425/#approach-2-static-local-variable_1","title":"Approach 2 (Static Local Variable)","text":"<ul> <li>The entire instance is stored in the data area (static memory)</li> <li>No dynamic memory allocation needed</li> <li>Automatic cleanup at program termination</li> <li>Instance persists for the entire program duration</li> </ul>"},{"location":"AR250425/#common-issues-and-considerations","title":"Common Issues and Considerations","text":""},{"location":"AR250425/#1-memory-efficiency","title":"1. Memory Efficiency","text":"<p>When implementing a Singleton for a class with substantial data members, consider: - Approach 1: Stores only an 8-byte pointer in the data area - Approach 2: Stores the entire object in the data area, potentially less efficient</p>"},{"location":"AR250425/#2-lifetime-control","title":"2. Lifetime Control","text":"<ul> <li>Approach 1: Offers explicit control through the <code>Destroy()</code> method</li> <li>Approach 2: Instance exists until program termination, cannot be manually destroyed</li> </ul>"},{"location":"AR250425/#3-thread-safety","title":"3. Thread Safety","text":"<p>Neither approach shown is thread-safe. For multi-threaded environments, additional synchronization would be needed.</p>"},{"location":"AR250425/#4-memory-leak-prevention","title":"4. Memory Leak Prevention","text":"<p>With the dynamic allocation approach, forgetting to call <code>Destroy()</code> will cause memory leaks. The destruction process needs careful attention:</p> <pre><code>void CEngine::Destroy()\n{\n    if (nullptr != m_This)\n    {\n        delete m_This;    // Delete the dynamically allocated object\n        m_This = nullptr; // Reset the pointer to prevent dangling pointer issues\n    }    \n}\n</code></pre>"},{"location":"AR250425/#best-practices-and-considerations","title":"Best Practices and Considerations","text":""},{"location":"AR250425/#when-to-use-singleton","title":"When to Use Singleton","text":"<ul> <li>When exactly one instance of a class is required</li> <li>When the instance needs controlled access</li> <li>For manager or administrator classes in a game engine</li> </ul>"},{"location":"AR250425/#potential-drawbacks","title":"Potential Drawbacks","text":"<ul> <li>Can make code testing more difficult</li> <li>Creates global state, which may lead to hidden dependencies</li> <li>May cause performance issues due to lack of memory flexibility</li> <li>Can accumulate unused data in long-running programs</li> </ul>"},{"location":"AR250425/#modern-c-alternatives","title":"Modern C++ Alternatives","text":"<ul> <li>Consider using dependency injection instead of Singletons</li> <li>Use static methods without enforcing the Singleton pattern when appropriate</li> <li>Leverage smart pointers for safer memory management</li> </ul>"},{"location":"AR250425/#interview-questions-on-singleton-pattern","title":"Interview Questions on Singleton Pattern","text":"<ol> <li> <p>What is the Singleton design pattern and when would you use it in game development?</p> </li> <li> <p>Compare and contrast the two main approaches to implementing the Singleton pattern.</p> </li> <li> <p>How would you make a Singleton pattern thread-safe?</p> </li> <li> <p>What are the potential drawbacks of using the Singleton pattern?</p> </li> <li> <p>How would you modify the provided implementations to be more memory efficient or safer?</p> </li> </ol>"},{"location":"AR250425/#conclusion","title":"Conclusion","text":"<p>The Singleton pattern, while useful in specific scenarios like manager classes in game engines, comes with trade-offs regarding memory management, flexibility, and code maintainability. Understanding these trade-offs is crucial for effective implementation and for determining when this pattern is appropriate for your specific use case.</p> <p>When preparing for C++ game programming interviews, be ready to discuss not just how to implement the Singleton pattern, but also when it's appropriate to use it and what alternatives might be better in certain scenarios. </p> <p>Windows only structure </p> <p>4 instances input  Windows disadvantages too old From Windows XP </p> <p>Windwows failed to get smartphone market </p> <p>MSFT Windows had unnecessary features  PC OS directly inside the smartphone so not working on mobile phone  iOS and Andriod OS rebuilt the entire OS appropriate to phone </p> <p>Still let old Windows program to work still currently in Windows XP or even before </p> <p>get 4 instances, althouth it is not used right now lol </p> <p>// SAL , comment languages  does nOT affect code but exist for explanation  In HINSTANCE hInstance, // In is comment without meaning  opt .. unnecessary instance  Out // return value existing instance  InOut // Both input has meaning and o;utput is returned _</p> <p>For isntance </p> <p>void Pow(int* Input, int _Pow) { }</p> <p>int Data = 2;  Pow(&amp;Data, 16); // Return 2^16 // InOut sample usage as SAL  void Pow (InOut int Input, int _Pow) {     int Result = 1;     for (int i = 0; i &lt; Pow; i++)     {         Result = _Input;     }     _Input = Result; }</p> <p>Windows Main Function  Purple characters are mostly macros  preoprocessor will replace before compiler </p>"},{"location":"AR250425/#define-int-int-macros","title":"define INT int // Macros","text":"<p>Unreferenced parameter macro analysis </p>"},{"location":"AR250425/#define-unreferenced_parameterp-p-macro","title":"define UNREFERENCED_PARAMETER(P) (P) // Macro","text":"<p>UNREFERENCED_PARAMETER(hPrevInstance); // Macro will be converted to  (hPrevInstance); // Macro, so basically meaningless code  So compiler , by optmization, will automatically remove these unnecessary code  UNREFERENCED_PARAMETER // not used parameter declared </p> <p>HINSTANCE HINSTANCE LPWSTR int  Green color characters are redefined types by typedef  Click with F12 then figure out what it is.  Also macro instance  Search by F12 if input then change data </p>"},{"location":"AR250425/#define-my_macrop-struct-pstruct","title":"#define MY_MACRO(p) struct p##Struct {};","text":"<p>MY_MACRO(MY); MYStruct st;  MYStruct(st);  So it can be defined as </p> <p>struct MyStruct {}; // Like this </p> <p>HINSTANCE__; // struct instance generated  typedef HINSTANCE__ * HINSTANCE; // typedef instance pointer value </p> <p>DECLARE_HANDLE(MyDataType);  MyDataType__;  typedef MyDataType__ MyDataType; // typedef instance pointer value</p> <p>so why doing this ..?  Handle datatype ?  Kernel object  // OS  Core functions of the OS </p> <p>All seems same but codes will be different inside per OS  Android iOS all converted codes should be necessary  That is why game engine is better due to platform flexibility  Kernel object is core function of OS, so source code is hidden, ID value handle </p> <p>windows generated pointer memory whatever ... these OS only provide functions  Return the id value of the window. handle datatype HWND pointer type is returned </p> <p>float pFloat;  int pInt = pFloat; // Error </p> <p>Simliarly  HWD hWnd = 0; // pointer value pointing struct HWD__ HBITMAP hBit = hWnd; // pointer value pointing struct HBITMAP__</p> <p>Compatibility Issue pointer function is applied  If all id are defined as UINT then the user will be extremely confused about ID type  so ID type is defined as different type while not revealing kernel objects  so HPEN HBRUSH HDC HWND HBITMAP HMODULE are used </p> <p>Kernel object is not revealing specific memory address or structure but provided as id value  by each type of kernel object id value confusion shuold be prevented  so id value offers different types per each kernel object </p> <p>simple interger type management by ID will result in kernel object confusion with different types  so different tpye pointers are not compatible so name is redefine dand used </p> <p>Each different handle not compatible  HWND hWnd - 0;  HBitMAP hBit = hWnd; // Error  Each differnent pointer not compatible </p> <p>float pFloat;  int pInt = pFloat; // Error </p> <p>Kernel objects </p>"},{"location":"AR250426/","title":"Windows API Programming","text":""},{"location":"AR250426/#introduction","title":"Introduction","text":"<p>Understanding Windows API programming is essential for C++ game developers working in the Windows environment. This article breaks down fundamental concepts of Windows application development including process handling, window creation, resource management, and message loops. These concepts form the foundation of Windows desktop application development and are particularly relevant for game development.</p>"},{"location":"AR250426/#process-handles-and-instances","title":"Process Handles and Instances","text":"<p>When developing Windows applications, understanding process handles and instances is crucial. Here's what you need to know:</p>"},{"location":"AR250426/#hinstance-and-process-ids","title":"HINSTANCE and Process IDs","text":"<ul> <li><code>HINSTANCE</code> represents a handle to an instance, which is essentially the launched process ID.</li> <li>When you start a program like <code>mspaint.exe</code> multiple times, each instance gets its own process ID.</li> </ul>"},{"location":"AR250426/#multiple-instance-detection","title":"Multiple Instance Detection","text":"<p>In older Windows systems, you could detect previous instances using:</p> <pre><code>__IN_ HINSTANCE hInstance       // Current process ID \n_In_opt_ HINSTANCE hPrevInstance // Previous instance handle\n</code></pre> <p>If you wanted to prevent multiple launches of your application (common in game clients):</p> <pre><code>if(nullptr != hPrevInstance) {\n    // Another instance exists\n    return 0; // Terminate this instance\n}\n</code></pre> <p>However, this mechanism is obsolete in modern Windows. Each process now operates in its own virtual memory space (approximately 150-180 MB of RAM), and Windows OS manages memory mapping. This means processes can't easily find or access each other even if they're instances of the same executable.</p>"},{"location":"AR250426/#resource-management","title":"Resource Management","text":"<p>Resources are non-executable data included with your application, such as strings, icons, and menus.</p>"},{"location":"AR250426/#string-tables","title":"String Tables","text":"<p>String tables let you store text values in your application's resources:</p> <pre><code>IDS_APP_TITLE    103    WinAPI_56  \nIDC_WINAPI56     109    WinAPI_56\n</code></pre> <p>These values can be accessed in code using:</p> <pre><code>LoadStringW(hInstance, IDS_APP_TITLE, szTitle, 100);\n</code></pre> <p>When an application launches: 1. The process is loaded into memory 2. Resources (including string tables) are loaded with it 3. Resource values can be accessed via their IDs</p>"},{"location":"AR250426/#why-use-resource-strings","title":"Why Use Resource Strings?","text":"<p>While it's possible to hardcode strings directly:</p> <pre><code>wchar_t szWindowClass[100] = L\"WINAPI_56\";\n</code></pre> <p>Resources provide several advantages: - Centralized management of strings - Easier localization - Separation of code and content</p>"},{"location":"AR250426/#window-registration-and-creation","title":"Window Registration and Creation","text":"<p>Creating windows involves two key steps: registering a window class and instantiating windows of that class.</p>"},{"location":"AR250426/#window-class-registration","title":"Window Class Registration","text":"<pre><code>WNDCLASSEXW wcex;\n// Fill window class options\nwcex.lpszClassName = szWindowClass; // Class name (key value)\nRegisterClassExW(&amp;wcex);\n</code></pre> <p>This registers a \"blueprint\" for your windows, defining their behavior and appearance. The <code>lpszClassName</code> acts as a key that identifies this window type.</p>"},{"location":"AR250426/#window-creation","title":"Window Creation","text":"<pre><code>HWND hWnd = CreateWindow(szWindowClass, szTitle, ...);\n</code></pre> <p>Key parameters include: - Window class name - Window title - Style and appearance settings</p> <p>After creation, windows need to be made visible:</p> <pre><code>ShowWindow(hWnd, nCmdShow); // Make window visible (true) or hidden (false)\nUpdateWindow(hWnd);         // Apply the settings\n</code></pre>"},{"location":"AR250426/#window-customization","title":"Window Customization","text":"<p>Additional customization options include: - Menu bars: Set via <code>wcex.lpszMenuName</code> - Icons: Set via <code>wcex.hIcon</code> - Cursors: Set via <code>wcex.hCursor</code></p> <p>These resources are typically defined in the application's resource files.</p>"},{"location":"AR250426/#message-loops-and-event-handling","title":"Message Loops and Event Handling","text":"<p>Windows applications are event-driven, using message loops to process user input and system events.</p>"},{"location":"AR250426/#message-structure","title":"Message Structure","text":"<pre><code>MSG msg = {}; // Structure to hold message information\n</code></pre> <p>The <code>MSG</code> structure holds information about: - Which window received the event - What type of event occurred (message ID) - Additional parameters specific to the event</p>"},{"location":"AR250426/#traditional-message-loop","title":"Traditional Message Loop","text":"<p>The standard Windows message loop:</p> <pre><code>while(GetMessage(&amp;msg, nullptr, 0, 0)) {\n    // Handle shortcut key combinations\n    if(!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg)) {\n        TranslateMessage(&amp;msg); \n        DispatchMessage(&amp;msg);\n    }\n}\n</code></pre> <p>This is known as reactive programming - the application waits for events and reacts to them.</p>"},{"location":"AR250426/#how-getmessage-works","title":"How GetMessage Works","text":"<ul> <li><code>GetMessage</code> retrieves messages from the application's message queue</li> <li>If the queue is empty, <code>GetMessage</code> pauses execution until a message arrives</li> <li><code>GetMessage</code> returns false when it retrieves a <code>WM_QUIT</code> message (value 0x0012 or 18 in decimal)</li> <li>When false is returned, the loop ends and the application terminates</li> </ul>"},{"location":"AR250426/#game-programming-peekmessage-alternative","title":"Game Programming: PeekMessage Alternative","text":"<p>Games can't just wait for user input - they need to run continuously. Instead of <code>GetMessage</code>, games typically use <code>PeekMessage</code>:</p> <pre><code>while(running) {\n    // Check for messages but don't wait if none exist\n    if(PeekMessage(&amp;msg, nullptr, 0, 0, PM_REMOVE)) {\n        if(msg.message == WM_QUIT) {\n            running = false;\n        } else {\n            TranslateMessage(&amp;msg);\n            DispatchMessage(&amp;msg);\n        }\n    }\n\n    // Game logic runs here, every frame\n    UpdateGame();\n    RenderFrame();\n}\n</code></pre> <p>The key differences between <code>GetMessage</code> and <code>PeekMessage</code>:</p> <ol> <li><code>GetMessage</code> waits if the message queue is empty; <code>PeekMessage</code> returns immediately</li> <li><code>GetMessage</code> returns false for <code>WM_QUIT</code>; <code>PeekMessage</code> returns true if any message was retrieved</li> <li><code>PeekMessage</code> allows the game loop to run continuously</li> </ol>"},{"location":"AR250426/#forward-declarations-and-global-variables","title":"Forward Declarations and Global Variables","text":"<p>The code example includes some C/C++ programming concepts worth noting:</p>"},{"location":"AR250426/#forward-declarations","title":"Forward Declarations","text":"<pre><code>// Function forward declarations\nint Add(int a, int b);\nint Sub(int a, int b);\nint Mul(int a, int b);\nint Div(int a, int b);\n</code></pre> <p>Forward declarations tell the compiler about functions before they're fully defined, typically in header files.</p>"},{"location":"AR250426/#global-and-static-variables","title":"Global and Static Variables","text":"<pre><code>// Static global variable - only available in this file\nstatic int g_Global = 0;\n\n// Global variable accessible from all files\nint g_A = 0;\n\nint main() {\n    // Static local variable - retains value between function calls\n    static int iStatic = 0;\n\n    g_Global = 200;\n    //g_A = 100;\n\n    // Function calls\n    int i = 0;\n    i = Add(1, 9);\n    i = Sub(1, 9);\n    i = Mul(1, 9);\n    i = Div(1, 9);\n    Func();\n\n    return 0;\n}\n</code></pre> <ul> <li>Static global variables (prefixed with <code>static</code>) are only accessible within the file where they're defined</li> <li>Global variables without <code>static</code> can be accessed from any file (with proper external declarations)</li> <li>Static local variables retain their values between function calls</li> </ul>"},{"location":"AR250426/#interview-preparation-questions","title":"Interview Preparation Questions","text":"<p>Based on this material, here are some questions you might encounter in a C++ game programmer interview:</p> <ol> <li> <p>Basic Windows Creation: Explain the process of creating a window in a Windows application.</p> </li> <li> <p>Message Loop Mechanics: What's the difference between <code>GetMessage</code> and <code>PeekMessage</code>, and why would you choose one over the other for game development?</p> </li> <li> <p>Resource Management: How would you store and access string resources in a Windows application?</p> </li> <li> <p>Multiple Instance Prevention: How would you prevent multiple instances of your game from running simultaneously?</p> </li> <li> <p>Game Loop Implementation: Design a basic game loop that handles Windows messages while ensuring continuous gameplay.</p> </li> <li> <p>Memory Management in Windows: Explain how process memory is allocated and managed in modern Windows operating systems.</p> </li> <li> <p>Event-Driven Programming: Describe the event-driven programming model used in Windows applications and how it differs from sequential programming.</p> </li> </ol>"},{"location":"AR250426/#conclusion","title":"Conclusion","text":"<p>Understanding Windows API programming is essential for C++ game developers targeting the Windows platform. The concepts of process handles, window creation, message loops, and resource management form the foundation of Windows application development. By mastering these concepts, you'll be well-prepared for technical interviews and have the knowledge needed to create efficient, responsive Windows games.</p> <p>Remember that modern game development often uses frameworks like DirectX, SDL, or game engines that abstract many of these low-level Windows details, but understanding the underlying mechanisms remains valuable for debugging, optimization, and specialized implementation needs.</p>"},{"location":"AR250429/","title":"Message Loops and Engine Architecture","text":""},{"location":"AR250429/#introduction","title":"Introduction","text":"<p>Understanding Windows API programming fundamentals and engine architecture is essential for C++ game developers. While modern game development often relies on established game engines, mastering the underlying Windows message system and creating custom engine architectures provides a strong foundation for technical interviews and professional development. This guide explores Windows message processing and demonstrates how to build a basic game engine framework.</p>"},{"location":"AR250429/#windows-message-system","title":"Windows Message System","text":"<p>At the core of Windows applications lies the message system. This event-driven architecture enables user interaction by processing input and system events.</p>"},{"location":"AR250429/#getmessage-vs-peekmessage","title":"GetMessage vs. PeekMessage","text":"<p>Traditional Windows applications use <code>GetMessage</code> to retrieve messages from the application's message queue:</p> <pre><code>MSG msg;\nwhile (GetMessage(&amp;msg, nullptr, 0, 0)) {\n    if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg)) {\n        TranslateMessage(&amp;msg);\n        DispatchMessage(&amp;msg);\n    }\n}\n</code></pre> <p>However, games require continuous execution even when no user input occurs. Here's how the two message-handling approaches differ:</p> Function Behavior Return Value Usage <code>GetMessage</code> Waits for messages, blocking execution <code>false</code> for WM_QUIT, <code>true</code> otherwise Regular applications <code>PeekMessage</code> Checks for messages without blocking <code>true</code> if message exists, <code>false</code> otherwise Games, real-time applications"},{"location":"AR250429/#the-game-message-loop-pattern","title":"The Game Message Loop Pattern","text":"<p>Games typically implement this message loop pattern:</p> <pre><code>while (true) {\n    if (PeekMessage(&amp;msg, nullptr, 0, 0, PM_REMOVE)) {\n        if (msg.message == WM_QUIT) {\n            break; // Exit loop when WM_QUIT received\n        } else {\n            if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg))\n            {\n                TranslateMessage(&amp;msg);\n                DispatchMessage(&amp;msg);\n            }\n        }\n    } else {\n        // No message in queue - run game logic here\n        RunGame();\n    }\n}\n</code></pre> <p>This pattern ensures your game keeps running without interruption, while still processing Windows messages when they occur. In most frames, the <code>else</code> block runs (~99.99% of the time), allowing continuous gameplay.</p>"},{"location":"AR250429/#message-processing-flow","title":"Message Processing Flow","text":"<p>When a message is retrieved:</p> <ol> <li><code>TranslateMessage</code> converts virtual-key messages to character messages</li> <li><code>DispatchMessage</code> sends the message to the window procedure function</li> </ol>"},{"location":"AR250429/#window-procedure-function","title":"Window Procedure Function","text":"<p>Each window has a procedure function that handles its messages:</p> <pre><code>LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)\n{\n    switch (message) {\n    case WM_COMMAND:\n        // Handle menu commands\n        switch (LOWORD(wParam)) {\n        case IDM_ABOUT:\n            DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);\n            break;\n        case IDM_EXIT:\n            DestroyWindow(hWnd);\n            break;\n        default:\n            return DefWindowProc(hWnd, message, wParam, lParam);\n        }\n        break;\n\n    case WM_DESTROY:\n        PostQuitMessage(0); // This sends WM_QUIT to the message queue\n        break;\n\n    default:\n        return DefWindowProc(hWnd, message, wParam, lParam);\n    }\n    return 0;\n}\n</code></pre> <p>Key points: - <code>message</code> parameter contains the message type (like WM_COMMAND = 273) - <code>wParam</code> often contains additional information (like which menu item was clicked) - <code>DefWindowProc</code> handles standard window behavior when you don't need custom handling - <code>PostQuitMessage(0)</code> puts a WM_QUIT message in the queue, which will cause the message loop to exit</p>"},{"location":"AR250429/#building-a-game-engine-framework","title":"Building a Game Engine Framework","text":"<p>Now let's examine how to build a simple game engine architecture that works with the Windows message system.</p>"},{"location":"AR250429/#the-singleton-pattern","title":"The Singleton Pattern","text":"<p>Most engine subsystems use the Singleton pattern to ensure only one instance exists:</p> <pre><code>class Engine {\nprivate:\n    // Private constructor and destructor\n    Engine();\n    ~Engine();\n\n    // Delete copy constructor and assignment operator\n    Engine(const Engine&amp; _Other) = delete;\n    Engine&amp; operator=(const Engine&amp; _Other) = delete;\n\npublic:\n    // Static instance getter\n    static Engine* GetInst() {\n        static Engine mgr;\n        return &amp;mgr;\n    }\n\n    // Engine methods...\n};\n</code></pre> <p>This pattern has several key characteristics: - Private constructor prevents external instantiation - Static method returns the single instance - Copy constructor and assignment operator are deleted to prevent duplication</p> <p>For convenience, you can create a macro to generate singleton code:</p> <pre><code>#define SINGLE(ClassName) \\\npublic: \\\n    static ClassName* GetInst() { \\\n        static ClassName mgr; \\\n        return &amp;mgr; \\\n    } \\\nprivate: \\\n    ClassName(); \\\n    ~ClassName(); \\\n    ClassName(const ClassName&amp; _Other) = delete; \\\n    ClassName&amp; operator=(const ClassName&amp; _Other) = delete;\n</code></pre> <p>Then use it like this:</p> <pre><code>class Engine {\n    SINGLE(Engine)\n\n    // Engine methods...\n};\n</code></pre>"},{"location":"AR250429/#engine-class-implementation","title":"Engine Class Implementation","text":"<p>The Engine class manages core functionality including window handling and rendering:</p> <pre><code>class Engine {\n    SINGLE(Engine)\n\nprivate:\n    HINSTANCE m_hInst;       // Process handle\n    HWND m_hMainWnd;         // Main window handle\n    POINT m_Resolution;      // Window resolution\n    HDC m_MainDC;            // Device context for rendering\n\npublic:\n    void Init(HINSTANCE _Inst, HWND _hWnd, UINT _Width, UINT _Height);\n    void Progress();         // Main game loop function\n};\n</code></pre> <p>The initialization method sets up the engine:</p> <pre><code>void Engine::Init(HINSTANCE _Inst, HWND _hWnd, UINT _Width, UINT _Height)\n{\n    m_hInst = _Inst;\n    m_hMainWnd = _hWnd;\n    m_Resolution = POINT{(LONG)_Width, (LONG)_Height};\n\n    // Position and size the window\n    SetWindowPos(m_hMainWnd, nullptr, 10, 10, m_Resolution.x, m_Resolution.y, 0);\n\n    // Get device context for rendering\n    m_MainDC = GetDC(m_hMainWnd);\n}\n</code></pre> <p>The constructor initializes members to safe defaults:</p> <pre><code>Engine::Engine() :\n    m_hInst(nullptr),\n    m_hMainWnd(nullptr),\n    m_Resolution{},\n    m_MainDC(nullptr)\n{\n}\n</code></pre> <p>The destructor releases resources:</p> <pre><code>Engine::~Engine()\n{\n    if (m_MainDC != nullptr) {\n        ReleaseDC(m_hMainWnd, m_MainDC);\n    }\n}\n</code></pre> <p>The Progress method contains game logic and rendering:</p> <pre><code>void Engine::Progress()\n{\n    // Example: Draw a rectangle\n    Rectangle(m_MainDC, 200, 200, 300, 300);\n\n    // Game update and rendering code would go here\n}\n</code></pre>"},{"location":"AR250429/#integrating-with-the-windows-message-loop","title":"Integrating with the Windows Message Loop","text":"<p>Here's how to integrate the Engine with the Windows message loop:</p> <pre><code>int APIENTRY wWinMain(_In_ HINSTANCE hInstance,\n                      _In_opt_ HINSTANCE hPrevInstance,\n                      _In_ LPWSTR    lpCmdLine,\n                      _In_ int       nCmdShow)\n{\n    // Register window class and create window...\n    HWND hWnd = CreateWindow(...);\n\n    // Initialize the engine\n    Engine::GetInst()-&gt;Init(hInstance, hWnd, 1280, 768);\n\n    MSG msg;\n    while (true) {\n        if (PeekMessage(&amp;msg, nullptr, 0, 0, PM_REMOVE)) {\n            if (msg.message == WM_QUIT) {\n                break;\n            }\n\n            TranslateMessage(&amp;msg);\n            DispatchMessage(&amp;msg);\n        } else {\n            // Run game logic when no messages are waiting\n            Engine::GetInst()-&gt;Progress();\n        }\n    }\n\n    return (int)msg.wParam;\n}\n</code></pre>"},{"location":"AR250429/#using-precompiled-headers","title":"Using Precompiled Headers","text":"<p>To improve compilation speed, use precompiled headers for commonly included files:</p> <ol> <li> <p>Create a <code>pch.h</code> file with common includes: <pre><code>#pragma once\n\n#include &lt;windows.h&gt;\n// Other common includes\n#include \"define.h\"  // For our singleton macro\n</code></pre></p> </li> <li> <p>Create a corresponding <code>pch.cpp</code> that includes it: <pre><code>#include \"pch.h\"\n</code></pre></p> </li> <li> <p>Configure Visual Studio to use precompiled headers:</p> </li> <li>Right-click on the project \u2192 Properties</li> <li>C/C++ \u2192 Precompiled Headers</li> <li>Set \"Precompiled Header\" to \"Use (/Yu)\"</li> <li>Set \"Precompiled Header File\" to \"pch.h\"</li> <li> <p>For <code>pch.cpp</code> specifically, set to \"Create (/Yc)\"</p> </li> <li> <p>Include <code>pch.h</code> at the top of all .cpp files: <pre><code>#include \"pch.h\"\n// Other includes...\n</code></pre></p> </li> </ol>"},{"location":"AR250429/#drawing-with-device-context","title":"Drawing with Device Context","text":"<p>The Windows API provides functions to draw on a window using a Device Context (DC):</p> <pre><code>void Engine::Progress()\n{\n    // Clear background (optional)\n    RECT clientRect;\n    GetClientRect(m_hMainWnd, &amp;clientRect);\n    FillRect(m_MainDC, &amp;clientRect, (HBRUSH)GetStockObject(WHITE_BRUSH));\n\n    // Draw a rectangle\n    Rectangle(m_MainDC, 200, 200, 300, 300);\n\n    // Draw text\n    SetTextColor(m_MainDC, RGB(0, 0, 0));\n    SetBkMode(m_MainDC, TRANSPARENT);\n    TextOut(m_MainDC, 100, 100, L\"Hello, Game!\", 12);\n}\n</code></pre>"},{"location":"AR250429/#interview-questions","title":"Interview Questions","text":"<p>Here are some potential interview questions related to this material:</p> <ol> <li> <p>Message Loop Question: Explain the difference between <code>GetMessage</code> and <code>PeekMessage</code>. Why would a game use <code>PeekMessage</code> instead of <code>GetMessage</code>?</p> </li> <li> <p>Singleton Pattern Question: What is the Singleton pattern and why is it commonly used in game engines? What are potential drawbacks?</p> </li> <li> <p>Memory Management Question: In the Engine class destructor, we call <code>ReleaseDC()</code>. Why is proper resource cleanup important in Windows programming?</p> </li> <li> <p>Architecture Question: Describe how you would structure a game engine to separate game logic from rendering and input handling.</p> </li> <li> <p>Window Procedure Question: What happens when a window receives a message? Describe the flow from user input to message handling.</p> </li> <li> <p>Practical Question: Write a Windows message loop suitable for a game that needs to run at 60 FPS.</p> </li> <li> <p>DeviceContext Question: What is a Device Context in Windows and how is it used for drawing?</p> </li> <li> <p>Advanced Question: How would you implement frame rate control in a Windows-based game using the architecture described?</p> </li> </ol>"},{"location":"AR250429/#conclusion","title":"Conclusion","text":"<p>Understanding Windows message processing and engine architecture provides a strong foundation for C++ game development. While modern games often use established engines, knowing how these systems work under the hood is valuable for optimization, debugging, and technical interviews.</p> <p>The techniques covered here\u2014message loops, the Singleton pattern, window management, and basic rendering\u2014form building blocks that you can expand into more complex game engines. With this knowledge, you can build your own custom game frameworks or better understand existing engines.</p> <p>Remember that production-ready game engines have many additional components like resource management, input systems, scene graphs, physics, audio, and more sophisticated rendering. However, the architectural patterns described here scale to those more complex systems.</p>"},{"location":"AR250430/","title":"WinAPI Actor Architecture and Rendering","text":""},{"location":"AR250430/#introduction-to-actor-based-design","title":"Introduction to Actor-Based Design","text":"<p>In game development, effective architecture is crucial for creating maintainable and scalable systems. One of the most widespread patterns is the actor-based architecture, which serves as the foundation for many modern game engines like Unreal Engine and Unity.</p>"},{"location":"AR250430/#understanding-actors-as-foundational-elements","title":"Understanding Actors as Foundational Elements","text":"<p>An Actor represents the minimum material unit in a game world. Rather than creating all game objects directly, we define a base Actor class from which more specific classes are derived. This approach leverages C++ polymorphism to create a flexible and extensible game architecture.</p> <p>The Actor base class typically cannot be instantiated directly - it's designed as an abstract class that provides common functionality while requiring derived classes to implement specific behaviors. This follows the principle that concrete objects in a game world are always specific entities (Player, Monster, Prop, etc.) rather than generic \"actors.\"</p>"},{"location":"AR250430/#basic-actor-implementation","title":"Basic Actor Implementation","text":"<p>Let's examine a fundamental Actor class implementation:</p> <pre><code>class Actor \n{\nprivate: \n    // Position and scale represented as vectors\n    Vec2 m_Pos;\n    Vec2 m_Scale;\n\npublic: \n    // Position setter and getter\n    void SetPos(Vec2 _Pos)\n    {\n        m_Pos = _Pos; \n    }\n\n    // Scale setter and getter\n    void SetScale(Vec2 _Scale)\n    {\n        m_Scale = _Scale; \n    }\n\n    Vec2 GetPos()\n    {\n        return m_Pos; \n    }\n\n    Vec2 GetScale()\n    {\n        return m_Scale; \n    }\n\n    // Core functionality that all actors must implement\n    virtual void Tick() = 0;\n    virtual void Render(HDC _dc);\n};\n</code></pre>"},{"location":"AR250430/#header-implementation-and-inline-functions","title":"Header Implementation and Inline Functions","text":"<p>A critical point to understand about the above implementation is the implications of defining functions within the header file. When functions are defined (implemented) directly in a header file, they are implicitly treated as inline functions.</p>"},{"location":"AR250430/#what-are-inline-functions","title":"What are Inline Functions?","text":"<p>Inline functions are a compiler optimization where the function's code is inserted directly at the call site rather than generating an actual function call. This can improve performance for small, frequently called functions by eliminating the overhead of the function call mechanism.</p> <p>When a function is defined in a header file:</p> <ol> <li>The compiler treats it as an inline function</li> <li>The function's implementation is copied wherever it's called</li> <li>No separate function call is generated in the compiled code</li> </ol> <p>For example, when we call:</p> <pre><code>actor.SetPos(Vec2{10.0f, 10.0f});\n</code></pre> <p>The compiler effectively transforms this into:</p> <pre><code>actor.m_Pos = Vec2{10.0f, 10.0f};\n</code></pre> <p>This avoids the overhead of a function call, which includes: - Pushing parameters onto the stack - Jumping to the function code - Setting up the function's stack frame - Returning from the function - Cleaning up the stack</p>"},{"location":"AR250430/#when-to-use-inline-functions","title":"When to Use Inline Functions","text":"<p>Inline functions are particularly beneficial when: 1. The function is small and simple 2. The function is called frequently 3. The function execution time is comparable to or less than the function call overhead</p> <p>Simple accessors and mutators (getters and setters) are excellent candidates for inline functions because they typically just return or assign a value.</p>"},{"location":"AR250430/#cautions-with-inline-functions","title":"Cautions with Inline Functions","text":"<p>There are trade-offs to consider:</p> <ol> <li>Code Size Increase: Every place the function is called will contain a copy of the function code, potentially increasing the executable size</li> <li>Header File Bloat: Implementing complex functions in the header can make headers large and difficult to maintain</li> <li>Compilation Time: Changes to inline functions require recompiling all files that include the header</li> </ol> <p>For larger, more complex functions, it's generally better to provide only the declaration in the header and implement the function in a .cpp file.</p>"},{"location":"AR250430/#custom-vector-implementation","title":"Custom Vector Implementation","text":"<p>For better precision in positioning and movement, we can implement a custom vector structure using floating-point values instead of integers:</p> <pre><code>struct Vec2 {\n    float x;\n    float y;\n\npublic: \n    // Default constructor initializes to zero\n    Vec2() : x(0.f), y(0.f) {}\n\n    // Parameterized constructor\n    Vec2(float _x, float _y) : x(_x), y(_y) {}\n};\n</code></pre> <p>Using floating-point values allows for smoother movement and more precise positioning than integer-based coordinates, which is especially important for game development where sub-pixel precision may be needed.</p>"},{"location":"AR250430/#the-game-loop-tick-and-render","title":"The Game Loop: Tick and Render","text":"<p>In game development, a fundamental concept is the game loop, often divided into update (Tick) and rendering phases.</p>"},{"location":"AR250430/#the-tick-function","title":"The Tick Function","text":"<p>The <code>Tick()</code> function is called once per frame and is responsible for updating an actor's state, handling input, applying physics, and any other frame-by-frame logic. All actors must implement their own Tick function:</p> <pre><code>// In the Actor base class\nvirtual void Tick() = 0; // Pure virtual function\n\n// In a derived class (e.g., Player)\nvoid Player::Tick() override {\n    // Check for input\n    if(GetAsyncKeyState('W')) {\n        m_Pos.y -= 0.001f; // Move up slightly\n    }\n    if(GetAsyncKeyState('S')) {\n        m_Pos.y += 0.001f; // Move down slightly\n    }\n    if(GetAsyncKeyState('A')) {\n        m_Pos.x -= 0.001f; // Move left slightly\n    }\n    if(GetAsyncKeyState('D')) {\n        m_Pos.x += 0.001f; // Move right slightly\n    }\n\n    // Additional actor-specific logic\n}\n</code></pre>"},{"location":"AR250430/#the-render-function","title":"The Render Function","text":"<p>The <code>Render()</code> function is responsible for drawing the actor on the screen. While the base Actor class may provide a default implementation, derived classes often override it for custom visuals:</p> <pre><code>void Actor::Render(HDC _dc) {\n    // Calculate rectangle corners based on position and scale\n    Rectangle(_dc, \n            (int)(m_Pos.x - m_Scale.x / 2), \n            (int)(m_Pos.y - m_Scale.y / 2),\n            (int)(m_Pos.x + m_Scale.x / 2), \n            (int)(m_Pos.y + m_Scale.y / 2));\n}\n</code></pre>"},{"location":"AR250430/#input-handling-in-games","title":"Input Handling in Games","text":"<p>A key aspect of interactive games is handling user input. While Windows typically processes input through the message loop (WM_KEYDOWN, WM_KEYUP, etc.), games often need more immediate input detection.</p>"},{"location":"AR250430/#asynchronous-key-state-detection","title":"Asynchronous Key State Detection","text":"<p>For responsive input handling, games commonly use the <code>GetAsyncKeyState()</code> function, which checks the current state of a key directly without waiting for a Windows message:</p> <pre><code>if(GetAsyncKeyState('W')) {\n    // 'W' key is currently pressed\n    m_Pos.y -= 0.001f; // Move upward\n}\n</code></pre> <p>This approach allows for: 1. Continuous movement while a key is held down 2. Multiple key presses to be detected simultaneously 3. Input checking in sync with the game loop</p>"},{"location":"AR250430/#working-with-the-windows-gdi-for-rendering","title":"Working with the Windows GDI for Rendering","text":"<p>The Graphics Device Interface (GDI) is Windows' legacy system for drawing graphics. While modern games typically use more advanced APIs (DirectX, OpenGL, etc.), understanding GDI concepts is valuable for learning fundamental graphics principles.</p>"},{"location":"AR250430/#device-context-dc","title":"Device Context (DC)","text":"<p>A Device Context (DC) is a Windows structure that contains information about the drawing attributes of a device and serves as a container for drawing operations. It includes:</p> <ol> <li>The destination (window) where drawing will occur</li> <li>The current drawing tools (pen, brush, etc.)</li> <li>Various drawing parameters and settings</li> </ol>"},{"location":"AR250430/#customizing-drawing-with-pens-and-brushes","title":"Customizing Drawing with Pens and Brushes","text":"<p>GDI uses two primary tools for drawing: - Pens: Define how lines are drawn (color, width, style) - Brushes: Define how enclosed areas are filled</p> <p>Here's how to create and use custom pens and brushes:</p> <pre><code>void Actor::Render(HDC _dc) {\n    // Create a red pen\n    HPEN hNewPen = CreatePen(PS_SOLID, 2, RGB(255, 0, 0));\n\n    // Save the original pen and select our new one\n    HPEN hPrevPen = (HPEN)SelectObject(_dc, hNewPen);\n\n    // Create a green brush\n    HBRUSH hNewBrush = CreateSolidBrush(RGB(20, 255, 20));\n\n    // Save the original brush and select our new one\n    HBRUSH hPrevBrush = (HBRUSH)SelectObject(_dc, hNewBrush);\n\n    // Draw the rectangle (with red outline and green fill)\n    Rectangle(_dc, \n            (int)(m_Pos.x - m_Scale.x / 2), \n            (int)(m_Pos.y - m_Scale.y / 2),\n            (int)(m_Pos.x + m_Scale.x / 2), \n            (int)(m_Pos.y + m_Scale.y / 2));\n\n    // Restore the original pen and brush\n    SelectObject(_dc, hPrevPen);\n    SelectObject(_dc, hPrevBrush);\n\n    // Clean up our created objects\n    DeleteObject(hNewPen);\n    DeleteObject(hNewBrush);\n}\n</code></pre>"},{"location":"AR250430/#understanding-colorref-and-rgb-colors","title":"Understanding COLORREF and RGB Colors","text":"<p>Windows uses the COLORREF type to represent colors, which is essentially a 32-bit value where: - The lowest 8 bits represent the red component (0-255) - The next 8 bits represent the green component (0-255) - The next 8 bits represent the blue component (0-255) - The highest 8 bits are not used</p> <p>The RGB macro simplifies creating these values:</p> <pre><code>// Create a bright red color\nCOLORREF redColor = RGB(255, 0, 0);\n\n// This is equivalent to:\nCOLORREF redColor = 255 | (0 &lt;&lt; 8) | (0 &lt;&lt; 16);\n</code></pre>"},{"location":"AR250430/#optimization-for-drawing-tools","title":"Optimization for Drawing Tools","text":"<p>Creating and destroying GDI objects for every frame is inefficient. For better performance, you can create commonly used pens and brushes once and reuse them:</p> <pre><code>class Engine {\nprivate:\n    // Arrays of common pens and brushes\n    HPEN m_Pen[6];  // Different colored pens\n    HBRUSH m_Brush[6];  // Different colored brushes\n\npublic:\n    void Initialize() {\n        // Create commonly used pens and brushes\n        m_Pen[0] = CreatePen(PS_SOLID, 1, RGB(255, 0, 0));    // Red\n        m_Pen[1] = CreatePen(PS_SOLID, 1, RGB(0, 255, 0));    // Green\n        m_Pen[2] = CreatePen(PS_SOLID, 1, RGB(0, 0, 255));    // Blue\n        // ... more pens and brushes\n    }\n\n    HPEN GetPen(int index) {\n        return m_Pen[index];\n    }\n\n    void Release() {\n        // Clean up all pens and brushes\n        for(int i = 0; i &lt; 6; ++i) {\n            DeleteObject(m_Pen[i]);\n            DeleteObject(m_Brush[i]);\n        }\n    }\n};\n</code></pre>"},{"location":"AR250430/#understanding-frame-rate-and-game-loop","title":"Understanding Frame Rate and Game Loop","text":"<p>Frame rate, measured in frames per second (FPS), determines how smoothly a game runs. The game loop controls this by executing Tick and Render operations repeatedly:</p> <pre><code>// Simplified game loop\nwhile(running) {\n    // Process Windows messages\n    // ...\n\n    // Update all actors\n    for(Actor* actor : actors) {\n        actor-&gt;Tick();\n    }\n\n    // Render all actors\n    for(Actor* actor : actors) {\n        actor-&gt;Render(hDC);\n    }\n}\n</code></pre> <p>Modern games typically target specific frame rates (30, 60, 144 FPS, etc.) and may use frame timing to ensure consistent gameplay regardless of hardware speed.</p>"},{"location":"AR250430/#interview-questions-and-challenging-cases","title":"Interview Questions and Challenging Cases","text":"<ol> <li> <p>Q: Why would you use an actor-based architecture in game development?    A: Actor-based architecture provides a consistent interface for all game objects, facilitates polymorphism for specialized behaviors, centralizes common functionality like positioning and rendering, and creates a clean separation of concerns through the Tick/Render pattern.</p> </li> <li> <p>Q: Explain the difference between synchronous and asynchronous input handling in games.    A: Synchronous input handling waits for Windows messages like WM_KEYDOWN, which can cause input lag. Asynchronous input handling (using GetAsyncKeyState()) proactively checks the state of keys during the game loop, providing more responsive controls.</p> </li> <li> <p>Q: What are the trade-offs of using inline functions in a header file?    A: Inline functions can improve performance by eliminating function call overhead, which is beneficial for small, frequently called functions. However, they can increase code size, slow compilation times, and make headers more difficult to maintain if overused.</p> </li> <li> <p>Q: How would you optimize the rendering of many similar objects?    A: Some optimization strategies include: creating pens and brushes once at initialization rather than per frame, implementing object pooling, using culling techniques to avoid rendering off-screen objects, and batching similar draw calls.</p> </li> <li> <p>Q: Why use floating-point values for position instead of integers in a 2D game?    A: Floating-point positions allow for sub-pixel movement, which enables smoother animation, particularly at varying frame rates. They also facilitate consistent movement speeds and can store accumulated small movements that would be lost with integer-only positions.</p> </li> </ol>"},{"location":"AR250430/#conclusion","title":"Conclusion","text":"<p>Understanding actor-based architecture, game loops, rendering techniques, and efficient input handling provides a solid foundation for game development interviews. By mastering these concepts, you'll be better equipped to design and implement scalable, maintainable game systems.</p> <p>Remember that while these examples use Windows GDI for simplicity, modern game development typically employs more advanced graphics APIs. However, the core principles of game architecture remain consistent across different rendering technologies.</p>"},{"location":"AR250501/","title":"Game Engine Architecture: Level Management and Resource Handling","text":""},{"location":"AR250501/#introduction","title":"Introduction","text":"<p>Game engine architecture is a critical aspect of game development that requires careful consideration to ensure optimal performance, maintainability, and scalability. This article explores key components of a game engine with a focus on level management, resource handling, client-server architecture, and efficient rendering techniques. These concepts are fundamental knowledge for any C++ game programmer interview.</p>"},{"location":"AR250501/#client-server-architecture-in-games","title":"Client-Server Architecture in Games","text":"<p>Before diving into the engine architecture, it's important to understand the client-server model, which influences many design decisions in multiplayer game development.</p>"},{"location":"AR250501/#basic-client-server-interaction","title":"Basic Client-Server Interaction","text":"<p>In multiplayer games, particularly FPS (First Person Shooter) games, the server typically maintains the authoritative game state, while clients receive and visualize this information. This architecture has several implications:</p> <ul> <li>The server maintains and distributes information about all players to each client</li> <li>Each client already contains information about other players (enemies)</li> <li>Clients are primarily responsible for rendering the game state received from the server</li> </ul>"},{"location":"AR250501/#handling-game-actions-and-anti-cheat-considerations","title":"Handling Game Actions and Anti-Cheat Considerations","text":"<p>When a player performs an action like shooting, the process typically follows these steps:</p> <ol> <li>The client detects the action (e.g., gun fired)</li> <li>Client-side collision detection determines what was hit</li> <li>The client sends this information to the server</li> <li>The server validates the action before applying it to the game state</li> </ol> <p>This separation of responsibilities creates vulnerabilities for cheating. For example, a modified client could:</p> <ul> <li>Ignore obstacles in collision detection</li> <li>Report false hits on enemies</li> <li>Manipulate player position data</li> </ul> <p>To mitigate these risks, proper server-side validation is crucial. In many competitive games, the server performs its own collision detection and validation rather than trusting client reports.</p> <pre><code>// Example of how a server might validate a hit report\nbool ServerValidateHit(const BulletInfo&amp; bullet, const PlayerPosition&amp; shooterPos, \n                       const PlayerPosition&amp; targetPos) {\n    // Check if line of sight exists between shooter and target\n    if (!HasLineOfSight(shooterPos, targetPos)) {\n        return false; // No line of sight, reject the hit\n    }\n\n    // Check if bullet trajectory matches reported hit\n    if (!IsTrajectoryValid(bullet, shooterPos, targetPos)) {\n        return false; // Invalid trajectory, reject the hit\n    }\n\n    return true; // Hit validated\n}\n</code></pre> <p>For some games, particularly non-competitive or console games, extensive anti-cheat measures may be less critical due to: - The limited impact of cheating in cooperative or single-player experiences - More controlled hardware environments (e.g., consoles) that make cheating difficult</p>"},{"location":"AR250501/#gdi-resource-management","title":"GDI Resource Management","text":"<p>Moving to our engine implementation, proper management of GDI (Graphics Device Interface) resources is essential for rendering efficiency.</p>"},{"location":"AR250501/#enumerating-common-resources","title":"Enumerating Common Resources","text":"<p>To efficiently manage graphical resources like pens and brushes, we can use enumerations:</p> <pre><code>#pragma once\n\nenum class PEN_TYPE\n{\n    RED,\n    BLUE,\n    GREEN,\n    GRAY,\n    BLACK,\n    WHITE,\n    MAGENTA,\n    END, // Marker for the total number of pens\n};\n\nenum class BRUSH_TYPE\n{\n    RED,\n    BLUE,\n    GREEN,\n    GRAY,\n    MAGENTA,\n    HOLLOW,\n    END\n};\n</code></pre>"},{"location":"AR250501/#creating-and-managing-gdi-objects","title":"Creating and Managing GDI Objects","text":"<p>These resources are created once at initialization and stored for reuse:</p> <pre><code>// Declaration in the engine class\nHPEN m_pen[(UINT)PEN_TYPE::END];\nHBRUSH m_brush[(UINT)BRUSH_TYPE::END];\n\n// Creation of resources\nvoid Engine::CreateGDIObjects()\n{\n    m_pen[(UINT)PEN_TYPE::RED] = CreatePen(PS_SOLID, 1, RGB(255, 0, 0));\n    m_pen[(UINT)PEN_TYPE::GREEN] = CreatePen(PS_SOLID, 1, RGB(0, 255, 0));\n    m_pen[(UINT)PEN_TYPE::BLUE] = CreatePen(PS_SOLID, 1, RGB(0, 0, 255));\n    m_pen[(UINT)PEN_TYPE::MAGENTA] = CreatePen(PS_SOLID, 1, RGB(255, 0, 255));\n    // Other pens...\n\n    m_brush[(UINT)BRUSH_TYPE::RED] = CreateSolidBrush(RGB(255, 0, 0));\n    // Other brushes...\n\n    // The HOLLOW brush is obtained from the system\n    m_brush[(UINT)BRUSH_TYPE::HOLLOW] = (HBRUSH)GetStockObject(HOLLOW_BRUSH);\n}\n</code></pre>"},{"location":"AR250501/#proper-resource-cleanup","title":"Proper Resource Cleanup","text":"<p>Cleaning up these resources when the engine shuts down is equally important:</p> <pre><code>void Engine::CleanupGDIObjects()\n{\n    // Release the device context\n    ReleaseDC(m_hMainWnd, m_MainDC);\n\n    // Delete all pens\n    for(UINT i = 0; i &lt; (UINT)PEN_TYPE::END; ++i) {\n        DeleteObject(m_pen[i]);\n    }\n\n    // Delete all brushes except HOLLOW (system-managed)\n    for(UINT i = 0; i &lt; (UINT)BRUSH_TYPE::END; ++i) {\n        if(i == (UINT)BRUSH_TYPE::HOLLOW) continue;\n        DeleteObject(m_brush[i]);\n    }\n}\n</code></pre>"},{"location":"AR250501/#accessor-methods","title":"Accessor Methods","text":"<p>To provide access to these resources, we implement simple getter methods:</p> <pre><code>HPEN Engine::GetPen(PEN_TYPE _Type)\n{\n    return m_pen[(UINT)_Type];\n}\n\nHBRUSH Engine::GetBrush(BRUSH_TYPE _Type)\n{\n    return m_brush[(UINT)_Type];\n}\n</code></pre>"},{"location":"AR250501/#level-management-architecture","title":"Level Management Architecture","text":"<p>Level management is a core component of game engines, responsible for organizing game stages and maintaining collections of actors.</p>"},{"location":"AR250501/#level-class-design","title":"Level Class Design","text":"<p>The Level class serves as a container for all actors in a game stage:</p> <pre><code>class Level\n{\nprivate:\n    vector&lt;Actor*&gt; m_vecActor; // Collection of actors in this level\n\npublic:\n    void Tick();         // Update all actors\n    void Render(HDC _dc); // Render all actors\n    void AddActor(Actor* _actor); // Add an actor to the level\n\npublic:\n    Level();\n    ~Level();\n};\n</code></pre>"},{"location":"AR250501/#level-manager-implementation","title":"Level Manager Implementation","text":"<p>The Level Manager controls which level is currently active and facilitates level transitions:</p> <pre><code>#pragma once\n\nclass Level;\n\nclass LevelMgr\n{\n    SINGLE(LevelMgr); // Singleton macro\nprivate:\n    Level* m_CurLevel; // Currently active level\n\npublic:\n    void Init();\n    void Progress();\n};\n</code></pre> <p>Implementation in LevelMgr.cpp:</p> <pre><code>#include \"pch.h\"\n#include \"LevelMgr.h\"\n\n#include \"Engine.h\"\n#include \"Level.h\"\n#include \"Actor.h\"\n\nLevelMgr::LevelMgr()\n    : m_CurLevel(nullptr)\n{\n\n}\n\nLevelMgr::~LevelMgr()\n{\n    if(nullptr != m_CurLevel)\n       delete m_CurLevel;\n}\n\nvoid LevelMgr::Init()\n{\n    m_CurLevel = new Level;\n\n    Actor* pActor = new Actor; \n    pActor-&gt;SetPos(Vec2(640, 284));\n    pActor-&gt;SetScale(Vec2(100, 100));\n    m_CurLevel-&gt;AddActor(pActor);\n\n    pActor = new Actor;\n    pActor-&gt;SetPos(Vec2(200, 400));\n    pActor-&gt;SetScale(Vec2(50, 50));\n    m_CurLevel-&gt;AddActor(pActor);\n}\n\nvoid LevelMgr::Progress()\n{\n    m_CurLevel-&gt;Tick();\n    m_CurLevel-&gt;Render(Engine::GetInst()-&gt;GetMainDC());\n}\n</code></pre>"},{"location":"AR250501/#forward-declaration-and-header-management","title":"Forward Declaration and Header Management","text":"<p>Proper management of header files is crucial for optimizing compilation time and avoiding circular dependencies.</p>"},{"location":"AR250501/#the-value-of-forward-declarations","title":"The Value of Forward Declarations","text":"<p>In the LevelMgr.h file, notice the use of a forward declaration:</p> <pre><code>class Level; // Forward declaration\n</code></pre> <p>This approach offers several advantages:</p> <ol> <li> <p>Reduced Compilation Time: When a header file changes, only files that directly include it need to be recompiled, not those that use forward declarations.</p> </li> <li> <p>Prevents Circular Dependencies: Forward declarations help break potential circular include dependencies.</p> </li> <li> <p>Minimized Header Coupling: Implementation details remain hidden from header files.</p> </li> </ol>"},{"location":"AR250501/#guidelines-for-header-management","title":"Guidelines for Header Management","text":"<p>For optimal compilation performance:</p> <ol> <li>Use forward declarations in header files when possible</li> <li>Include the actual headers only in .cpp files where needed</li> <li>Keep header files minimal and focused</li> </ol> <pre><code>// Good practice\n// In header file\nclass SomeClass; // Forward declaration\n\n// In cpp file\n#include \"SomeClass.h\"\n</code></pre>"},{"location":"AR250501/#actor-collection-management","title":"Actor Collection Management","text":"<p>Efficient storage and access to game objects is crucial for performance.</p>"},{"location":"AR250501/#container-selection-vector-vs-linked-list","title":"Container Selection: Vector vs. Linked List","text":"<p>Both arrays/vectors and linked lists have O(n) time complexity for iterating through all elements, but there are practical performance differences:</p> <ul> <li>Dynamic Arrays/Vectors: Better cache locality and fewer memory allocations make iteration faster in practice</li> <li>Linked Lists: Each node access requires a pointer dereference, increasing the actual work done during iteration</li> </ul> <p>For a game where actors are iterated over every frame, a vector is typically the better choice:</p> <pre><code>class Level\n{\nprivate:\n    vector&lt;Actor*&gt; m_vecActor; // Vector of actor pointers\n\n    // Methods...\n};\n</code></pre>"},{"location":"AR250501/#memory-management-for-actor-collections","title":"Memory Management for Actor Collections","text":"<p>When a level contains dynamically allocated actors, proper cleanup is essential:</p> <pre><code>Level::~Level()\n{\n    // Clean up all dynamically allocated actors\n    for (size_t i = 0; i &lt; m_vecActor.size(); ++i)\n    {\n        delete m_vecActor[i];\n    }\n\n    // Vector's own destructor will handle clearing its internal storage\n}\n</code></pre>"},{"location":"AR250501/#polymorphism-and-virtual-destructors","title":"Polymorphism and Virtual Destructors","text":"<p>When using polymorphism with actor hierarchies, proper virtual destructor implementation is critical.</p>"},{"location":"AR250501/#the-need-for-virtual-destructors","title":"The Need for Virtual Destructors","text":"<p>Consider this hierarchy: - Actor (base class)   - Player (derived class)   - Enemy (derived class)</p> <p>When storing these as base class pointers:</p> <pre><code>vector&lt;Actor*&gt; m_vecActor; // Contains Player* and Enemy* stored as Actor*\n</code></pre> <p>Without a virtual destructor, deleting through the base pointer will only call the base class destructor:</p> <pre><code>// If Actor's destructor is not virtual\ndelete someActorPointer; // Only calls ~Actor(), not ~Player() or ~Enemy()\n</code></pre>"},{"location":"AR250501/#implementing-virtual-destructors","title":"Implementing Virtual Destructors","text":"<p>The solution is to declare the base class destructor as virtual:</p> <pre><code>class Actor \n{\npublic:\n    // Other members...\n\n    virtual ~Actor() {} // Virtual destructor ensures proper cleanup\n};\n</code></pre> <p>With this change, the appropriate derived class destructor will be called first, followed by the base class destructor, ensuring complete cleanup.</p>"},{"location":"AR250501/#interview-questions","title":"Interview Questions","text":"<p>Here are some challenging interview questions related to these concepts:</p> <ol> <li> <p>Q: Why should you prefer using a vector over a linked list for storing game actors that need to be updated every frame?    A: Although both have O(n) theoretical complexity for iteration, vectors offer better cache locality and fewer pointer dereferences, making them significantly faster for sequential access patterns common in game loops.</p> </li> <li> <p>Q: What is the purpose of forward declarations and when should you use them?    A: Forward declarations tell the compiler that a class exists without defining its structure. They should be used in header files when you only need pointers or references to a class, helping to reduce compilation dependencies and improve build times.</p> </li> <li> <p>Q: Why is it crucial to declare destructors as virtual in base classes used for polymorphism?    A: When deleting objects through base class pointers, only the base class destructor will be called unless it's declared virtual. Virtual destructors ensure that the appropriate derived class destructor is called first, followed by the base class destructor, preventing memory leaks.</p> </li> <li> <p>Q: In a client-server game architecture, what validation should the server perform to prevent cheating?    A: The server should validate player positions, verify line-of-sight for attacks, perform its own collision detection, and check the plausibility of reported actions. Never trust client-reported data for game-critical decisions.</p> </li> <li> <p>Q: How would you optimize GDI resource management in a Windows-based game?    A: Create common GDI resources (pens, brushes) once at initialization and store them for reuse. Use enumerations to organize and access them. Ensure proper cleanup when the application exits to prevent resource leaks.</p> </li> <li> <p>Q: How would you implement a level transition system in your game engine?    A: The Level Manager should handle creating new levels, destroying old ones, and managing the transition between them. This might involve fading screens, loading new assets, and ensuring all resources from the previous level are properly cleaned up.</p> </li> </ol>"},{"location":"AR250501/#conclusion","title":"Conclusion","text":"<p>Understanding these fundamental aspects of game engine architecture is essential for building efficient, maintainable games. From resource management to level organization, these principles form the foundation of well-designed game systems. Proper understanding of polymorphism, memory management, and optimization techniques will help you create robust game engines and perform well in technical interviews.</p> <p>The concepts covered in this article\u2014GDI resource management, level architecture, actor collections, and proper use of virtual destructors\u2014are not only theoretical knowledge but practical skills that directly impact the performance and maintainability of your game engine.</p>"},{"location":"Algorithm/HKUL1P1/","title":"Divide and Conquer","text":""},{"location":"Algorithm/HKUL1P1/#learning-outcome","title":"Learning Outcome","text":"<ul> <li>Learn how to analyze recursive algorithms.</li> <li>Understand the divide-and-conquer technique, recurrence relations, and recursive functions.</li> </ul>"},{"location":"Algorithm/HKUL1P1/#what-is-a-recursive-function","title":"What is a Recursive Function?","text":"<ul> <li>A recursive function calls itself with a smaller input.</li> <li>It consists of:<ul> <li>A base case that stops the recursion.</li> <li>A recursive case that breaks the problem into a smaller subproblem.</li> </ul> </li> </ul>"},{"location":"Algorithm/HKUL1P1/#example","title":"Example","text":"<p><pre><code>f(n) = 1                 if n = 1\nf(n) = f(n - 1) + n      if n &gt; 1\n</code></pre> To compute f(4): <pre><code>f(4) = f(3) + 4\n     = f(2) + 3 + 4\n     = f(1) + 2 + 7\n     = 1 + 9 = 10\n</code></pre></p>"},{"location":"Algorithm/HKUL1P1/#finding-a-closed-form-non-recursive-formula","title":"Finding a Closed Form (Non-Recursive Formula)","text":""},{"location":"Algorithm/HKUL1P1/#method-iteration","title":"Method: Iteration","text":"<p>By expanding the recurrence: <pre><code>f(n) = f(n-1) + n\n     = f(n-2) + (n-1) + n\n     = ...\n     = 1 + 2 + ... + n = n(n+1)/2\n</code></pre></p>"},{"location":"Algorithm/HKUL1P1/#mathematical-induction","title":"Mathematical Induction","text":"<p>To prove: f(n) = n(n+1)/2 - Base case: n = 1 \u2192 f(1) = 1, and 1(1+1)/2 = 1 \u2705 - Inductive step:   Assume f(k) = k(k+1)/2   Show f(k+1) = f(k) + (k+1) = k(k+1)/2 + (k+1) = (k+1)(k+2)/2 \u2705</p>"},{"location":"Algorithm/HKUL1P1/#asymptotic-analysis-big-o","title":"Asymptotic Analysis (Big-O)","text":"<p>We often care about the growth rate instead of the exact formula.</p>"},{"location":"Algorithm/HKUL1P1/#prove-fn-on2","title":"Prove: f(n) = O(n\u00b2)","text":"<p>We want to find a constant c such that f(n) \u2264 cn\u00b2 for all n \u2265 1.</p> <p>Step 1: Trial to find c <pre><code>f(n) = f(n-1) + n \u2264 c(n-1)\u00b2 + n = cn\u00b2 - (2cn - c - n)\n</code></pre> To ensure f(n) \u2264 cn\u00b2, we need: <pre><code>2cn - c - n \u2265 0 \u2192 c \u2265 n / (2n - 1)\n</code></pre> Since n / (2n - 1) \u2264 1 for all n \u2265 1, choose c = 1.</p> <p>Step 2: Induction proof - Base: f(1) = 1 \u2264 1\u00b2 - Inductive step:   Assume f(k) \u2264 k\u00b2   Then f(k+1) = f(k) + (k+1) \u2264 k\u00b2 + (k+1) \u2264 (k+1)\u00b2</p> <p>So, f(n) = O(n\u00b2) is proven.</p>"},{"location":"Algorithm/HKUL1P1/#take-home-exercise","title":"Take-home Exercise","text":"<p>Prove: f(n) = O(n), where <pre><code>f(1) = 3\nf(n) = f(n - 1) + 10 for n &gt; 1\n</code></pre></p>"},{"location":"Algorithm/HKUL1P1/#solving-recurrences-how-to-find-asymptotic-bounds","title":"Solving Recurrences (How to Find Asymptotic Bounds)","text":"<p>Here are three common techniques: 1. Substitution Method 2. Recursion Tree Method 3. Master Method</p> <p>These are detailed in MIT Introduction to Algorithms (CLRS), Chapters 4.3 to 4.5. While not a major exam topic, understanding them is useful for mastering algorithm analysis. You can review online materials or request a tutorial if needed.</p>"},{"location":"Algorithm/HKUL1P1/#divide-and-conquer-overview","title":"Divide and Conquer Overview","text":"<p>This approach leads to recursive algorithms. Their time complexity is usually described by recurrence relations.</p> <p>The general structure: 1. Divide the problem into subproblems 2. Conquer each subproblem recursively 3. Combine their solutions</p>"},{"location":"Algorithm/HKUL1P1/#factorial-example","title":"Factorial Example","text":""},{"location":"Algorithm/HKUL1P1/#recursive-code","title":"Recursive Code","text":"<pre><code>fact(n) {\n  if (n == 1) return 1;\n  else return n * fact(n-1);\n}\n</code></pre>"},{"location":"Algorithm/HKUL1P1/#time-complexity-analysis","title":"Time Complexity Analysis","text":"<p>Let T(n) be the runtime: - T(1) = c1 - T(n) = T(n - 1) + c2 (for n &gt; 1)</p> <p>Unfolding: <pre><code>T(n) = T(n-1) + c2\n     = T(n-2) + 2c2\n     = ...\n     = T(1) + (n - 1)c2 = c1 + (n - 1)c2\n</code></pre> Therefore, T(n) = O(n)</p> <p>This shows that the recursive factorial algorithm runs in linear time.</p>"},{"location":"Algorithm/HKUL1P1/#tower-of-hanoi-summary","title":"Tower of Hanoi - Summary","text":""},{"location":"Algorithm/HKUL1P1/#problem-overview","title":"Problem Overview","text":"<ul> <li>Given 3 pegs and n disks of different sizes stacked in increasing size on one peg (largest at bottom).</li> <li>Goal: Move all disks from the source peg to the destination peg.</li> </ul>"},{"location":"Algorithm/HKUL1P1/#rules","title":"Rules","text":"<ol> <li>Only one disk can be moved at a time.</li> <li>A disk can only be placed on top of a larger disk or an empty peg.</li> </ol>"},{"location":"Algorithm/HKUL1P1/#recursive-solution-strategy","title":"Recursive Solution Strategy","text":"<p>To move <code>n</code> disks from Peg A to Peg C using Peg B: 1. Move <code>n-1</code> disks from A to B (using C as auxiliary). 2. Move the largest disk (nth) from A to C. 3. Move the <code>n-1</code> disks from B to C (using A as auxiliary).</p>"},{"location":"Algorithm/HKUL1P1/#base-case","title":"Base Case","text":"<p>If <code>n = 1</code>: Move the single disk directly from A to C.</p>"},{"location":"Algorithm/HKUL1P1/#pseudocode","title":"Pseudocode","text":"<pre><code>TofH(A, B, C, n) {\n    if (n == 1)\n        move disk from A to C;\n    else {\n        TofH(A, C, B, n - 1);\n        move disk from A to C;\n        TofH(B, A, C, n - 1);\n    }\n}\n</code></pre>"},{"location":"Algorithm/HKUL1P1/#visual-explanation-for-n-3","title":"Visual Explanation for n = 3","text":""},{"location":"Algorithm/HKUL1P1/#initial-state","title":"Initial State","text":"<pre><code>Peg A       Peg B       Peg C\n[3]         |           |\n[2]         |           |\n[1]         |           |\n</code></pre>"},{"location":"Algorithm/HKUL1P1/#step-by-step-moves","title":"Step-by-step Moves","text":"<ol> <li> <p>Move 2 disks from A to B (use C):</p> <ul> <li>Move [1] A \u2192 C</li> <li>Move [2] A \u2192 B</li> <li>Move [1] C \u2192 B <pre><code>Peg A       Peg B       Peg C\n[3]         [2]         |\n            [1]         |\n</code></pre></li> </ul> </li> <li> <p>Move [3] A \u2192 C <pre><code>Peg A       Peg B       Peg C\n            [2]        [3]\n            [1]         |\n</code></pre></p> </li> <li> <p>Move 2 disks from B to C (use A):</p> <ul> <li>Move [1] B \u2192 A</li> <li>Move [2] B \u2192 C</li> <li>Move [1] A \u2192 C <pre><code>Peg A       Peg B       Peg C\n            |          [3]\n            |          [2]\n            |          [1]\n</code></pre></li> </ul> </li> </ol>"},{"location":"Algorithm/HKUL1P1/#number-of-moves","title":"Number of Moves","text":"<p>Let f(n) be the number of moves: - f(1) = 1 - f(n) = 2f(n-1) + 1</p> <p>Solving recurrence: <pre><code>f(n) = 2f(n - 1) + 1\n     = 2(2f(n - 2) + 1) + 1 = 4f(n - 2) + 3\n     = ...\n     = 2\u207f - 1\n</code></pre></p>"},{"location":"Algorithm/HKUL1P1/#time-complexity","title":"Time Complexity","text":"<ul> <li>Recursive algorithm performs <code>2\u207f - 1</code> moves</li> <li>\u21d2 Time complexity: O(2\u207f) (exponential)</li> </ul> <p>This version includes structured visuals and step-by-step logic for explaining Tower of Hanoi to students in an intuitive way. You can draw each state on a whiteboard or use the pseudocode and recurrence to connect with algorithm analysis.</p>"},{"location":"Algorithm/HKUL1P2/","title":"Tower of Hanoi","text":""},{"location":"Algorithm/HKUL1P2/#problem-overview","title":"Problem Overview","text":"<ul> <li>Given 3 pegs and n disks of different sizes stacked in increasing size on one peg (largest at bottom).</li> <li>Goal: Move all disks from the source peg to the destination peg.</li> </ul>"},{"location":"Algorithm/HKUL1P2/#rules","title":"Rules","text":"<ol> <li>Only one disk can be moved at a time.</li> <li>A disk can only be placed on top of a larger disk or an empty peg.</li> </ol>"},{"location":"Algorithm/HKUL1P2/#recursive-solution-strategy","title":"Recursive Solution Strategy","text":"<p>To move <code>n</code> disks from Peg A to Peg C using Peg B: 1. Move <code>n-1</code> disks from A to B (using C as auxiliary). 2. Move the largest disk (nth) from A to C. 3. Move the <code>n-1</code> disks from B to C (using A as auxiliary).</p>"},{"location":"Algorithm/HKUL1P2/#base-case","title":"Base Case","text":"<p>If <code>n = 1</code>: Move the single disk directly from A to C.</p>"},{"location":"Algorithm/HKUL1P2/#pseudocode","title":"Pseudocode","text":"<pre><code>TofH(A, B, C, n) {\n    if (n == 1)\n        move disk from A to C;\n    else {\n        TofH(A, C, B, n - 1);\n        move disk from A to C;\n        TofH(B, A, C, n - 1);\n    }\n}\n</code></pre>"},{"location":"Algorithm/HKUL1P2/#visual-explanation-for-n-3","title":"Visual Explanation for n = 3","text":""},{"location":"Algorithm/HKUL1P2/#initial-state","title":"Initial State","text":"<pre><code>Peg A       Peg B       Peg C\n[3]         |           |\n[2]         |           |\n[1]         |           |\n</code></pre>"},{"location":"Algorithm/HKUL1P2/#step-by-step-moves","title":"Step-by-step Moves","text":"<ol> <li> <p>Move 2 disks from A to B (use C):</p> <ul> <li>Move [1] A \u2192 C</li> <li>Move [2] A \u2192 B</li> <li>Move [1] C \u2192 B <pre><code>Peg A       Peg B       Peg C\n[3]         [2]         |\n            [1]         |\n</code></pre></li> </ul> </li> <li> <p>Move [3] A \u2192 C <pre><code>Peg A       Peg B       Peg C\n            [2]        [3]\n            [1]         |\n</code></pre></p> </li> <li> <p>Move 2 disks from B to C (use A):</p> <ul> <li>Move [1] B \u2192 A</li> <li>Move [2] B \u2192 C</li> <li>Move [1] A \u2192 C <pre><code>Peg A       Peg B       Peg C\n            |          [3]\n            |          [2]\n            |          [1]\n</code></pre></li> </ul> </li> </ol>"},{"location":"Algorithm/HKUL1P2/#number-of-moves","title":"Number of Moves","text":"<p>Let f(n) be the number of moves: - f(1) = 1 - f(n) = 2f(n-1) + 1</p> <p>Solving recurrence: <pre><code>f(n) = 2f(n - 1) + 1\n     = 2(2f(n - 2) + 1) + 1 = 4f(n - 2) + 3\n     = ...\n     = 2\u207f - 1\n</code></pre></p>"},{"location":"Algorithm/HKUL1P2/#time-complexity","title":"Time Complexity","text":"<ul> <li>Recursive algorithm performs <code>2\u207f - 1</code> moves</li> <li>\u21d2 Time complexity: O(2\u207f) (exponential)</li> </ul>"},{"location":"Algorithm/HKUL1P2/#incorrect-attempt-at-hanoi","title":"\u26a0\ufe0f Incorrect Attempt at Hanoi","text":"<p>Student\u2019s Wrong Approach: <pre><code>TofH2(A, B, C, n) {\n  if (n == 1)\n    move disk from A to C;\n  else {\n    TofH2(A, C, B, n/2);\n    TofH2(A, B, C, n/2);\n    TofH2(B, A, C, n/2);\n  }\n}\n</code></pre></p>"},{"location":"Algorithm/HKUL1P2/#why-its-incorrect","title":"Why It\u2019s Incorrect","text":"<ul> <li>Tower of Hanoi must preserve disk ordering.</li> <li>Splitting into <code>n/2</code> is invalid because it breaks the top-to-bottom size rule.</li> <li>The correct subproblem is always: move top <code>n-1</code> disks first.</li> </ul>"},{"location":"Algorithm/HKUL1P3/","title":"Divide-and-Conquer Approach","text":""},{"location":"Algorithm/HKUL1P3/#key-concepts","title":"Key Concepts","text":"<ol> <li> <p>Divide-and-Conquer Strategy:</p> <ul> <li>Solve a problem of size <code>n</code> by assuming solutions exist for smaller inputs (<code>n-1</code>, or <code>n/2</code>).</li> <li>Then, combine those solutions to build the solution for size <code>n</code>.</li> </ul> </li> <li> <p>Base Case is Essential:</p> <ul> <li>For factorial: <code>n! = 1</code> when <code>n = 1</code></li> <li>For Tower of Hanoi: Move 1 disk directly</li> </ul> </li> <li> <p>Steps in Divide-and-Conquer:</p> <ul> <li>Define subproblems</li> <li>Solve base cases</li> <li>Combine subproblem solutions</li> <li>Formulate a recursive algorithm</li> <li>Model running time as recurrence and solve it</li> </ul> </li> </ol>"},{"location":"Algorithm/HKUL1P3/#example-finding-the-maximum-number","title":"Example: Finding the Maximum Number","text":""},{"location":"Algorithm/HKUL1P3/#goal","title":"Goal","text":"<p>Find the largest value in an array using recursion.</p>"},{"location":"Algorithm/HKUL1P3/#strategy","title":"Strategy","text":"<ul> <li>Base Case: If one number, return it.</li> <li>Recursive Case: Compare the last number with the result from a recursive call on the rest.</li> </ul>"},{"location":"Algorithm/HKUL1P3/#pseudocode","title":"Pseudocode","text":"<pre><code>largest1(A[1..n]) {\n  if (n == 1) return A[1];\n  x = largest1(A[1..n-1]);\n  if (x &gt; A[n]) return x;\n  else return A[n];\n}\n</code></pre>"},{"location":"Algorithm/HKUL1P3/#time-complexity","title":"Time Complexity","text":"<ul> <li><code>T(n) = T(n-1) + c2</code>, <code>T(1) = c1</code></li> <li>\u21d2 T(n) = O(n)</li> </ul>"},{"location":"Algorithm/HKUL1P3/#example-execution","title":"Example Execution","text":"<pre><code>largest1([4, 60, 21, 3, 5])\n  \u2192 largest1([4, 60, 21, 3])\n    \u2192 largest1([4, 60, 21])\n      \u2192 largest1([4, 60])\n        \u2192 largest1([4]) \u2192 4\n        \u2192 return max(4, 60) \u2192 60\n      \u2192 return max(60, 21) \u2192 60\n    \u2192 return max(60, 3) \u2192 60\n  \u2192 return max(60, 5) \u2192 60\n</code></pre>"},{"location":"Algorithm/HKUL1P3/#divide-and-conquer-finding-the-largest-number-alternative-approach","title":"Divide and Conquer: Finding the Largest Number (Alternative Approach)","text":""},{"location":"Algorithm/HKUL1P3/#problem","title":"Problem:","text":"<p>Find the largest number in an array of size <code>n</code> using divide-and-conquer.</p>"},{"location":"Algorithm/HKUL1P3/#key-idea","title":"Key Idea:","text":"<ul> <li>Divide the array into two equal halves.</li> <li>Conquer each half recursively.</li> <li>Combine: Compare the maximums from both halves.</li> </ul>"},{"location":"Algorithm/HKUL1P3/#algorithm","title":"Algorithm:","text":"<pre><code>// Assume n is a power of 2 for simplicity\nlargest2(A[1..n]) {\n    if (n == 1)\n        return A[1];\n    else {\n        x1 = largest2(A[1..n/2]);\n        x2 = largest2(A[n/2+1..n]);\n        if (x1 &gt; x2)\n            return x1;\n        else\n            return x2;\n    }\n}\n</code></pre>"},{"location":"Algorithm/HKUL1P3/#time-complexity_1","title":"Time Complexity:","text":"<p>Let T(n) be the time taken to find the largest element in n numbers. - T(1) = c1 - T(n) = 2T(n/2) + c2 - Using Master Theorem, this gives T(n) = O(n)</p>"},{"location":"Algorithm/HKUL1P3/#example","title":"Example:","text":"<p>Array: [14, 65, 34, 33, 7, 56, 100, 20]</p> <p>Step-by-step recursive split: <pre><code>Left: [14, 65, 34, 33]           Right: [7, 56, 100, 20]\n  \u251c\u2500\u2500 [14, 65]                      \u251c\u2500\u2500 [7, 56]\n  \u2502     \u251c\u2500\u2500 14                     \u2502     \u251c\u2500\u2500 7\n  \u2502     \u2514\u2500\u2500 65                     \u2502     \u2514\u2500\u2500 56\n  \u2514\u2500\u2500 [34, 33]                     \u2514\u2500\u2500 [100, 20]\n        \u251c\u2500\u2500 34                           \u251c\u2500\u2500 100\n        \u2514\u2500\u2500 33                           \u2514\u2500\u2500 20\n</code></pre> Compare and propagate max values up: - max(14, 65) \u2192 65 - max(34, 33) \u2192 34 - max(65, 34) \u2192 65 - max(7, 56) \u2192 56 - max(100, 20) \u2192 100 - max(56, 100) \u2192 100 - final max: max(65, 100) \u2192 100</p>"},{"location":"Algorithm/HKUL1P3/#comparison-with-straightforward-approach","title":"Comparison with Straightforward Approach:","text":"<p><pre><code>largest(A[1..n]) {\n    maximum = A[1];\n    for (i = 2; i &lt;= n; i++) {\n        if (A[i] &gt; maximum)\n            maximum = A[i];\n    }\n    return maximum;\n}\n</code></pre> - Also O(n) time complexity. - This method is simpler, but the divide-and-conquer version helps practice recursion.</p>"},{"location":"Algorithm/HKUL1P3/#summary","title":"Summary:","text":"<ul> <li>Divide-and-conquer is not always the most efficient in practice but is helpful conceptually.</li> <li>Good for illustrating recursion and recurrence analysis.</li> </ul>"},{"location":"Algorithm/HKUL1P4/","title":"Master Theorem, Fibonacci Example","text":""},{"location":"Algorithm/HKUL1P4/#master-theorem-simplified-statement","title":"Master Theorem (Simplified Statement)","text":"<p>For recurrence of the form: <pre><code>T(n) = aT(n/b) + f(n)\n</code></pre> where: - <code>a \u2265 1</code> (number of subproblems) - <code>b \u2265 2</code> (factor of size reduction) - <code>f(n) = \u0398(n^p)</code> (non-recursive work per level)</p> <p>Then: - If <code>f(n) = O(n^{log_b a - \u03b5})</code> for some \u03b5 &gt; 0:     - T(n) = \u0398(n^{log_b a}) - If <code>f(n) = \u0398(n^{log_b a})</code>:     - T(n) = \u0398(n^{log_b a} log n) - If <code>f(n) = \u03a9(n^{log_b a + \u03b5})</code> and regularity condition holds:     - T(n) = \u0398(f(n))</p> <p>For cases where <code>n</code> is not a perfect power of <code>b</code>, the time complexity usually stays the same, but algorithms may require additional handling for leftover elements.</p>"},{"location":"Algorithm/HKUL1P4/#fibonacci-numbers-recursive-vs-iterative","title":"Fibonacci Numbers: Recursive vs Iterative","text":""},{"location":"Algorithm/HKUL1P4/#definition","title":"Definition:","text":"<pre><code>F(1) = 1\nF(2) = 1\nF(n) = F(n-1) + F(n-2) for n &gt; 2\n</code></pre>"},{"location":"Algorithm/HKUL1P4/#algorithm-1-naive-recursion","title":"Algorithm 1: Naive Recursion","text":"<p><pre><code>FIB1(n):\n  if n \u2264 2:\n    return 1\n  else:\n    return FIB1(n-1) + FIB1(n-2)\n</code></pre> - Recurrence:     - T(n) = T(n-1) + T(n-2) + c\u2082     - T(n) = exponential time (approximately \u0398(1.618^n)) - Inefficient: Recomputes many values</p> <p>Claim: T(n) &gt; 2^(n/2 - 1) - Recursive calls double roughly every two levels - Exponential growth due to repeated calls</p>"},{"location":"Algorithm/HKUL1P4/#algorithm-2-iterative-loop","title":"Algorithm 2: Iterative Loop","text":"<p><pre><code>FIB2(n):\n  if n \u2264 2:\n    return 1\n  p = 1\n  q = 1\n  for i = 3 to n:\n    r = p + q\n    p = q\n    q = r\n  return r\n</code></pre> - Time Complexity: \u0398(n) - Efficient: No redundant computations</p>"},{"location":"Algorithm/HKUL1P4/#q-can-we-do-even-better","title":"Q: Can We Do Even Better?","text":"<ul> <li>Yes! Matrix exponentiation or using Binet\u2019s formula (closed-form) can bring time complexity to O(log n).</li> <li>Example: Fast doubling or matrix power via divide-and-conquer.</li> </ul>"},{"location":"Algorithm/HKUL1P5/","title":"Fibonacci Numbers &amp; Matrix Exponentiation Summary","text":""},{"location":"Algorithm/HKUL1P5/#problem-compute-the-n-th-fibonacci-number-efficiently","title":"Problem: Compute the n-th Fibonacci number efficiently","text":"<p>We\u2019ve seen two common approaches:</p> <ol> <li> <p>Recursive (FIB1)</p> <ul> <li>Direct implementation of the recurrence.</li> <li>Time Complexity: Exponential, \\( T(n) = \\Theta(1.618^n) \\)</li> <li>Inefficient due to repeated computation.</li> </ul> </li> <li> <p>Iterative (FIB2)</p> <ul> <li>Uses a loop to iteratively build up to \\( F_n \\).</li> <li>Time Complexity: \\( \\Theta(n) \\)</li> <li>Much faster, but can we go even faster?</li> </ul> </li> </ol>"},{"location":"Algorithm/HKUL1P5/#matrix-exponentiation","title":"Matrix Exponentiation","text":"<p>Fibonacci numbers can be computed using matrix exponentiation:</p> <p>Let: <pre><code>    | 0 1 |\nA = | 1 1 |\n</code></pre> Then, <pre><code>    | F(n)   F(n+1) |\nA\u207f =| F(n-1) F(n)   |\n</code></pre></p> <p>To compute Fibonacci numbers, compute \\( A^{n-1} \\), and return the value at position (2,2).</p>"},{"location":"Algorithm/HKUL1P5/#matrix-power-algorithms","title":"Matrix Power Algorithms","text":"<p>1st Attempt: Straightforward Recursion <pre><code>Power1(A, n):\n  if (n == 1): return A\n  else: return Multiply(A, Power1(A, n-1))\n</code></pre> - Time: \\( O(n) \\)</p> <p>2nd Attempt: If n is a power of 2 <pre><code>Power2(A, n):\n  if (n == 1): return A\n  else:\n    B = Power2(A, n/2)\n    return Multiply(B, B)\n</code></pre> - Time: \\( O(\\log n) \\)</p> <p>3rd Attempt: General n (Odd or Even) <pre><code>Power3(A, n):\n  if (n == 1): return A\n  if (n is even):\n    B = Power3(A, n/2)\n    return Multiply(B, B)\n  else:\n    B = Power3(A, (n-1)/2)\n    return Multiply(A, Multiply(B, B))\n</code></pre> - Time: \\( O(\\log n) \\)</p>"},{"location":"Algorithm/HKUL1P5/#application-to-fibonacci","title":"Application to Fibonacci","text":"<ul> <li>Use the matrix: <pre><code>    | 0 1 |\n    | 1 1 |\n</code></pre></li> <li>Compute \\( A^{n-1} \\) using Power3 to get \\( F(n) \\) efficiently.</li> <li>Time Complexity: \\( O(\\log n) \\), very efficient for large n.</li> </ul>"},{"location":"Algorithm/HKUL1P6/","title":"Maximum Subarray Problem","text":"<p>Problem Statement: Given an array <code>A[1..n]</code> of integers, find a contiguous subarray (nonempty) whose sum is the largest among all possible contiguous subarrays.</p> <p>Example: A = [-4, 6, -3, -1, 6, 1, -2]</p> <p>The maximum subarray is A[2..6] = [6, -3, -1, 6, 1], and the sum is 9.</p> <p>1st Attempt: Brute-force Algorithm</p> <p>Idea: Try all possible subarrays and compute the sum of each.</p> <p>Algorithm (Max_subarray1): <pre><code>max = -inf;\nfor i = 1 to n:\n    for j = i to n:\n        sum = 0;\n        for k = i to j:\n            sum += A[k];\n        if sum &gt; max:\n            max = sum;\n            ans = (i, j, max);\nreturn ans;\n</code></pre> Time Complexity: O(n^3)</p> <p>Observation: The brute-force algorithm does a lot of redundant addition. For example: - For <code>i=1, j=2</code>: sum = A[1] + A[2] - For <code>i=1, j=3</code>: sum = A[1] + A[2] + A[3] (repeats the work done in <code>j=2</code>)</p> <p>2nd Attempt: Improved Brute-force</p> <p>Idea: Reuse the computed sums to avoid redundancy.</p> <p>Algorithm (Max_subarray2): <pre><code>max = -inf;\nfor i = 1 to n:\n    sum = 0;\n    for j = i to n:\n        sum += A[j];\n        if sum &gt; max:\n            max = sum;\n            ans = (i, j, max);\nreturn ans;\n</code></pre> Time Complexity: O(n^2)</p> <p>This version significantly improves performance by avoiding unnecessary recomputation of subarray sums.</p> <p>Next Step: Can we do even better? (Hint: use divide-and-conquer or dynamic programming)</p> <p>Maximum Subarray Problem (Divide-and-Conquer Approach)</p> <p>Goal: Given an array A[1..n] of integers, find a nonempty, contiguous subarray of A whose values have the largest sum.</p> <p>3rd Attempt: Divide-and-Conquer Approach</p> <p>Key Idea: - Divide the array into two halves around the midpoint. - Recursively solve the maximum subarray problem on the left half and the right half. - Additionally, find the maximum subarray that crosses the midpoint.</p>"},{"location":"Algorithm/HKUL1P6/#why","title":"Why?","text":"<p>Even if the best subarray doesn't lie entirely in one half, it may span both.</p> <p>Example: Array: <code>[3, -1, 3, -5, 4, 5, -8, 2, 0, 4]</code> - Left recursion returns max sum 5 for <code>[3, -1, 3]</code> - Right recursion returns max sum 6 for <code>[2, 0, 4]</code> - But crossing subarray <code>[4, 5]</code> yields sum 9 \u2014 the true maximum.</p>"},{"location":"Algorithm/HKUL1P6/#finding-maximum-subarray-across-the-middle","title":"Finding Maximum Subarray Across the Middle:","text":"<ul> <li>Find max sum from middle to left. <pre><code>max = -\u221e; sum = 0;\nfor i from mid downto 1:\n    sum += A[i]\n    if sum &gt; max:\n        max = sum; left_index = i\n</code></pre></li> <li>Find max sum from middle+1 to right. <pre><code>max = -\u221e; sum = 0;\nfor j from mid+1 to n:\n    sum += A[j]\n    if sum &gt; max:\n        max = sum; right_index = j\n</code></pre></li> <li>Combine both results into a crossing subarray.</li> <li>This takes O(n) time.</li> </ul>"},{"location":"Algorithm/HKUL1P6/#full-recursive-algorithm","title":"Full Recursive Algorithm:","text":"<pre><code>Max_subarray3(A, p, q):\n  if p == q:\n    return (p, q, A[p])\n\n  mid = (p + q) // 2\n  (i1, j1, max1) = Max_subarray3(A, p, mid)\n  (i2, j2, max2) = Max_subarray3(A, mid + 1, q)\n  (i3, j3, max3) = Max_subarray_middle(A, p, q)\n\n  if max1 &gt;= max2 and max1 &gt;= max3:\n    return (i1, j1, max1)\n  elif max2 &gt;= max3:\n    return (i2, j2, max2)\n  else:\n    return (i3, j3, max3)\n</code></pre> <p>Time Complexity: - T(n) = 2T(n/2) + cn  =&gt; T(n) = O(n log n)</p> <p>Can we do even better? (Hint: Yes \u2014 Kadane\u2019s Algorithm)</p>"},{"location":"Algorithm/HKUL1P7/","title":"Exercises Summary","text":"<p>1) Recursive Average of Array - Idea: Use a recursive function to compute the sum of the array and divide by the number of elements. - Algorithm:   <pre><code>avg(A[1..n]) {\n  if (n == 1) return A[1];\n  return (avg(A[1..n-1]) * (n-1) + A[n]) / n;\n}\n</code></pre> - Time Complexity: O(n), as each recursive call processes one element.</p> <p>2) Recursive Array Reversal - Idea: Swap the first and last elements and recurse on the subarray. - Algorithm:   <pre><code>reverse(A, start, end) {\n  if (start &gt;= end) return;\n  swap(A[start], A[end]);\n  reverse(A, start + 1, end - 1);\n}\n</code></pre> - Time Complexity: O(n), with only constant extra space used for recursion.</p> <p>3) Generating All n-bit Strings - Idea: Fix the last bit and recursively generate the first (n-1) bits. - Algorithm:   <pre><code>generate_bits(A, n) {\n  if (n == 0) {\n    print A;\n    return;\n  }\n  A[n] = 0;\n  generate_bits(A, n-1);\n  A[n] = 1;\n  generate_bits(A, n-1);\n}\n</code></pre> - Time Complexity: O(2^n), since there are 2^n combinations.</p> <p>4) Generating All Subsets of a Set - Idea: Use recursion to include or exclude each element. - Algorithm:   <pre><code>generate_subsets(set, i, current) {\n  if (i == set.length) {\n    print current;\n    return;\n  }\n  generate_subsets(set, i+1, current); // exclude\n  current.add(set[i]);\n  generate_subsets(set, i+1, current); // include\n  current.remove(set[i]);\n}\n</code></pre> - Time Complexity: O(2^n)</p> <p>5) Generating Subsets of Size &lt;= x - Idea: Modify the subset generation to track the current size. - Algorithm:   <pre><code>generate_limited_subsets(set, i, current, x) {\n  if (i == set.length) {\n    if (current.size() &lt;= x) print current;\n    return;\n  }\n  generate_limited_subsets(set, i+1, current, x); // exclude\n  if (current.size() &lt; x) {\n    current.add(set[i]);\n    generate_limited_subsets(set, i+1, current, x); // include\n    current.remove(set[i]);\n  }\n}\n</code></pre> - Time Complexity: O(2^n) worst-case, but may reduce depending on x.</p>"},{"location":"Algorithm/HKUL1P8/","title":"HKUL1P8","text":"<p>Summary &amp; Exam Guide: Recursion and Divide-and-Conquer</p>"},{"location":"Algorithm/HKUL1P8/#y-core-concepts-covered","title":"\u00f0\u0178\u201c\u2013 Core Concepts Covered","text":""},{"location":"Algorithm/HKUL1P8/#a-1-divide-and-conquer","title":"\u00e2\u0153\u2026 1. Divide and Conquer","text":"<ul> <li>Problem is split into subproblems, solved recursively, and solutions combined.</li> <li>Common recurrence: <code>T(n) = 2T(n/2) + cn</code></li> <li>Time complexity often solved via Master Theorem:<ul> <li>If <code>f(n) = \u00ce\u02dc(n^p)</code>, then:<ul> <li>If <code>a &gt; b^p</code> \u00e2\u017e\u201d <code>T(n) = \u00ce\u02dc(n^log_b a)</code></li> <li>If <code>a = b^p</code> \u00e2\u017e\u201d <code>T(n) = \u00ce\u02dc(n^p log n)</code></li> <li>If <code>a &lt; b^p</code> \u00e2\u017e\u201d <code>T(n) = \u00ce\u02dc(n^p)</code></li> </ul> </li> </ul> </li> </ul>"},{"location":"Algorithm/HKUL1P8/#a-2-recursion","title":"\u00e2\u0153\u2026 2. Recursion","text":"<ul> <li>Recursive algorithms must define:<ul> <li>Base case</li> <li>Recursive step</li> </ul> </li> <li>Should always aim to reduce the problem size.</li> </ul>"},{"location":"Algorithm/HKUL1P8/#a-3-recurrence-and-complexity","title":"\u00e2\u0153\u2026 3. Recurrence and Complexity","text":"<ul> <li>Learn to express recursive time complexity and simplify using:<ul> <li>Recursion Tree</li> <li>Master Theorem</li> </ul> </li> </ul>"},{"location":"Algorithm/HKUL1P8/#y-classic-recursive-problems","title":"\u00f0\u0178\u201d\u00a7 Classic Recursive Problems","text":""},{"location":"Algorithm/HKUL1P8/#a-largest-number-in-array","title":"\u00e2\u20ac\u00a2 Largest Number in Array","text":"<ul> <li>Divide array into halves.</li> <li>Base: single element</li> <li>Combine: return max of two halves</li> <li>Time Complexity: O(n)</li> </ul>"},{"location":"Algorithm/HKUL1P8/#a-fibonacci-numbers","title":"\u00e2\u20ac\u00a2 Fibonacci Numbers","text":"<ul> <li>Naive recursion: exponential time <code>T(n) = T(n-1) + T(n-2)</code></li> <li>Iterative: O(n)</li> <li>Matrix Exponentiation: O(log n)</li> </ul>"},{"location":"Algorithm/HKUL1P8/#a-maximum-subarray-problem","title":"\u00e2\u20ac\u00a2 Maximum Subarray Problem","text":"<ul> <li>Brute-force: O(n^3)</li> <li>Improved brute-force: O(n^2)</li> <li>Divide-and-conquer: O(n log n)</li> <li>(Optional) Kadane\u00e2\u20ac\u2122s algorithm: O(n)</li> </ul>"},{"location":"Algorithm/HKUL1P8/#a-matrix-exponentiation","title":"\u00e2\u20ac\u00a2 Matrix Exponentiation","text":"<ul> <li>Naive: O(n)</li> <li>Recursive squaring: O(log n)</li> </ul>"},{"location":"Algorithm/HKUL1P8/#a-key-implementation-exercises","title":"\u00e2\u0153\u00a8 Key Implementation Exercises","text":"<ol> <li>Average of Array: Use recursion to divide and compute average.</li> <li>Reverse Array: Swap elements recursively with constant space.</li> <li>Generate Binary Strings: Fix last bit recursively and backtrack.</li> <li>Generate Subsets: Include/exclude current element recursively.</li> </ol>"},{"location":"Algorithm/HKUL1P8/#ys-exam-tips","title":"\u00f0\u0178\u201c\u0161 Exam Tips","text":"<ul> <li>Know how to write recursive functions with correct base and recursive cases.</li> <li>Be able to analyze time complexity using recurrence relations.</li> <li>Understand where recursion is inefficient and should be replaced with iteration.</li> <li>Trace recursive calls and predict outputs.</li> </ul>"},{"location":"Algorithm/HKUL1P8/#y1-practice-questions-you-might-see","title":"\u00f0\u0178\u201d\u00b9 Practice Questions You Might See","text":"<ul> <li>Write a recursive algorithm to compute the average of numbers.</li> <li>Implement and analyze recursive Fibonacci.</li> <li>Use divide-and-conquer to solve max subarray problem.</li> <li>Derive time complexity from a given recursive function.</li> <li>Generate all subsets of a set recursively.</li> </ul>"},{"location":"Algorithm/HKUL1P8/#y-asymptotic-notation-key","title":"\u00f0\u0178\u201d\u00a4 Asymptotic Notation Key","text":"Symbol Name Meaning O Big-O Upper bound: f(n) grows at most as fast as g(n), up to constant factors \u00ce\u00a9 Big-Omega Lower bound: f(n) grows at least as fast as g(n), up to constant factors \u00ce\u02dc Big-Theta Tight bound: f(n) grows at the same rate as g(n), up to constant factors o Little-o Strictly slower: f(n) grows slower than g(n); f(n)/g(n) \u00e2\u2020\u2019 0 as n \u00e2\u2020\u2019 \u00e2\u02c6\u017e \u00cf\u2030 Little-omega Strictly faster: f(n) grows faster than g(n); f(n)/g(n) \u00e2\u2020\u2019 \u00e2\u02c6\u017e as n \u00e2\u2020\u2019 \u00e2\u02c6\u017e"},{"location":"Algorithm/HKUL1P8/#y-intuition-cheat-sheet","title":"\u00f0\u0178\u2019\u00a1 Intuition Cheat Sheet","text":"<ul> <li><code>f(n) = O(g(n))</code> \u00e2\u2020\u2019 f \u00e2\u2030\u00a4 g</li> <li><code>f(n) = \u00ce\u00a9(g(n))</code> \u00e2\u2020\u2019 f \u00e2\u2030\u00a5 g</li> <li><code>f(n) = \u00ce\u02dc(g(n))</code> \u00e2\u2020\u2019 f \u00e2\u2030\u02c6 g</li> <li><code>f(n) = o(g(n))</code> \u00e2\u2020\u2019 f \u00e2\u2030\u00aa g</li> <li><code>f(n) = \u00cf\u2030(g(n))</code> \u00e2\u2020\u2019 f \u00e2\u2030\u00ab g</li> </ul> <p>Would you like me to walk through that table now and fill in the T/F for each row based on these?</p>"},{"location":"Algorithm/HKUPSET1/","title":"HKUPSET1","text":"<ul> <li>\\( f(n) = O(g(n)) \\) \u2013 \u201cBig-O\u201d: f grows no faster than g (upper bound).</li> <li>\\( f(n) = \\Omega(g(n)) \\) \u2013 \u201cBig-Omega\u201d: f grows at least as fast as g (lower bound).</li> <li>\\( f(n) = \\Theta(g(n)) \\) \u2013 \u201cBig-Theta\u201d: f and g grow at the same rate.</li> <li>\\( f(n) = o(g(n)) \\) \u2013 \u201clittle-o\u201d: f grows strictly slower than g.</li> <li>\\( f(n) = \\omega(g(n)) \\) \u2013 \u201clittle-omega\u201d: f grows strictly faster than g.</li> </ul>"},{"location":"Algorithm/HKUPSET1/#lets-fill-out-the-table-for-each-pair","title":"Let's fill out the table for each pair:","text":"f(n) g(n) O \u2126 \u0398 o \u03c9 Explanation \\( n^2 \\) \\( n^3 \\) T F F T F \\( n^2 &lt; n^3 \\), strictly slower growth \\( 2^n \\) \\( \\log \\sqrt{n} \\) F T F F T Exponential &gt;&gt; any log variant \\( \\sqrt{\\log n} \\) \\( 3n \\) T F F T F Log grows much slower than linear \\( \\log^2 n \\) \\( \\log_{10}n \\) F T F F T \\( \\log^2 n = (\\log n)^2 \\) &gt;&gt; \\( \\log n \\) \\( n \\cos n \\) \\( \\sqrt{3} \\) F T F F T Oscillates but grows unbounded vs constant \\( \\sqrt{n} \\) \\( n \\) T F F T F Root is slower than linear"},{"location":"Algorithm/HKUPSET1/#final-completed-table","title":"Final Completed Table:","text":"f(n) g(n) O \u2126 \u0398 o \u03c9 \\( n^2 \\) \\( n^3 \\) T F F T F \\( 2^n \\) \\( \\log \\sqrt{n} \\) F T F F T \\( \\sqrt{\\log n} \\) \\( 3n \\) T F F T F \\( \\log^2 n \\) \\( \\log_{10}n \\) F T F F T \\( n \\cos n \\) \\( \\sqrt{3} \\) F T F F T \\( \\sqrt{n} \\) \\( n \\) T F F T F"},{"location":"Algorithm/HKU_Math/","title":"HKU Math","text":"<p>Mathematical Induction Proofs and Fibonacci Algorithms</p>"},{"location":"Algorithm/HKU_Math/#1-sum-of-first-n-natural-numbers","title":"1. Sum of First n Natural Numbers","text":"<p>We want to prove: [ f(n) = 1 + 2 + 3 + \\dots + n = \\frac{n(n + 1)}{2} ]</p>"},{"location":"Algorithm/HKU_Math/#case-1-base-case-n-1","title":"Case 1: Base Case (n = 1)","text":"\\[ f(1) = 1 = \\frac{1(1 + 1)}{2} = \\frac{2}{2} = 1 \\quad \\text{True} \\]"},{"location":"Algorithm/HKU_Math/#case-2-inductive-step","title":"Case 2: Inductive Step","text":"<p>Assume the formula works for some \\( k \\): [ f(k) = \\frac{k(k + 1)}{2} ]</p> <p>We want to prove it works for \\( k + 1 \\): [ f(k + 1) = f(k) + (k + 1) ] [ = \\frac{k(k + 1)}{2} + (k + 1) ] [ = \\frac{k(k + 1) + 2(k + 1)}{2} ] [ = \\frac{(k + 1)(k + 2)}{2} \\quad \\text{True} ]</p> <p>Conclusion: By induction, the formula holds for all \\( n \\in \\mathbb{N} \\).</p>"},{"location":"Algorithm/HKU_Math/#2-sum-of-squares","title":"2. Sum of Squares","text":"<p>We want to prove: [ \\sum_{i=1}^n i^2 = \\frac{n(n + 1)(2n + 1)}{6} ]</p>"},{"location":"Algorithm/HKU_Math/#case-1-base-case-n-1_1","title":"Case 1: Base Case (n = 1)","text":"\\[ \\frac{1 \\cdot 2 \\cdot 3}{6} = 1 \\quad \\text{True} \\]"},{"location":"Algorithm/HKU_Math/#case-2-inductive-step_1","title":"Case 2: Inductive Step","text":"<p>Assume it works for some \\( k \\): [ \\sum_{i=1}^k i^2 = \\frac{k(k + 1)(2k + 1)}{6} ]</p> <p>Show it holds for \\( k + 1 \\): [ \\sum_{i=1}^{k+1} i^2 = \\sum_{i=1}^k i^2 + (k + 1)^2 ] [ = \\frac{k(k + 1)(2k + 1)}{6} + (k + 1)^2 ]</p> <p>Combine: [ = \\frac{k(k + 1)(2k + 1) + 6(k + 1)^2}{6} ] [ = \\frac{(k + 1)(k(2k + 1) + 6(k + 1))}{6} ] [ = \\frac{(k + 1)(k + 2)(2k + 3)}{6} \\quad \\text{True} ]</p> <p>Conclusion: Formula is valid by induction.</p>"},{"location":"Algorithm/HKU_Math/#3-fibonacci-implementations","title":"3. Fibonacci Implementations","text":""},{"location":"Algorithm/HKU_Math/#recursive-version","title":"Recursive Version","text":"<p><pre><code>FIB1(n):\n  if n \u2264 2:\n    return 1\n  else:\n    return FIB1(n - 1) + FIB1(n - 2)\n</code></pre> - Time complexity: \\( O(2^n) \\) \u2014 very inefficient for large n.</p>"},{"location":"Algorithm/HKU_Math/#dynamic-programming-version","title":"Dynamic Programming Version","text":"<p><pre><code>FIB_ARRAY[n] = [0];\nvector&lt;int&gt; fib_array(n);\nfib_array.resize(n);\n\nFIBDP(n):\n  if n \u2264 2:\n    return 1\n  else if FIB_ARRAY[n] == 0:\n    FIB_ARRAY[n] = FIBDP(n - 1) + FIBDP(n - 2)\n  return FIB_ARRAY[n];\n</code></pre> - Time complexity: \\( O(n) \\) - Uses memoization to avoid recomputation.</p>"},{"location":"Algorithm/HKU_Math/#summary","title":"Summary","text":"<ul> <li>Induction proofs work by validating the base case and extending to \\( k + 1 \\) from \\( k \\).</li> <li>The sum of natural numbers and sum of squares are classic examples.</li> <li>Fibonacci recursion is elegant but inefficient; dynamic programming makes it scalable.</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250305/","title":"C++ Data Types and Basics","text":""},{"location":"C_C%2B%2B_Basics/AR250305/#date-2025-03-05","title":"Date: 2025-03-05","text":""},{"location":"C_C%2B%2B_Basics/AR250305/#key-points","title":"Key Points","text":"<ul> <li>Data types define the size and purpose of variables in memory.</li> <li>Each type has a default range and behavior, especially with signed vs unsigned.</li> <li>Type casting allows explicit conversion between types.</li> <li>Floating-point numbers follow the IEEE standard.</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250305/#overview","title":"Overview","text":"<p>In C++, data types determine how memory is allocated for variables and how operations are performed. Understanding data types is fundamental for both correctness and performance.</p>"},{"location":"C_C%2B%2B_Basics/AR250305/#primitive-data-types","title":"Primitive Data Types","text":""},{"location":"C_C%2B%2B_Basics/AR250305/#integer-types","title":"Integer Types","text":"<p>Integer types store whole numbers and can be either signed (default) or unsigned.</p> <pre><code>// Signed: can represent negative and positive values\nsigned char sc = 0;    // Range: -128 to 127\n\n// Unsigned: only non-negative values\nunsigned char uc = 0;  // Range: 0 to 255\n\nsc = 128;  // Triggers overflow, behavior is implementation-defined\nuc = 128;  // Valid\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250305/#integer-size-summary","title":"Integer Size Summary","text":"<ul> <li><code>bool</code> ??? 1 byte</li> <li><code>char</code> ??? 1 byte</li> <li><code>short</code> ??? 2 bytes</li> <li><code>int</code> ??? 4 bytes</li> <li><code>long</code> ??? 4 bytes (platform dependent)</li> <li><code>long long</code> ??? 8 bytes</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250305/#signed-vs-unsigned-behavior","title":"Signed vs Unsigned Behavior","text":"<p>Signed integers can represent both positive and negative values using two's complement representation. To convert a positive binary to its negative form, invert the bits and add 1.</p> <pre><code>char c = 256;                  // Overflow: wraps around to 0\nunsigned char unchar = -1;     // Stores 255 due to wrap-around\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250305/#floating-point-types","title":"Floating-Point Types","text":"<p>Floating-point types store real numbers, including decimals. They follow the IEEE 754 standard for binary representation.</p> <pre><code>float fData = 3.66f;  // 4 bytes\nfloat fResult;\n\nint iData = 20;\nfResult = (float)iData + fData;  // Type casting to float for precise addition\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250305/#initialization-vs-assignment","title":"Initialization vs Assignment","text":"<pre><code>int i = 10;     // Initialization\nfloat f;\nf = 20.5f;      // Assignment\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250305/#type-conversion-and-casting","title":"Type Conversion and Casting","text":""},{"location":"C_C%2B%2B_Basics/AR250305/#implicit-conversion","title":"Implicit Conversion","text":"<p>Assigning an integer to a float will automatically cast the value:</p> <pre><code>float f = 3;  // Implicitly becomes 3.0\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250305/#explicit-casting","title":"Explicit Casting","text":"<p>Use C-style casting for precise control:</p> <pre><code>float result = (float)iData + fData;\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250305/#common-mistakes","title":"Common Mistakes","text":"<p>Overflow on signed/unsigned types: <pre><code>signed char sc = 128;  // Undefined or implementation-defined\n</code></pre></p> <p>Assigning negative to unsigned types: <pre><code>unsigned char uc = -1; // Becomes 255\n</code></pre></p> <p>Assigning float to int: <pre><code>int i = 3.99;  // i = 3, truncates decimal part\n</code></pre></p>"},{"location":"C_C%2B%2B_Basics/AR250305/#interview-questions","title":"Interview Questions","text":"<p>Q: What is the difference between signed and unsigned types? A: Signed types represent both negative and positive values using two's complement. Unsigned types can only represent zero and positive values.</p> <p>Q: What happens when you assign a negative number to an unsigned variable? A: The value wraps around using modulo arithmetic. For example, <code>unsigned char uc = -1;</code> results in <code>uc = 255</code>.</p> <p>Q: What is the difference between float and double? A: <code>float</code> uses 4 bytes and has lower precision. <code>double</code> uses 8 bytes and offers higher precision for decimal values.</p> <p>Q: When should you use explicit casting in C++? A: When combining different data types in operations, such as adding an int to a float, or to avoid implicit conversion bugs.</p>"},{"location":"C_C%2B%2B_Basics/AR250305/#references","title":"References","text":"<ul> <li>data_type.cpp</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250306/","title":"Operators and Precedence","text":""},{"location":"C_C%2B%2B_Basics/AR250306/#date-2025-03-06","title":"Date: 2025-03-06","text":""},{"location":"C_C%2B%2B_Basics/AR250306/#key-points","title":"Key Points","text":"<ul> <li>Operators perform computations on variables and values.</li> <li>Operator precedence determines evaluation order in expressions.</li> <li>C++ includes arithmetic, assignment, comparison, logical, and increment/decrement operators.</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250306/#arithmetic-operators","title":"Arithmetic Operators","text":"<pre><code>int a = 10, b = 3;\n\nint sum = a + b;    // 13\nint diff = a - b;   // 7\nint prod = a * b;   // 30\nint div = a / b;    // 3 (integer division)\nint mod = a % b;    // 1 (remainder)\n</code></pre> <ul> <li>When both operands are integers, division truncates the result.</li> <li><code>%</code> is only applicable to integers.</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250306/#floating-point-division","title":"Floating-Point Division","text":"<pre><code>float fdiv = 10.f / 3.f;    // 3.333...\ndouble ddiv = 10.0 / 3.0;   // 3.333...\n</code></pre> <ul> <li>Floating-point division returns a more accurate result.</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250306/#assignment-operator","title":"Assignment Operator","text":"<pre><code>int x = 5;  // Assigns value 5 to x\n</code></pre> <ul> <li><code>=</code> assigns the right-hand side value to the left-hand variable.</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250306/#increment-and-decrement","title":"Increment and Decrement","text":"<pre><code>int num = 0;\n\n++num; // Pre-increment: increment before use\n--num; // Pre-decrement\n\nnum++; // Post-increment: use before increment\ndec--; // Post-decrement\n\nint result = num++;  // result gets old num; num is incremented afterward\n</code></pre> <ul> <li>Pre-increment/decrement has higher precedence than post.</li> <li>Mixed with other expressions, they can affect evaluation order.</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250306/#comparison-operators","title":"Comparison Operators","text":"<pre><code>int a = 10, b = 20;\n\nbool isEqual = (a == b);   // false\nbool isNotEqual = (a != b);// true\nbool isGreater = (a &gt; b);  // false\nbool isLessEqual = (a &lt;= b); // true\n</code></pre> <ul> <li>Always return boolean values: <code>true</code> or <code>false</code>.</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250306/#boolean-and-logical-operators","title":"Boolean and Logical Operators","text":"<pre><code>bool result1 = true &amp;&amp; false;  // false (AND)\nbool result2 = true || false;  // true  (OR)\nbool result3 = !true;          // false (NOT)\n</code></pre> <ul> <li><code>&amp;&amp;</code>, <code>||</code> use short-circuit evaluation.</li> <li>Only <code>0</code> is false; all non-zero integers are considered true.</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250306/#operator-precedence-example","title":"Operator Precedence Example","text":"<pre><code>int x = 10, y = 20;\nbool result = x++ &lt; y &amp;&amp; y++ &gt; 15;\n</code></pre> <ul> <li><code>x++ &lt; y</code>: <code>x</code> is compared first, then incremented.</li> <li><code>&amp;&amp;</code>: evaluates only if the first condition is true.</li> <li><code>y++ &gt; 15</code>: executed only if <code>x++ &lt; y</code> is true.</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250306/#tricky-case-precedence-pitfall","title":"Tricky Case: Precedence Pitfall","text":"<pre><code>int i = 10;\nint j = i++ * 2 + ++i;\n</code></pre> <p>Step-by-step evaluation: - <code>i++</code> = 10 (then i becomes 11) - <code>++i</code> = 12 (i becomes 12 before use) - <code>j = 10 * 2 + 12 = 32</code></p>"},{"location":"C_C%2B%2B_Basics/AR250306/#interview-questions","title":"Interview Questions","text":"<p>Q: What's the difference between <code>++i</code> and <code>i++</code>? A: <code>++i</code> increments the value before it's used in the expression, while <code>i++</code> uses the current value and then increments.</p> <p>Q: What happens when mixing <code>&amp;&amp;</code>, <code>||</code>, and comparison operators in one expression? A: C++ follows operator precedence rules: comparison operators are evaluated first, then logical AND (<code>&amp;&amp;</code>), then logical OR (<code>||</code>). Use parentheses for clarity.</p> <p>Q: What\u2019s short-circuit evaluation? A: In logical expressions, <code>&amp;&amp;</code> stops evaluating if the first condition is false, and <code>||</code> stops if the first is true. This avoids unnecessary computation.</p>"},{"location":"C_C%2B%2B_Basics/AR250306/#references","title":"References","text":"<ul> <li>data_type.cpp</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250307/","title":"Control Flow in C++","text":""},{"location":"C_C%2B%2B_Basics/AR250307/#date-2025-03-07","title":"Date: 2025-03-07","text":""},{"location":"C_C%2B%2B_Basics/AR250307/#key-points","title":"Key Points","text":"<ul> <li>Control flow directs the order of execution in programs.</li> <li><code>if</code>, <code>else if</code>, <code>else</code> allow conditional execution.</li> <li><code>switch-case</code> enables value-based branching.</li> <li>Logical expressions (<code>&amp;&amp;</code>, <code>||</code>, <code>!</code>) are key in decision making.</li> <li>Only the first satisfied condition in <code>if-else if</code> chain is executed.</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250307/#overview","title":"Overview","text":"<p>Control flow determines which parts of code get executed and in what order. It is essential for making decisions, handling conditions, and branching logic. In C++, control flow constructs include conditional statements like <code>if</code>, <code>else if</code>, <code>else</code>, and multi-way branching using <code>switch-case</code>.</p>"},{"location":"C_C%2B%2B_Basics/AR250307/#conditional-statements","title":"Conditional Statements","text":""},{"location":"C_C%2B%2B_Basics/AR250307/#if-else-if-else","title":"If, Else If, Else","text":"<pre><code>int HP = 0;\n\n// If HP is greater than 80\nif (80 &lt; HP) {\n    int a = 0;\n}\n// If HP is greater than 60 but less than or equal to 80\nelse if (60 &lt; HP) {\n    int a = 0;\n}\n// If HP is greater than 40 but less than or equal to 60\nelse if (40 &lt; HP) {\n    int a = 0;\n}\n// If HP is greater than 20 but less than or equal to 40\nelse if (20 &lt; HP) {\n    int a = 0;\n}\n// If all above conditions fail\nelse {\n    int a = 0;\n}\n</code></pre> <ul> <li><code>else if</code> conditions are only checked if previous ones fail.</li> <li>Only one block will execute in a single <code>if-else if-else</code> chain.</li> <li>If you want all conditions checked independently, use separate <code>if</code> statements.</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250307/#logical-operators-in-conditions","title":"Logical Operators in Conditions","text":"<pre><code>int IsTrue = 10 &amp;&amp; 0;    // false\nIsTrue = 1 || 0;         // true\nIsTrue = !IsTrue;        // false\n</code></pre> <ul> <li><code>&amp;&amp;</code> (logical AND) returns true if both operands are true.</li> <li><code>||</code> (logical OR) returns true if at least one operand is true.</li> <li><code>!</code> (logical NOT) inverts the boolean value.</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250307/#interview-questions","title":"Interview Questions","text":"<p>Q: What is the difference between <code>if-else if</code> and multiple <code>if</code> statements? A: In <code>if-else if</code>, only the first true condition is executed; remaining conditions are skipped. Multiple <code>if</code> statements are evaluated independently.</p> <p>Q: What happens if multiple <code>else if</code> conditions are true? A: Only the first true condition??\uc172 block is executed; the rest are ignored.</p> <p>Q: How does short-circuiting work in logical expressions? A: In expressions like <code>a &amp;&amp; b</code>, if <code>a</code> is false, <code>b</code> is not evaluated. Similarly, in <code>a || b</code>, if <code>a</code> is true, <code>b</code> is skipped.</p>"},{"location":"C_C%2B%2B_Basics/AR250307/#references","title":"References","text":"<ul> <li>data_type.cpp</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250310/","title":"Bitwise Operators &amp; Preprocessor Macros","text":""},{"location":"C_C%2B%2B_Basics/AR250310/#date-2025-03-10","title":"Date: 2025-03-10","text":""},{"location":"C_C%2B%2B_Basics/AR250310/#key-points","title":"Key Points","text":"<ul> <li>Macros simplify complex or frequently-used expressions.</li> <li>Bitwise operators manipulate data at the bit level.</li> <li>Use <code>unsigned</code> types with bitwise operations to avoid signed behavior issues.</li> <li>Bit masks efficiently represent multiple boolean flags in a single variable.</li> <li>Combine and check bitwise states using <code>|</code>, <code>&amp;</code>, <code>^</code>, <code>~</code>, and shift operators.</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250310/#overview","title":"Overview","text":"<p>C++ provides a rich set of bitwise operators that are useful for low-level programming tasks. When used correctly with <code>#define</code> macros, they can improve both code clarity and performance??\ubd22specially in scenarios like setting and checking character statuses in games.</p> <p>The <code>#define</code> preprocessor directive is used to define constants or macro functions that can simplify repetitive or verbose code patterns.</p>"},{"location":"C_C%2B%2B_Basics/AR250310/#bit-mask-macros","title":"Bit Mask Macros","text":"<pre><code>#define MY int\n#define MAX_FLOOR 60\n\n#define ATT_UP     0x1\n#define DEF_UP     0x2\n#define DEX_UP     0x4\n#define SPEED_UP   0x8\n#define ATT_DOWN   0x10\n#define DEF_DOWN   0x20\n#define DEX_DOWN   0x40\n#define SPEED_DOWN 0x80\n\n#define EVENT_POTION (ATT_UP | DEF_UP | DEX_UP | SPEED_UP)\n</code></pre> <p>These macros define constants using hexadecimal values where each constant represents a unique bit flag. <code>EVENT_POTION</code> combines several buffs using the bitwise OR operator (<code>|</code>).</p>"},{"location":"C_C%2B%2B_Basics/AR250310/#bitwise-operators","title":"Bitwise Operators","text":""},{"location":"C_C%2B%2B_Basics/AR250310/#left-shift","title":"Left Shift (<code>&lt;&lt;</code>)","text":"<p>Doubles the value for each shift to the left. <pre><code>int a = 2 &lt;&lt; 3; // a = 16 (2 * 2^3)\n</code></pre></p>"},{"location":"C_C%2B%2B_Basics/AR250310/#right-shift","title":"Right Shift (<code>&gt;&gt;</code>)","text":"<p>Halves the value for each shift to the right. <pre><code>unsigned char c = 127;\nc = c &gt;&gt; 1; // c = 63\n</code></pre></p> <p>Use <code>unsigned</code> types to avoid unexpected behavior due to sign bit propagation in signed integers.</p>"},{"location":"C_C%2B%2B_Basics/AR250310/#bitwise-and-or-xor-not","title":"Bitwise AND, OR, XOR, NOT","text":"<pre><code>unsigned char c1 = 10;   // 0000 1010\nunsigned char c2 = 2;    // 0000 0010\n\nunsigned char c3 = c1 &amp; c2; // AND: 0000 0010\nc3 = c1 | c2;               // OR:  0000 1010\nc1 = ~c1;                   // NOT: 1111 0101 (bitwise inverse)\nc3 = c1 ^ c2;               // XOR: 0000 1000\n</code></pre> <p>You can also use compound assignment operators for clarity: <pre><code>c3 += 2;  // Instead of: c3 = c3 + 2\n</code></pre></p>"},{"location":"C_C%2B%2B_Basics/AR250310/#character-status-flags","title":"Character Status Flags","text":"<p>Use a single variable to hold multiple flags.</p> <pre><code>unsigned long long CharStat = 0;\n\nCharStat |= ATT_UP;\nCharStat |= DEF_UP;\nCharStat |= DEX_UP;\nCharStat |= SPEED_UP;\n</code></pre> <p>Check if a flag is set: <pre><code>if (CharStat &amp; DEF_UP) {\n    // DEF_UP is active\n}\n</code></pre></p> <p>Remove a flag using XOR (toggles the bit): <pre><code>if (CharStat &amp; SPEED_UP) {\n    CharStat ^= SPEED_UP;\n}\n</code></pre></p> <p>Forcefully clear a flag using AND with NOT: <pre><code>CharStat &amp;= ~SPEED_UP; // Clear SPEED_UP\n</code></pre></p> <p>Re-apply a predefined buff combination: <pre><code>CharStat |= EVENT_POTION;\n</code></pre></p>"},{"location":"C_C%2B%2B_Basics/AR250310/#tricky-case-signed-vs-unsigned-shift","title":"Tricky Case: Signed vs Unsigned Shift","text":"<p>Avoid right-shifting signed integers, as the behavior of sign bit propagation may differ between platforms.</p> <pre><code>char c = -1;\nc = c &gt;&gt; 1; // May retain sign bit (platform-dependent)\n\n// Use unsigned instead:\nunsigned char c = -1; // Interpreted as 255\nc = c &gt;&gt; 1;           // Safe right shift\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250310/#interview-questions","title":"Interview Questions","text":"<p>Q: Why use <code>unsigned</code> types with bitwise operations? A: Signed types may cause platform-dependent behavior during right shifts and logical operations due to sign bit extension. Unsigned ensures consistent results.</p> <p>Q: What??\uc172 the difference between <code>|</code>, <code>^</code>, and <code>&amp;</code>? A: <code>|</code> sets bits, <code>&amp;</code> checks or clears bits, <code>^</code> toggles bits. Used with bit masks to manipulate flags.</p> <p>Q: How do you clear a specific bit in a bitmask? A: Use <code>bitmask &amp;= ~BIT_FLAG;</code> to forcefully turn off the bit.</p> <p>Q: When should you use macros vs <code>const</code> or <code>enum</code>? A: Use macros for preprocessor control or platform-specific conditions. Prefer <code>const</code> or <code>enum class</code> for type safety in C++.</p>"},{"location":"C_C%2B%2B_Basics/AR250310/#visual-bit-flag-example","title":"Visual: Bit Flag Example","text":"<pre><code>Initial:        0000 0000\n+ATT_UP:        0000 0001\n+DEF_UP:        0000 0011\n+DEX_UP:        0000 0111\n+SPEED_UP:      0000 1111\n~SPEED_UP:      1111 0111 (Mask)\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250310/#references","title":"References","text":"<ul> <li>data_type.cpp</li> <li>bit_operator.cpp</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250311/","title":"Local Variables, Arrays, &amp; Loops","text":""},{"location":"C_C%2B%2B_Basics/AR250311/#date-2025-03-11","title":"Date: 2025-03-11","text":""},{"location":"C_C%2B%2B_Basics/AR250311/#key-points","title":"Key Points","text":"<ul> <li>Local variables are scoped to blocks and their lifetime ends with the block.</li> <li>Variable name collisions in nested scopes cause ambiguity.</li> <li>Arrays occupy continuous memory; their name points to the starting address.</li> <li>Use <code>sizeof()</code> to determine array size in memory.</li> <li>Loops allow repetitive execution of code blocks; be cautious of infinite loops.</li> <li><code>break</code> exits a loop immediately; <code>continue</code> skips the current iteration.</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250311/#overview","title":"Overview","text":"<p>This example introduces basic concepts in C++, including: - Local variable scoping - Arrays and memory layout - Control flow using <code>while</code>, <code>for</code>, and nested loops</p> <p>We also touch on size evaluation using <code>sizeof()</code> and demonstrate a star-pattern using nested loops.</p>"},{"location":"C_C%2B%2B_Basics/AR250311/#local-variables-and-scope","title":"Local Variables and Scope","text":"<p>Variables declared inside functions are local. Re-declaring a variable name in a nested scope creates ambiguity if not managed properly:</p> <pre><code>int a1 = 0;\n{\n    int a1 = 0; // Hides outer a1\n    a1 = 10;\n    {\n        int a1 = 0; // Hides above a1\n    }\n}\na1 = 10; // Refers to the outermost a1\n</code></pre> <p>Variables declared in a scope are destroyed once the block ends, but the memory might not be immediately released.</p>"},{"location":"C_C%2B%2B_Basics/AR250311/#arrays-in-c","title":"Arrays in C++","text":"<p>Arrays consist of elements stored in contiguous memory. The array name represents the starting address.</p> <pre><code>int Arr[10] = {1, 2}; // Remaining elements initialized to 0\n\nArr[0] = 10;\nArr[1] = 20;\nArr[9] = 100;\n\nint data = Arr[9]; // Accessing the last element\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250311/#size-calculation","title":"Size Calculation","text":"<pre><code>int size = sizeof(Arr);             // Total byte size\nint ArrCount = sizeof(Arr) / sizeof(int); // Number of elements\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250311/#loops","title":"Loops","text":""},{"location":"C_C%2B%2B_Basics/AR250311/#while-loop","title":"While Loop","text":"<pre><code>int Count = 0;\nwhile (Count &lt; 4) {\n    ++Count;\n}\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250311/#infinite-loop-with-break","title":"Infinite Loop with <code>break</code>","text":"<pre><code>int C = 0;\nwhile (1) {\n    ++C;\n    if (C == 4) break;\n}\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250311/#for-loop-with-commented-game-logic","title":"For Loop with Commented Game Logic","text":"<pre><code>for (int Count = 0; Count &lt; 4; ++Count) {\n    // if (Object[Count]-&gt;IsMonster()) {\n    //     SetDamage(Object[Count]);\n    // } else {\n    //     continue;\n    // }\n}\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250311/#populating-array-with-loop","title":"Populating Array with Loop","text":"<pre><code>for (int i = 0; i &lt; ArrCount; ++i) {\n    Arr[i] = (i + 1) * 10;\n    printf(\"Output\\n\");\n}\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250311/#nested-loop-triangle-star-pattern","title":"Nested Loop: Triangle Star Pattern","text":"<p><pre><code>int Num = 5;\nfor (int j = 0; j &lt; Num; ++j) {\n    for (int i = 0; i &lt; (j + 1); ++i) {\n        printf(\"*\");\n    }\n    printf(\"\\n\");\n}\n</code></pre> This prints: <pre><code>*\n**\n***\n****\n*****\n</code></pre></p>"},{"location":"C_C%2B%2B_Basics/AR250311/#homework-tip","title":"Homework Tip","text":"<p>Print a balanced tree star pattern using nested loops and space alignment: <pre><code>    *\n   * *\n  * * *\n * * * *\n* * * * *\n</code></pre> Use careful spacing before the <code>*</code> in each row.</p>"},{"location":"C_C%2B%2B_Basics/AR250311/#_1","title":"Local Variables, Arrays, &amp; Loops","text":"<p>Homework Code  <pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n    unsigned int n = 10; \n    // std::cin &gt;&gt; n; \n\n    for (unsigned int i = 0; i &lt; n; ++i)\n    {\n        for (unsigned int j = 1; j &lt; n-i; ++j)\n        {\n            std::cout &lt;&lt; \" \";  \n        }\n\n        for (unsigned int j = 0; j &lt; i; ++j)\n        {\n            std::cout &lt;&lt; \" \";\n            std::cout &lt;&lt; \"*\";\n        }\n\n        std::cout &lt;&lt; \"\\n\";\n    }\n}\n</code></pre></p> <p>Works well. </p>"},{"location":"C_C%2B%2B_Basics/AR250311/#sample-interview-questions","title":"Sample Interview Questions","text":"<p>Q: What happens if you declare a variable with the same name in an inner scope? A: It hides the outer variable. Only the innermost declared variable is visible within its scope.</p> <p>Q: How do arrays behave in memory? A: Array elements are stored in contiguous memory blocks. The array name acts as the pointer to its first element.</p> <p>Q: What is the difference between <code>break</code> and <code>continue</code> in a loop? A: <code>break</code> exits the loop immediately; <code>continue</code> skips to the next iteration.</p> <p>Q: Why is <code>sizeof</code> useful in loops? A: It helps calculate the number of elements in a statically declared array, which avoids hardcoding loop limits.</p>"},{"location":"C_C%2B%2B_Basics/AR250311/#references","title":"References","text":"<ul> <li>Array_Iteration.cpp</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250312/","title":"Structs and Functions","text":""},{"location":"C_C%2B%2B_Basics/AR250312/#date-2025-03-12","title":"Date: 2025-03-12","text":""},{"location":"C_C%2B%2B_Basics/AR250312/#key-points","title":"Key Points","text":"<ul> <li>Structs in C++ can include both variables and functions.</li> <li><code>typedef</code> can simplify type declarations and increase readability.</li> <li>Structs can be nested to represent composite data.</li> <li>Functions modularize logic and support code reuse.</li> <li>Default function arguments simplify function calls.</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250312/#overview","title":"Overview","text":"<p>Structs in C and C++ allow the creation of user-defined data types. C++ enhances struct capabilities by allowing member functions. Structs are crucial for organizing related variables under a single composite type.</p> <p>Functions in C++ help break down logic into reusable blocks. They support return types, parameters, and default arguments for flexible usage.</p> <pre><code>// Simple struct with member variables\nstruct MyType {\n    int I;\n    float F;\n};\n\n// Nested struct example\nstruct NewType {\n    MyType type;\n    int Age;\n    int Height;\n};\n\n// C-style struct with typedef\ntypedef struct Player {\n    int MaxHP;\n    int CurHP;\n    int Att;\n    int Def;\n    int Dex;\n    int Agi;\n    int Int;\n} PLAYER;\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250312/#typedef-and-aliasing","title":"Typedef and Aliasing","text":"<p><code>typedef</code> simplifies complex type declarations. It helps improve readability and maintainability.</p> <pre><code>typedef int INT;\ntypedef int SIZE;\ntypedef int TIME;\n\nINT a = 0;\nSIZE b = 0;\nTIME c = 0;\n</code></pre> <p>You can also typedef structs:</p> <pre><code>typedef struct Monster {\n    int i;\n    char c;\n    short s;\n} MONSTER;\n\nMonster n = {};\nMONSTER m = {};\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250312/#code-demonstration-struct-usage","title":"Code Demonstration: Struct Usage","text":"<pre><code>int main() {\n    struct Player p;   // C-style declaration\n    PLAYER p1;         // Typedef alias\n\n    struct MyType t1;\n    MyType t;\n\n    t.I = 100;\n    t.F = 1.1111f;\n\n    int size = sizeof(MyType);  // size of the struct\n\n    return 0;\n}\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250312/#functions-in-c","title":"Functions in C++","text":"<p>Functions modularize code, allowing you to write logic once and reuse it. Default parameters provide flexibility for function calls.</p> <pre><code>// Function with a default argument\nint Add(int _a, int _b, int _c = 0) {\n    int c = _a + _b;\n    return c;\n}\n\n// Function with void return type\nvoid TestFunc() {\n    return;  // ends function execution early\n}\n</code></pre> <p>Calling a function with fewer arguments uses the default:</p> <pre><code>int main() {\n    int Data = Add(10, 20);  // _c defaults to 0\n    return 0;\n}\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250312/#tricky-case-typedef-confusion","title":"Tricky Case: Typedef Confusion","text":"<p>Issue: Mixing C-style and C++-style struct names can confuse beginners.</p> <pre><code>typedef struct Monster {\n    int i;\n    char c;\n    short s;\n} MONSTER;\n\nMonster n = {};  // Using the struct name\nMONSTER m = {};  // Using the typedef alias\n</code></pre> <p>Both <code>Monster</code> and <code>MONSTER</code> refer to the same structure type, which can cause ambiguity in naming conventions.</p>"},{"location":"C_C%2B%2B_Basics/AR250312/#interview-questions","title":"Interview Questions","text":"<p>Q: What's the difference between <code>struct</code> in C and C++? A: In C, <code>struct</code> only supports data members. In C++, structs can have functions, constructors, destructors, and access specifiers (default is public).</p> <p>Q: What is the use of <code>typedef</code> in C++? A: It creates aliases for types, making code easier to read and manage, especially for complex types like structs or function pointers.</p> <p>Q: How do default arguments in functions work? A: They allow omission of arguments during function calls. Defaults must be provided from right to left in the parameter list.</p> <p>Q: Can <code>typedef</code> be replaced in modern C++? A: Yes, <code>using</code> is preferred in modern C++ for type aliasing.</p>"},{"location":"C_C%2B%2B_Basics/AR250312/#visual-struct-with-nested-members","title":"Visual: Struct with Nested Members","text":"<pre><code>MyType\n------\nI : int\nF : float\n\nNewType\n--------\ntype   : MyType\nAge    : int\nHeight : int\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250312/#references","title":"References","text":"<ul> <li>array_iteration.cpp</li> <li>switch_case.cpp</li> <li>struct.cpp</li> <li>function.cpp</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250313/","title":"Recursion and Function Mechanics","text":""},{"location":"C_C%2B%2B_Basics/AR250313/#date-2025-03-13","title":"Date: 2025-03-13","text":""},{"location":"C_C%2B%2B_Basics/AR250313/#key-points","title":"Key Points","text":"<ul> <li>Recursion involves a function calling itself.</li> <li>Recursive functions must include a termination condition to prevent infinite calls.</li> <li>Iterative approaches can replace recursion for performance.</li> <li>Local variables are stored in the stack during function calls.</li> <li>Stack overflow can occur if recursion is too deep or unbounded.</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250313/#overview","title":"Overview","text":"<p>Functions in C++ are modular blocks of code that perform a specific task. Understanding how they work at runtime and how memory is allocated during execution is essential for debugging and optimizing performance. Recursive functions, in particular, are elegant for solving hierarchical problems but require careful handling.</p>"},{"location":"C_C%2B%2B_Basics/AR250313/#iterative-factorial-function","title":"Iterative Factorial Function","text":"<pre><code>// Calculates N! using iteration\nint Factorial(int _N)\n{\n    int Value = 1;\n\n    for (int i = 0; i &lt; _N - 1; ++i)\n    {\n        Value *= (i + 2);\n    }\n\n    return Value;\n}\n</code></pre> <p>This function computes factorial using a for-loop, multiplying from 2 to N. It avoids stack usage beyond the function call.</p>"},{"location":"C_C%2B%2B_Basics/AR250313/#recursive-factorial-function","title":"Recursive Factorial Function","text":"<pre><code>// Calculates N! using recursion\nint Factorial_Recursion(int _N)\n{\n    if (_N == 1)\n        return 1;\n\n    return Factorial_Recursion(_N - 1) * _N;\n}\n</code></pre> <p>This approach uses the call stack to solve the problem. It's more readable but can lead to stack overflow for large values.</p>"},{"location":"C_C%2B%2B_Basics/AR250313/#power-function-iterative","title":"Power Function (Iterative)","text":"<pre><code>int Pow(int _a, int _b)\n{\n    int Value = 1;\n\n    for (int i = 0; i &lt; _b; ++i)\n    {\n        Value *= _a;\n    }\n\n    return Value;\n}\n</code></pre> <p>Raises <code>_a</code> to the power <code>_b</code> using a loop. Simple and avoids recursive overhead.</p>"},{"location":"C_C%2B%2B_Basics/AR250313/#infinite-recursion-example-caution","title":"Infinite Recursion Example (Caution!)","text":"<pre><code>void NewFunc(int a)\n{\n    NewFunc(100);  // No termination -&gt; infinite recursion!\n}\n</code></pre> <p>This function continuously calls itself with a constant value. Without a base case, it causes a stack overflow.</p>"},{"location":"C_C%2B%2B_Basics/AR250313/#function-call-mechanics","title":"Function Call Mechanics","text":"<ul> <li>Each function call uses a new stack frame.</li> <li>Local variables reside in the stack.</li> <li>Stack grows with each recursive call until the base case is reached or overflow occurs.</li> </ul> <pre><code>int main()\n{\n    int i = Pow(2, 4);       // 16\n    i = Pow(10, 4);          // 10000\n\n    int c = 10;\n    c = 20;\n\n    NewFunc(100);            // Infinite recursion: stack overflow\n\n    return 0;\n}\n</code></pre> <p>Use breakpoints and step execution to observe the stack behavior during debugging.</p>"},{"location":"C_C%2B%2B_Basics/AR250313/#debugging-tips","title":"Debugging Tips","text":"<ul> <li>F5: Start/continue debugging</li> <li>F9: Toggle breakpoint</li> <li>F10: Step over (function as a block)</li> <li>F11: Step into (enter function call)</li> <li>Ctrl + Shift + F9: Clear all breakpoints</li> </ul> <p>These commands help you trace function execution and understand stack changes.</p>"},{"location":"C_C%2B%2B_Basics/AR250313/#interview-questions","title":"Interview Questions","text":"<p>Q: What is a recursive function? A: A function that calls itself to solve a subproblem.</p> <p>Q: What are the dangers of recursion? A: Infinite recursion can cause a stack overflow if there's no proper termination condition.</p> <p>Q: Can all recursive logic be written iteratively? A: Yes, but sometimes recursion improves readability, especially for tree and graph problems.</p> <p>Q: Why is the stack important in recursion? A: Each recursive call stores its context (variables, return address) on the stack.</p>"},{"location":"C_C%2B%2B_Basics/AR250313/#tricky-case-recursion-vs-iteration","title":"Tricky Case: Recursion vs Iteration","text":"<p>Recursive code: <pre><code>int Factorial_Recursion(int n) {\n    if (n == 1) return 1;\n    return Factorial_Recursion(n - 1) * n;\n}\n</code></pre></p> <p>Equivalent iterative code: <pre><code>int Factorial(int n) {\n    int result = 1;\n    for (int i = 2; i &lt;= n; ++i)\n        result *= i;\n    return result;\n}\n</code></pre></p> <p>Prefer the iterative approach if performance and stack safety are priorities.</p>"},{"location":"C_C%2B%2B_Basics/AR250313/#references","title":"References","text":"<ul> <li>array_iteration.cpp</li> <li>recursion.cpp</li> <li>function_call.cpp</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250317/","title":"Recursion and Static Variables","text":""},{"location":"C_C%2B%2B_Basics/AR250317/#date-2025-03-17","title":"Date: 2025-03-17","text":""},{"location":"C_C%2B%2B_Basics/AR250317/#key-points","title":"Key Points","text":"<ul> <li>Recursive functions must include a termination condition.</li> <li>Iterative and recursive versions of algorithms (e.g., Fibonacci) often differ in efficiency.</li> <li>Static variables inside functions retain values across calls.</li> <li>Global and local variables with the same name prioritize local scope.</li> <li>Use <code>::</code> to explicitly access global variables.</li> <li>Global, static, and external variables reside in the data segment, not on the stack.</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250317/#overview","title":"Overview","text":"<p>This note covers fundamental concepts in C++ involving recursion, Fibonacci sequence implementations, and different types of variables (local, global, static, and extern). The examples illustrate usage patterns and potential tricky cases.</p>"},{"location":"C_C%2B%2B_Basics/AR250317/#recursive-function-example","title":"Recursive Function Example","text":"<p><pre><code>void TestFunc(int _a)\n{\n    if (_a == 1)    // Termination condition\n        return;\n\n    TestFunc(_a - 1);  // Recursive call\n}\n</code></pre> This simple recursive function calls itself until <code>_a</code> reaches 1.</p>"},{"location":"C_C%2B%2B_Basics/AR250317/#fibonacci-sequence","title":"Fibonacci Sequence","text":""},{"location":"C_C%2B%2B_Basics/AR250317/#iterative-version","title":"Iterative Version","text":"<p><pre><code>int Fibonacci(int _N)\n{\n    if (_N == 1 || _N == 2)\n        return 1;\n\n    int n1 = 1;\n    int n2 = 1;\n    int Value = 0;\n\n    for (int i = 0; i &lt; _N - 2; ++i)\n    {\n        Value = n1 + n2;\n        n1 = n2;\n        n2 = Value;\n    }\n    return Value;\n}\n</code></pre> The iterative version avoids stack overhead and performs better.</p>"},{"location":"C_C%2B%2B_Basics/AR250317/#recursive-version","title":"Recursive Version","text":"<p><pre><code>int Fibonacci_Re(int _N)\n{\n    if (_N == 1 || _N == 2)\n        return 1;\n\n    return Fibonacci_Re(_N - 1) + Fibonacci_Re(_N - 2);\n}\n</code></pre> This version is intuitive but inefficient due to repeated calculations.</p>"},{"location":"C_C%2B%2B_Basics/AR250317/#variable-scopes-and-types","title":"Variable Scopes and Types","text":""},{"location":"C_C%2B%2B_Basics/AR250317/#global-variable","title":"Global Variable","text":"<p><pre><code>int g_A = 0;  // Global variable declared in data segment\n</code></pre> Always exists during program execution. Avoid name collisions.</p>"},{"location":"C_C%2B%2B_Basics/AR250317/#static-variable-inside-function","title":"Static Variable Inside Function","text":"<p><pre><code>int Test()\n{\n    static int StaticParam = 0;  // Retains value across calls\n    ++StaticParam;\n    return StaticParam;\n}\n</code></pre> <code>StaticParam</code> is initialized once and keeps its value between function calls.</p>"},{"location":"C_C%2B%2B_Basics/AR250317/#local-vs-global-scope","title":"Local vs Global Scope","text":"<p><pre><code>int Test()\n{\n    int g_A = 0;      // Local variable with same name as global\n    g_A = 100;        // Refers to local g_A\n    ++::g_A;          // Refers to global g_A using scope resolution\n    return ::g_A;\n}\n</code></pre> Local variable hides the global one unless the global is explicitly accessed via <code>::</code>.</p>"},{"location":"C_C%2B%2B_Basics/AR250317/#tricky-case-static-variables-and-side-effects","title":"Tricky Case: Static Variables and Side Effects","text":"<p>Calling a function with static variables multiple times results in state accumulation:</p> <p><pre><code>Test();  // StaticParam becomes 1\nTest();  // StaticParam becomes 2\nint Count = Test();  // StaticParam becomes 3, Count = 3\n</code></pre> This makes functions impure and not thread-safe. Use caution in multithreaded or state-dependent scenarios.</p>"},{"location":"C_C%2B%2B_Basics/AR250317/#interview-questions","title":"Interview Questions","text":"<p>Q: What is the difference between a static and global variable? A: Both are stored in the data segment and retain values for the program's lifetime, but static variables are only visible in the scope where they are declared.</p> <p>Q: How does tail recursion differ from regular recursion? A: In tail recursion, the recursive call is the last operation, allowing the compiler to optimize it into a loop.</p> <p>Q: What happens if a local variable has the same name as a global one? A: The local variable takes precedence. Use <code>::</code> to access the global variable explicitly.</p> <p>Q: Why avoid recursion for large inputs? A: Recursion can cause stack overflows and is generally less efficient than iteration for large input sizes.</p>"},{"location":"C_C%2B%2B_Basics/AR250317/#code-demonstration","title":"Code Demonstration","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint g_A = 0;\n\nint Test()\n{\n    static int StaticParam = 0;\n    ++StaticParam;\n    ++::g_A;\n    return ::g_A;\n}\n\nint main()\n{\n    int Arr[100] = {};\n    g_A = 20;\n\n    Test();  // g_A becomes 21\n    Test();  // g_A becomes 22\n    int Count = Test();  // g_A becomes 23, Count = 23\n\n    return 0;\n}\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250317/#visual-variable-scopes","title":"Visual: Variable Scopes","text":"Variable Type Memory Area Lifetime Scope Local Stack Until function ends Current function Global Data Segment Entire program All files (unless static) Static (local) Data Segment Entire program Declaring function only External Data Segment Entire program Across files (with <code>extern</code>)"},{"location":"C_C%2B%2B_Basics/AR250317/#references","title":"References","text":"<ul> <li>recursion2.cpp</li> <li>variable_types.cpp</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250318/","title":"Global and Static Variables","text":""},{"location":"C_C%2B%2B_Basics/AR250318/#date-2025-03-18","title":"Date: 2025-03-18","text":""},{"location":"C_C%2B%2B_Basics/AR250318/#key-points","title":"Key Points","text":"<ul> <li><code>extern</code> declares a global variable without defining it.</li> <li><code>static</code> at global scope makes the variable local to the file (translation unit).</li> <li>Duplicate global variable definitions across files cause linker errors.</li> <li>Global variables should be used carefully to avoid name conflicts and side effects.</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250318/#overview","title":"Overview","text":"<p>This code sample illustrates how global and static variables behave across translation units in C++. It also covers the role of <code>extern</code>, the risks of duplicate global variable definitions, and file-local static global variables.</p>"},{"location":"C_C%2B%2B_Basics/AR250318/#header-file-funch","title":"Header File: <code>func.h</code>","text":"<pre><code>#pragma once\n\nint Add(int a, int b);\nint Sub(int a, int b);\nint Mul(int a, int b);\nint Div(int a, int b);\nint Func();\n\n// Declares that an int global variable named g_A exists somewhere.\nextern int g_A;\n\n// Defines a static global variable unique to each file including this header.\nstatic int g_NewStatic = 0;\n\n// Uncommenting the below line would define a global variable in every file including func.h, leading to linker errors.\n// int g_GlobalParam = 0;\n```~~~~\n\n### Source File 1: `func.cpp`\n\n```cpp\n#include \"func.h\"\n\n// File-local global variable\nstatic int g_Global = 0;\n\n// Use of externally declared variable\nextern int g_A;\n\nint Add(int a, int b)\n{\n    g_Global = 10; // modifies local static global\n    g_A = 200;     // modifies shared global declared with extern\n    return a + b;\n}\n\nint Sub(int a, int b) { return a - b; }\nint Mul(int a, int b) { return a * b; }\nint Div(int a, int b) { return a / b; }\nint Func() { return 0; }\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250318/#source-file-2-maincpp","title":"Source File 2: <code>main.cpp</code>","text":"<pre><code>#include \"func.h\"\n\n// File-local global\nstatic int g_Global = 0;\n\n// Definition of global variable declared with extern\nint g_A = 0;\n\nint main()\n{\n    // Local static variable: retains value across function calls\n    static int iStatic = 0;\n\n    g_Global = 200;  // refers to file-local static variable\n    // g_A = 100;    // modifies global variable shared across files\n\n    int i = 0;\n    i = Add(1, 9);\n    i = Sub(1, 9);\n    i = Mul(1, 9);\n    i = Div(1, 9);\n    Func();\n\n    return 0;\n}\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250318/#tricky-cases","title":"Tricky Cases","text":""},{"location":"C_C%2B%2B_Basics/AR250318/#1-static-global-variable","title":"1. Static Global Variable","text":"<p>A static global variable like <code>static int g_Global</code> is only visible to the file where it's defined. Both <code>func.cpp</code> and <code>main.cpp</code> have their own <code>g_Global</code>, which do not conflict.</p>"},{"location":"C_C%2B%2B_Basics/AR250318/#2-extern-global-variable","title":"2. Extern Global Variable","text":"<p><code>extern int g_A;</code> in <code>func.h</code> tells other files about a global variable defined elsewhere. In <code>main.cpp</code>, <code>int g_A = 0;</code> provides the actual definition. This shared global can be modified in any file including <code>func.h</code>.</p>"},{"location":"C_C%2B%2B_Basics/AR250318/#3-global-variable-in-header-file","title":"3. Global Variable in Header File","text":"<p>Declaring a global variable directly in a header like <code>int g_GlobalParam = 0;</code> (commented out in the sample) causes a new definition in every file that includes it?\ubd31esulting in multiple definitions and linker errors.</p>"},{"location":"C_C%2B%2B_Basics/AR250318/#sample-interview-questions","title":"Sample Interview Questions","text":"<p>Q: What does <code>static</code> do to a global variable? A: It limits the variable's linkage to the current translation unit (source file), making it file-local.</p> <p>Q: What happens if you define a global variable in a header file and include it in multiple source files? A: Each source file gets its own definition, leading to a multiple definition linker error.</p> <p>Q: How does <code>extern</code> help in managing global variables? A: <code>extern</code> declares a variable without defining it, allowing shared access across files if it's defined once elsewhere.</p> <p>Q: Can two source files define a static global variable with the same name? A: Yes, because each static global is local to its file; they won't interfere with each other.</p>"},{"location":"C_C%2B%2B_Basics/AR250318/#summary","title":"Summary","text":"<ul> <li>Use <code>extern</code> in headers for shared globals, define them only once in a <code>.cpp</code> file.</li> <li>Use <code>static</code> for file-local globals to avoid conflicts.</li> <li>Never define non-static globals directly in headers.</li> <li>Carefully manage visibility and linkage to prevent subtle bugs and linker errors.</li> </ul> <p>These behaviors are essential when working on large C++ projects with multiple source files.</p>"},{"location":"C_C%2B%2B_Basics/AR250318/#references","title":"References","text":"<ul> <li>func.cpp</li> <li>func.h</li> <li>main.cpp</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250319/","title":"Pointer Basics and Function Overloading","text":""},{"location":"C_C%2B%2B_Basics/AR250319/#date-2025-03-19","title":"Date: 2025-03-19","text":""},{"location":"C_C%2B%2B_Basics/AR250319/#key-points","title":"Key Points","text":"<ul> <li>Pointers store memory addresses; their size is typically 8 bytes on modern systems.</li> <li><code>&amp;</code> retrieves a variable's address, <code>*</code> dereferences a pointer.</li> <li><code>void*</code> is a generic pointer type, but cannot be dereferenced directly.</li> <li>Pointer arithmetic depends on the pointer's data type.</li> <li>Arrays and pointers are closely related; array indexing uses pointer arithmetic.</li> <li>Function overloading allows multiple functions with the same name but different signatures.</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250319/#overview","title":"Overview","text":"<p>This code snippet covers fundamental C++ concepts including pointer usage, function overloading, pointer casting, and memory operations using external functions like <code>MemSet</code> and <code>MemMove</code>.</p> <p>Let's walk through the details.</p>"},{"location":"C_C%2B%2B_Basics/AR250319/#function-overloading-in-c","title":"Function Overloading in C++","text":"<p>Function overloading allows the same function name to be used with different parameter lists.</p> <pre><code>int Test(int _a) {\n    return 10;\n}\n\nvoid Test(float _f) {\n}\n\nvoid Test(int _a, int _b = 0) {\n}\n\nint main() {\n    Test(1.1f);    // Calls void Test(float)\n    Test(10, 20);  // Calls void Test(int, int)\n    return 0;\n}\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250319/#tricky-case-default-parameters-and-overloading","title":"Tricky Case: Default Parameters and Overloading","text":"<p>Be cautious when using default parameters with overloaded functions??\ubd33hey can lead to ambiguity.</p>"},{"location":"C_C%2B%2B_Basics/AR250319/#pointer-fundamentals","title":"Pointer Fundamentals","text":"<p>Pointers are variables that store memory addresses.</p> <pre><code>int i = 0;\nchar c = 0;\nshort s = 0;\n\nint*   pI = 0;\nchar*  pC = 0;\nshort* pS = 0;\n\npI = &amp;i;\npC = &amp;c;\npS = &amp;s;\n\n*pI = 10;\n*pC = 20;\n*pS = 30;\n</code></pre> <p>Declaring a pointer with a type (e.g., <code>int*</code>) defines how the memory at that address will be interpreted.</p>"},{"location":"C_C%2B%2B_Basics/AR250319/#pointer-casting","title":"Pointer Casting","text":"<pre><code>pI = (int*)&amp;c;\npC = (char*)&amp;i;\n</code></pre> <p>This forces interpretation of memory as another type. Use with caution??\ubd27t bypasses type safety.</p>"},{"location":"C_C%2B%2B_Basics/AR250319/#void-pointers","title":"Void Pointers","text":"<pre><code>void* pVoid = 0;\npVoid = &amp;i;\npVoid = &amp;c;\npVoid = &amp;s;\n</code></pre> <p><code>void*</code> can store any address but must be cast to another type before dereferencing.</p> <pre><code>// Invalid:\n// pS = pVoid;\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250319/#memory-utilities","title":"Memory Utilities","text":"<p>Assuming the following external functions:</p> <pre><code>void MemSet(void* _pData, int _Size);\nvoid MemMove(void* _pData, int _Size, void* _Src);\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250319/#example-usage","title":"Example Usage","text":"<pre><code>short arr[10];\nMemSet(arr, 20);\n\nint k;\nMemSet(&amp;k, sizeof(int));\n\nint iArr[10] = { 1,2,3,4,5,6,7,8,9,10 };\nint iArrOther[10] = {};\nMemMove(iArrOther, sizeof(int) * 10, iArr);\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250319/#pointer-arithmetic","title":"Pointer Arithmetic","text":"<pre><code>int* pInt = 0;\npInt += 1;  // Moves pointer by sizeof(int)\n\nshort* pShort = 0;\npShort += 1;  // Moves pointer by sizeof(short)\n</code></pre> <p>The increment steps over a number of bytes depending on the type.</p>"},{"location":"C_C%2B%2B_Basics/AR250319/#array-and-pointer-relationship","title":"Array and Pointer Relationship","text":"<pre><code>int iTest[5] = {};\npInt = iTest;\n\npInt[0] = 1;  // *(pInt + 0)\npInt[1] = 2;  // *(pInt + 1)\n</code></pre> <p>Array indexing is syntactic sugar for pointer arithmetic.</p>"},{"location":"C_C%2B%2B_Basics/AR250319/#interview-questions","title":"Interview Questions","text":"<p>Q: What is a pointer in C++? A: A pointer is a variable that stores the memory address of another variable.</p> <p>Q: Can you dereference a void pointer? A: No, a <code>void*</code> must first be cast to a specific type before dereferencing.</p> <p>Q: How is pointer arithmetic affected by the data type? A: The pointer moves in steps of the size of the data type it points to (e.g., <code>int*</code> moves 4 bytes, <code>short*</code> moves 2 bytes).</p> <p>Q: What's the relationship between arrays and pointers? A: An array name is effectively a pointer to its first element. Array indexing uses pointer arithmetic under the hood.</p> <p>Q: What is the purpose of function overloading? A: Function overloading allows multiple functions with the same name to coexist as long as their signatures differ.</p>"},{"location":"C_C%2B%2B_Basics/AR250319/#visual-pointer-arithmetic","title":"Visual: Pointer Arithmetic","text":"<pre><code>int* pInt = 0;\npInt += 1;\n\nBefore: pInt = 0x1000\nAfter : pInt = 0x1004 (assuming int = 4 bytes)\n</code></pre> <p>Keep these principles in mind when dealing with pointers.  They're powerful but error-prone if misused.  Use pointer casting and void pointers with caution,  and always be aware of type sizes when doing arithmetic.</p>"},{"location":"C_C%2B%2B_Basics/AR250319/#references","title":"References","text":"<ul> <li>pointer.cpp</li> <li>function_overloading.cpp</li> <li>MemSet.cpp</li> <li>HW250319.cpp</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250320/","title":"Constexpr, Const, Volatile, and Pointer Fundamentals","text":""},{"location":"C_C%2B%2B_Basics/AR250320/#date-2025-03-20","title":"Date: 2025-03-20","text":""},{"location":"C_C%2B%2B_Basics/AR250320/#key-points","title":"Key Points","text":"<ul> <li><code>const</code> prevents variable reassignment after initialization.</li> <li><code>volatile</code> disables compiler optimizations for variables that may change externally.</li> <li><code>constexpr</code> enforces compile-time constant evaluation.</li> <li>Modifying <code>const</code> or <code>constexpr</code> via pointer casting can lead to undefined behavior.</li> <li><code>nullptr</code> is a dedicated keyword for null pointers in C++.</li> <li>Double pointers allow pointer manipulation across functions.</li> <li><code>void*</code> pointers are type-agnostic and require size information for operations.</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250320/#overview","title":"Overview","text":"<p>Understanding <code>const</code>, <code>constexpr</code>, and <code>volatile</code> is crucial for writing safe and optimized C++ code. These keywords provide control over variable mutability and evaluation timing, and interact closely with pointer semantics. This note also explores pointer-related concepts like null pointers, double pointers, and low-level memory manipulation with <code>MemSet</code> and <code>MemMove</code> functions.</p>"},{"location":"C_C%2B%2B_Basics/AR250320/#const-volatile-and-constexpr","title":"Const, Volatile, and Constexpr","text":"<pre><code>volatile const int iConst = 100;\n//iConst = 200; // Error: cannot assign to a const\n\nvolatile const int* pData = &amp;iConst;\n//*pData = 200; // Error: pData is a pointer to const\n\nint* pData1 = (int*)&amp;iConst;\n*pData1 = 200; // Undefined behavior, bypasses const\n\nint k = iConst; // Might use cached register value if not volatile\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250320/#why-volatile-matters","title":"Why <code>volatile</code> Matters","text":"<p>The compiler might optimize access to <code>iConst</code>, assuming it doesn't change. Using <code>volatile</code> forces re-evaluation every time, useful when memory might be modified outside of program control (e.g., hardware registers).</p>"},{"location":"C_C%2B%2B_Basics/AR250320/#constexpr-constants","title":"<code>constexpr</code> Constants","text":"<p><pre><code>volatile constexpr int iConstExpr = 100;\nint* pConstExpr = (int*)&amp;iConstExpr;\n*pConstExpr = 200; // Still undefined behavior\nint p = iConstExpr; // Always 100 at compile time\n</code></pre> <code>constexpr</code> requires compile-time evaluable expressions. It's stricter than <code>const</code> and allows compiler optimizations without runtime overhead.</p>"},{"location":"C_C%2B%2B_Basics/AR250320/#null-pointer-boolean-macros-and-pointer-safety","title":"Null Pointer, Boolean Macros, and Pointer Safety","text":""},{"location":"C_C%2B%2B_Basics/AR250320/#null-pointers","title":"Null Pointers","text":"<p><pre><code>int* pData = nullptr; // Safe null initialization\n</code></pre> Use <code>nullptr</code> to represent a pointer to no object. Avoid using <code>0</code> or <code>NULL</code> in modern C++.</p>"},{"location":"C_C%2B%2B_Basics/AR250320/#boolean-macros-c-style","title":"Boolean Macros (C-style)","text":"<p><pre><code>#define TRUE 1;\n#define FALSE 0;\n\nbool IsTrue = TRUE;\n</code></pre> C++ provides <code>true</code> and <code>false</code> as keywords. Macros like <code>TRUE</code>/<code>FALSE</code> are legacy from C.</p>"},{"location":"C_C%2B%2B_Basics/AR250320/#tricky-case-pointer-passing-and-double-pointers","title":"Tricky Case: Pointer Passing and Double Pointers","text":""},{"location":"C_C%2B%2B_Basics/AR250320/#accessing-local-variables-in-other-functions","title":"Accessing Local Variables in Other Functions","text":"<pre><code>void Test(int* _Data) {\n    *_Data = 10;\n}\n\nint i = 0;\nTest(&amp;i); // i is now 10\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250320/#double-pointers-for-pointer-modification","title":"Double Pointers for Pointer Modification","text":"<p><pre><code>void Test(int** _Data) {\n    *_Data = nullptr;\n}\n\nint* pInt = (int*)1;\nTest(&amp;pInt); // pInt is now nullptr\n</code></pre> This is useful when you want to modify the pointer itself (not just the data it points to).</p>"},{"location":"C_C%2B%2B_Basics/AR250320/#memory-initialization-and-movement-with-void","title":"Memory Initialization and Movement with <code>void*</code>","text":"<p><pre><code>typedef unsigned char BYTE;\n\nvoid MemSet(void* _pData, int _Size) {\n    BYTE* pData = (BYTE*)_pData;\n    for (int i = 0; i &lt; _Size; ++i) {\n        pData[i] = 0;\n    }\n}\n\nvoid MemMove(void* _Dest, int _Size, void* _Src) {\n    BYTE* pDest = (BYTE*)_Dest;\n    BYTE* pSrc = (BYTE*)_Src;\n    for (int i = 0; i &lt; _Size; ++i) {\n        pDest[i] = pSrc[i];\n    }\n}\n</code></pre> These utility functions show how <code>void*</code> enables flexible memory manipulation. Use with care, as type safety is lost.</p>"},{"location":"C_C%2B%2B_Basics/AR250320/#interview-questions","title":"Interview Questions","text":"<p>Q: What is the difference between <code>const</code> and <code>constexpr</code>? A: <code>const</code> applies at runtime and allows runtime-initialized values. <code>constexpr</code> requires compile-time evaluable expressions and provides stronger optimization.</p> <p>Q: Why use <code>volatile</code> with a <code>const</code> variable? A: It prevents the compiler from optimizing out reads to the variable, ensuring the program always fetches the latest value.</p> <p>Q: What does <code>nullptr</code> represent and why use it over <code>0</code>? A: <code>nullptr</code> is a type-safe null pointer constant in C++11+, unlike <code>0</code> which can be ambiguous in overload resolution.</p> <p>Q: Why are double pointers used in C++? A: Double pointers (<code>T**</code>) allow functions to modify the original pointer passed to them, useful for reassigning memory or nullifying pointers.</p> <p>Q: What are the risks of casting away <code>const</code> using a pointer? A: It results in undefined behavior if the object was originally declared as <code>const</code>. Compilers may optimize assuming immutability.</p>"},{"location":"C_C%2B%2B_Basics/AR250320/#visual-const-volatile-and-pointer-interaction","title":"Visual: Const, Volatile, and Pointer Interaction","text":"<pre><code>Original Const Variable\n------------------------\niConst = 100\n\nPointer Access\n--------------\npData -&gt; [100]   // Safe read\npData1 -&gt; [200]  // Forced overwrite (UB)\n\nEffect on Compiler\n------------------\nWith volatile: Always re-reads value\nWithout volatile: Might cache value\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250320/#references","title":"References","text":"<ul> <li>MemSet.cpp</li> <li>const, const pointer.cpp</li> <li>nullptr, double pointer.cpp</li> <li>pointer.cpp</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250320/#references_1","title":"References","text":"<ul> <li>const_const_pointer.cpp</li> <li>nullptr_double_pointer.cpp</li> <li>pointer_problem.cpp</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250321/","title":"C Memory Functions","text":""},{"location":"C_C%2B%2B_Basics/AR250321/#date-2025-03-21","title":"Date: 2025-03-21","text":""},{"location":"C_C%2B%2B_Basics/AR250321/#memset","title":"MemSet","text":"<p>Purpose: The <code>memset()</code> function sets a block of memory to a specific byte value. It is commonly used to initialize or clear memory.</p> <p>Prototype: <pre><code>void* memset(void* ptr, int value, size_t num);\n</code></pre></p> <ul> <li><code>ptr</code>: A pointer to the starting address of the memory block to be set.</li> <li><code>value</code>: The value to set each byte in the memory block to. This value is converted to an unsigned char.</li> <li><code>num</code>: The number of bytes to set.</li> </ul> <p>Usage Example: <pre><code>int arr[5];\nmemset(arr, 0, sizeof(arr)); // Set all bytes in arr to 0\n</code></pre></p> <p>Behavior: <code>memset()</code> sets the bytes in the memory block to the specified value. It operates byte-by-byte, making it suitable for initializing buffers, clearing memory, or filling structures with a default value.</p> <p>Code Implementation <pre><code>typedef unsigned char BYTE;\n\nvoid MemSet(void* _pData, int _Size) {\n    BYTE* pData = (BYTE*)_pData;\n    for (int i = 0; i &lt; _Size; ++i) {\n        *(pData + i) = 0;\n    }\n}\n</code></pre></p>"},{"location":"C_C%2B%2B_Basics/AR250321/#memcpy","title":"MemCpy","text":"<p>Purpose: The <code>memcpy()</code> function copies a block of memory from one location to another. It does not handle overlapping memory regions.</p> <p>Prototype: <pre><code>void* memcpy(void* dest, const void* src, size_t num);\n</code></pre></p> <ul> <li><code>dest</code>: A pointer to the destination memory location.</li> <li><code>src</code>: A pointer to the source memory location.</li> <li><code>num</code>: The number of bytes to copy.</li> </ul> <p>Usage Example: <pre><code>char src[] = \"Hello\";\nchar dest[10];\nmemcpy(dest, src, 6); // Copies \"Hello\\0\" to dest\n</code></pre></p> <p>Behavior: <code>memcpy()</code> performs a fast copy of <code>num</code> bytes from the source to the destination. It assumes that the memory regions do not overlap and will behave incorrectly if they do.</p> <p>Note: If the source and destination memory regions overlap, the behavior is undefined, potentially causing data corruption.</p> <p>Code Implementation <pre><code>typedef unsigned char BYTE;\n\nvoid MemCopy(void* _Dest, int _Size, void* _Src) {\n    BYTE* pDest = (BYTE*)_Dest;\n    BYTE* pSrc = (BYTE*)_Src;\n    for (int i = 0; i &lt; _Size; ++i) {\n        pDest[i] = pSrc[i];\n    }\n}\n</code></pre></p>"},{"location":"C_C%2B%2B_Basics/AR250321/#memmove","title":"MemMove","text":"<p>Purpose: The <code>memmove()</code> function copies a block of memory like <code>memcpy()</code>, but it safely handles overlapping memory regions.</p> <p>Prototype: <pre><code>void* memmove(void* dest, const void* src, size_t num);\n</code></pre></p> <ul> <li><code>dest</code>: A pointer to the destination memory location.</li> <li><code>src</code>: A pointer to the source memory location.</li> <li><code>num</code>: The number of bytes to copy.</li> </ul> <p>Usage Example: <pre><code>char data[] = \"123456789\";\nmemmove(&amp;data[2], &amp;data[0], 5); // Moves \"12345\" to position starting at index 2\n</code></pre></p> <p>Behavior: <code>memmove()</code> copies the bytes safely even when the source and destination memory regions overlap. It checks if the regions overlap and copies in the correct direction (either forward or backward) to prevent data corruption.</p> <p>Code Implementation <pre><code>typedef unsigned char BYTE;\n\nvoid MemMove(void* _Dest, int _Size, void* _Src) {\n    BYTE* pDest = (BYTE*)_Dest;\n    BYTE* pSrc = (BYTE*)_Src;\n\n    if (pDest &lt; pSrc || pDest &gt;= pSrc + _Size) {\n        for (int i = 0; i &lt; _Size; ++i) {\n            pDest[i] = pSrc[i];\n        }\n    } else {\n        for (int i = _Size - 1; i &gt;= 0; --i) {\n            pDest[i] = pSrc[i];\n        }\n    }\n}\n</code></pre></p>"},{"location":"C_C%2B%2B_Basics/AR250321/#sample-code","title":"Sample Code","text":"<pre><code>#include &lt;iostream&gt;\n\ntypedef unsigned char BYTE;\n\nvoid MemSet(void* _pData, int _Size)\n{\n    BYTE* pData = (BYTE*)_pData;\n\n    for (int i = 0; i &lt; _Size; ++i)\n    {\n        *(pData + i) = 0;\n    }\n}\n\n// Goal : Copy data from one memory area to another\n\nvoid MemCopy(void* _Dest, int _Size, void* _Src) {\n    BYTE* pDest = (BYTE*)_Dest;\n    BYTE* pSrc = (BYTE*)_Src;\n    for (int i = 0; i &lt; _Size; ++i) {\n        pDest[i] = pSrc[i];\n    }\n}\n\n// Goal : Move data from one memory area to another \n// Note : The source and destination memory areas may overlap \n\nvoid MemMove(void* _Dest, int _Size, void* _Src)\n{\n    BYTE* pDest = (BYTE*)_Dest;\n    BYTE* pSrc = (BYTE*)_Src;\n\n    if (pDest &lt; pSrc || pDest &gt;= pSrc + _Size) \n    {\n    }\n\n    for (int i = 0; i &lt; _Size; ++i)\n    {\n        //*(pDest + i) = *(pSrc + i);\n        pDest[i] = pSrc[i];\n    }\n}\n\nint main(int argc, const char* argv[]) {\n\n    short arr[10];\n    MemSet(arr, 20); \n    for (unsigned int i = 0; i &lt; sizeof(arr)/sizeof(short); i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n\n    int k;\n    MemSet(&amp;k, sizeof(int));\n\n    for (unsigned int i = 0; i &lt; sizeof(arr) / sizeof(short); i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n\n    int iArr[10] = { 1,2,3,4,5,6,7,8,9,10 };\n    int iArrOther[10] = {};\n\n    MemMove(iArrOther, sizeof(int) * 10, iArr);\n\n    for (unsigned int i = 0; i &lt; sizeof(iArrOther) / sizeof(int); i++)\n    {\n        printf(\"%d \", iArrOther[i]);\n    }\n    printf(\"\\n\");\n\n    return 0; \n}\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250321/#why-use-byte-or-unsigned-char-for-memset-and-memmove","title":"Why Use <code>BYTE*</code> (or <code>unsigned char*</code>) for <code>MemSet</code> and <code>MemMove</code>?","text":"<p>In C (and C++ if templates aren't used), you often need a generic way to work with raw memory. This is where <code>void*</code> comes in, as it's a typeless pointer. However, when reading from or writing to that memory, it needs to be cast to a type that has a known size. That's why <code>BYTE*</code> (which is a typedef for <code>unsigned char*</code>) is commonly used.</p>"},{"location":"C_C%2B%2B_Basics/AR250321/#references","title":"References","text":"<ul> <li>const_const_pointer.cpp</li> <li>HW250319.cpp</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250324/","title":"Const Pointers and Type-Punning","text":""},{"location":"C_C%2B%2B_Basics/AR250324/#date-2025-03-24","title":"Date: 2025-03-24","text":""},{"location":"C_C%2B%2B_Basics/AR250324/#key-points","title":"Key Points","text":"<ul> <li><code>const int*</code> means a pointer to a constant value. You can read but not write.</li> <li><code>int* const</code> means a constant pointer to an int. You can modify the value but not reassign the pointer.</li> <li>When both <code>const</code> modifiers are used, the pointer cannot be reassigned or modify the target.</li> <li>Type punning using casts (<code>char*</code>, <code>int*</code>, etc.) must be done with caution due to strict aliasing rules.</li> <li>Use <code>const</code> correctness to ensure safer, more predictable code.</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250324/#overview","title":"Overview","text":"<p>Understanding <code>const</code> with pointers is essential in modern C++ for writing safe and efficient code. It allows expressing intent clearly and protects against unintended modification. Pointers themselves can be constant or point to constant data, and the position of <code>const</code> determines the behavior.</p>"},{"location":"C_C%2B%2B_Basics/AR250324/#pointer-to-constant-value","title":"Pointer to Constant Value","text":"<pre><code>const int a = 10; // Constant integer value\nconst int* pInt = &amp;a; // Pointer to a constant int\n\n// *pInt = 100; // Error: cannot modify through pInt\npInt = nullptr; // Allowed: pointer can point elsewhere\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250324/#constant-pointer-to-variable","title":"Constant Pointer to Variable","text":"<pre><code>int j = 0;\nint* const pContInt = &amp;j; // Constant pointer to a variable\n\n*pContInt = 200; // Allowed: can modify the target\n// pContInt = nullptr; // Error: cannot change the pointer itself\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250324/#constant-pointer-to-constant-value","title":"Constant Pointer to Constant Value","text":"<pre><code>const int* const pCCInt = &amp;j; // Read-only pointer and value\n\n// *pCCInt = 300;     // Error\n// pCCInt = nullptr;  // Error\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250324/#const-safety-in-functions","title":"Const Safety in Functions","text":""},{"location":"C_C%2B%2B_Basics/AR250324/#safe-read-only-access","title":"Safe Read-Only Access","text":"<p><pre><code>void DataOutput(const int* _Data) {\n    printf(\"%d\\n\", *_Data);\n    // *_Data = 300; // Error: _Data points to a const\n}\n</code></pre> Passing a <code>const int*</code> ensures the function cannot modify the value it receives.</p>"},{"location":"C_C%2B%2B_Basics/AR250324/#type-punning-with-structs-and-pointers","title":"Type-Punning with Structs and Pointers","text":"<pre><code>struct MyType {\n    int   i;\n    short s;\n};\n\nMyType type = {10, 20};\nMyType* pType = &amp;type;\n\npType-&gt;i = 50;\npType-&gt;s = 60;\n</code></pre> <p>Accessing struct members through pointers is direct and efficient. Arrow <code>-&gt;</code> syntax is shorthand for dereferencing and accessing (<code>(*p).x</code>).</p>"},{"location":"C_C%2B%2B_Basics/AR250324/#pointer-size-and-type-awareness","title":"Pointer Size and Type Awareness","text":"<pre><code>int* pInt = nullptr;\nchar* pChar = nullptr;\n\nint Size = sizeof(int*); // Pointer size is typically 8 bytes on 64-bit systems\n</code></pre> <p>Pointers, regardless of the type they point to, usually have the same size on a given architecture.</p>"},{"location":"C_C%2B%2B_Basics/AR250324/#tricky-case-pointer-arithmetic-and-type-punning","title":"Tricky Case: Pointer Arithmetic and Type-Punning","text":""},{"location":"C_C%2B%2B_Basics/AR250324/#casting-char-to-int","title":"Casting <code>char[]</code> to <code>int*</code>","text":"<p><pre><code>char arrData[10] = {2, 4, 6, 8, 10, 12, 14, 16, 18, 20};\nint* pData = (int*)arrData;\npData += 2; // Advances by 2 * sizeof(int) bytes\n\nchar* pChar = (char*)pData;\nchar a = *pChar;\n</code></pre> Pointer arithmetic on a casted pointer can easily misalign data and lead to undefined behavior. Be careful when casting <code>char[]</code> to <code>int*</code>, especially when accessing or modifying memory.</p>"},{"location":"C_C%2B%2B_Basics/AR250324/#signed-vs-unsigned-char-interpretation","title":"Signed vs Unsigned Char Interpretation","text":"<p><pre><code>char CharData = -1;\n\nunsigned char* pUChar = (unsigned char*)&amp;CharData;\nchar* pChar = &amp;CharData;\n\nint intData = *pUChar; // Value: 255 (unsigned interpretation)\nintData = *pChar;      // Value: -1 (signed interpretation)\n</code></pre> Casting a signed <code>char</code> to <code>unsigned char</code> reveals how the same memory is interpreted differently. This is useful in low-level programming but must be used carefully.</p>"},{"location":"C_C%2B%2B_Basics/AR250324/#common-mistakes","title":"Common Mistakes","text":"<p>Mistake: Modifying <code>const</code> value through cast <pre><code>const int Data = 100;\nint* p = (int*)&amp;Data;\n*p = 200; // Undefined behavior\n</code></pre> Modifying a <code>const</code> value using a cast is undefined behavior. Avoid this in production code.</p> <p>Mistake: Confusing pointer const-ness <pre><code>int* const ptr = &amp;x; // Cannot change ptr itself\nconst int* ptr2 = &amp;x; // Cannot modify *ptr2\n</code></pre> Understand which part is <code>const</code> ??the pointer or the value ??to avoid bugs.</p>"},{"location":"C_C%2B%2B_Basics/AR250324/#interview-questions","title":"Interview Questions","text":"<p>Q: What's the difference between <code>const int*</code> and <code>int* const</code>? A: - <code>const int*</code>: pointer to const int ??can't modify the value. - <code>int* const</code>: const pointer to int ??can't change the pointer.</p> <p>Q: Can you cast away <code>const</code> and modify the value? A: Technically yes using <code>(int*)</code>, but doing so leads to undefined behavior and must be avoided.</p> <p>Q: What is <code>nullptr</code>? Why not just use 0 or NULL? A: <code>nullptr</code> (C++11) is a type-safe null pointer constant. Prevents overload ambiguity and improves readability.</p> <p>Q: What does <code>const int* const ptr</code> mean? A: Pointer is constant and points to a constant value. Neither the address nor the value can be changed.</p>"},{"location":"C_C%2B%2B_Basics/AR250324/#summary-table","title":"Summary Table","text":"Declaration Can Change Value Can Reassign Pointer <code>const int* ptr</code> No Yes <code>int* const ptr</code> Yes No <code>const int* const ptr</code> No No <p>This guide covers core behavior of <code>const</code> with pointers and tricky memory manipulation patterns using pointer casting. Mastering these concepts gives a solid foundation for deeper system-level C++ work.</p>"},{"location":"C_C%2B%2B_Basics/AR250324/#references","title":"References","text":"<ul> <li>MemSet.cpp</li> <li>const_pointer2.cpp</li> <li>struct+pointer.cpp</li> <li>pointer_problem.cpp</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250325/","title":"Custom String Utilities","text":""},{"location":"C_C%2B%2B_Basics/AR250325/#date-2025-03-25","title":"Date: 2025-03-25","text":""},{"location":"C_C%2B%2B_Basics/AR250325/#key-points","title":"Key Points","text":"<ul> <li>Custom functions like <code>StringCopy</code>, <code>StringCat</code>, <code>StringLen</code> mimic standard C-string utilities.</li> <li>Null-termination (<code>\\0</code>) is critical for proper string manipulation.</li> <li><code>ItoA</code> and <code>AtoI</code> provide manual int-to-string and string-to-int conversions.</li> <li><code>const char*</code> string literals reside in read-only memory (ROM).</li> <li>Writing to ROM-located string literals causes runtime errors.</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250325/#overview","title":"Overview","text":"<p>This study covers a set of hand-written C-style string utilities to better understand low-level memory manipulation and string processing in C++. These functions replicate behavior of standard C functions like <code>strcpy</code>, <code>strcat</code>, <code>strlen</code>, <code>itoa</code>, and <code>atoi</code>.</p>"},{"location":"C_C%2B%2B_Basics/AR250325/#implementations","title":"Implementations","text":""},{"location":"C_C%2B%2B_Basics/AR250325/#stringcopy","title":"<code>StringCopy</code>","text":"<p>Copies the content of <code>_Src</code> into <code>_Dest</code>, including the null terminator:</p> <pre><code>void StringCopy(char* _Dest, const char* _Src) {\n    int idx = 0;\n    while (_Src[idx] != 0) {\n        _Dest[idx] = _Src[idx];\n        ++idx;\n    }\n    _Dest[idx] = _Src[idx]; // Copy the null-terminator\n}\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250325/#stringlen","title":"<code>StringLen</code>","text":"<p>Calculates the length of a string by counting until the null character:</p> <pre><code>int StringLen(const char* _Src) {\n    int Len = 0;\n    while (_Src[Len] != 0) {\n        ++Len;\n    }\n    return Len;\n}\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250325/#stringcat","title":"<code>StringCat</code>","text":"<p>Appends <code>_Src</code> to the end of <code>_Dest</code>:</p> <pre><code>void StringCat(char* _Dest, const char* _Src) {\n    int DestLen = StringLen(_Dest);\n    int SrcLen = StringLen(_Src);\n\n    for (int i = 0; i &lt; SrcLen; ++i) {\n        _Dest[i + DestLen] = _Src[i];\n    }\n\n    _Dest[DestLen + SrcLen] = 0; // Null-terminate result\n}\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250325/#itoa","title":"<code>ItoA</code>","text":"<p>Converts an integer to its ASCII string representation:</p> <pre><code>void ItoA(char* _Dest, int _Num) {\n    int Count = 0;\n    int Result = _Num;\n    while (true) {\n        Result /= 10;\n        ++Count;\n        if (Result == 0)\n            break;\n    }\n\n    for (int i = 0; i &lt; Count; ++i) {\n        _Dest[Count - (i + 1)] = (_Num % 10) + 48;\n        _Num /= 10;\n    }\n\n    _Dest[Count] = 0; // Null-terminate\n}\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250325/#atoi","title":"<code>AtoI</code>","text":"<p>Converts a numeric string to its integer representation:</p> <pre><code>int AtoI(const char* _Src) {\n    int Count = StringLen(_Src);\n    int Value = 0;\n    for (int i = 0; i &lt; Count; ++i) {\n        Value *= 10;\n        Value += (_Src[i] - 48);\n    }\n    return Value;\n}\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250325/#common-mistakes","title":"Common Mistakes","text":"<p>Modifying string literals</p> <pre><code>const char* pString = \"abcdef\";\npString[0] = 'z'; // Runtime error: attempting to modify ROM\n</code></pre> <p>Forgetting null-termination</p> <pre><code>char str[4] = {'1', '2', '3'}; // Missing null terminator!\n// String functions like strlen or strcpy may read past the end.\n</code></pre> <p>Incorrect array sizing</p> <pre><code>char buffer[4] = \"abcd\"; // Buffer overflow: needs 5 bytes (4 chars + null)\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250325/#tricky-case-literal-vs-writable-strings","title":"Tricky Case: Literal vs. Writable Strings","text":"<pre><code>const char* literal = \"hello\"; // Stored in ROM (read-only)\nchar buffer[] = \"hello\";       // Stored in RAM (writable)\n\nliteral[0] = 'H'; // ??Runtime crash\nbuffer[0] = 'H';  // ??OK\n</code></pre> <p>Understanding the storage location and mutability of strings is key in avoiding subtle bugs.</p>"},{"location":"C_C%2B%2B_Basics/AR250325/#interview-questions","title":"Interview Questions","text":"<p>Q: Why can't we modify <code>const char*</code> literals? A: String literals are stored in ROM, which is read-only. Attempting to write causes undefined behavior or runtime errors.</p> <p>Q: How does manual <code>ItoA</code> work? A: It repeatedly divides the number by 10 to count digits, then fills the array from the end with ASCII character equivalents (<code>+48</code>).</p> <p>Q: What's a common mistake with <code>StringCat</code>? A: Not ensuring that <code>_Dest</code> has enough space to hold the combined result, potentially causing buffer overflows.</p> <p>Q: Difference between <code>char[]</code> and <code>const char*</code>? A: <code>char[]</code> is a writable local array. <code>const char*</code> may point to a literal in ROM?\ubd31ead-only memory.</p>"},{"location":"C_C%2B%2B_Basics/AR250325/#code-demonstration","title":"Code Demonstration","text":"<pre><code>char szSrc[100] = \"Copy\";\nchar szDest[100] = \"\";\nStringCopy(szDest, szSrc); // szDest == \"Copy\"\n\nchar szSrc1[100] = \"defg\";\nchar szDest1[100] = \"abc\";\nStringCat(szDest1, szSrc1); // szDest1 == \"abcdefg\"\n\nchar szNum[100] = {};\nItoA(szNum, 72543); // szNum == \"72543\"\n\nint value = AtoI(\"2452\"); // value == 2452\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250325/#visual-string-concatenation","title":"Visual: String Concatenation","text":"<pre><code>Before Cat:\nDest: \"abc\"\nSrc:  \"def\"\n\nAfter Cat:\nDest: \"abcdef\"\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250325/#summary","title":"Summary","text":"<p>These foundational string functions provide a great low-level look into memory layout, string processing, and manual type conversions in C++. Knowing their implementation helps reinforce understanding of pointers, arrays, and memory safety?\ubd22ssential skills for systems-level programming.</p>"},{"location":"C_C%2B%2B_Basics/AR250325/#references","title":"References","text":"<ul> <li>my_string.cpp</li> <li>my_string.h</li> <li>char_char_array.cpp</li> <li>char_and_pointer.cpp</li> <li>HW250325.cpp</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250326/","title":"Memory Layout and Static Variables","text":""},{"location":"C_C%2B%2B_Basics/AR250326/#date-2025-03-26","title":"Date: 2025-03-26","text":""},{"location":"C_C%2B%2B_Basics/AR250326/#key-points","title":"Key Points","text":"<ul> <li>Local variables reside in the stack segment.</li> <li>Global, static, and external variables live in the data segment.</li> <li><code>static</code> variables retain state across function calls.</li> <li>Heap memory is dynamically allocated during runtime.</li> <li>ROM includes constants, code, and string literals.</li> <li>Accessing static variables via pointers allows indirect manipulation.</li> <li>Dynamic allocation enables flexible memory usage.</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250326/#overview","title":"Overview","text":"<p>Understanding how different types of variables are stored in memory is crucial for writing efficient and bug-free C/C++ code. This includes knowing the distinctions between stack, data, heap, and ROM segments.</p> <p>This example demonstrates the use of various storage classes: local, global, static, and dynamic memory allocation. It also shows how to indirectly modify <code>static</code> variables declared within a function using pointers.</p> <pre><code>#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n\n// Global variable - stored in data segment\ntint global = 10;\nint g_Arr[10] = {}; // Global array - also in data segment\n\n// Custom data type defined by struct\nstruct MyDatType {\n    int arr[2];     // Two integer elements\n    float fArr[3];  // Three float elements\n};\n\n// Function that returns a pointer to a static variable\nint* Test() {\n    static int iStatic = 0; // Stored in data segment, retains value across calls\n\n    ++global;     // Modify global variable\n    ++iStatic;    // Modify static variable\n\n    return &amp;iStatic; // Return address to allow external modification\n}\n\nint main() {\n    // Accessing and modifying a static variable indirectly via pointer\n    int* pInt = Test();\n    *pInt = 100;  // Modifies the static variable directly\n    Test();       // Calls again to observe incremented behavior\n\n    ++global;     // Directly modify global variable\n\n    // Dynamic memory allocation happens in heap\n    // Enables allocation of memory at runtime\n\n    int Value = 10;         // Local variable - stack\n    int iArr[10];           // Local array - stack\n\n    MyDatType data = {};    // Struct instance - stack\n    data.arr[0];            // Accessing struct members\n    data.arr[1];\n    data.fArr[0];\n    data.fArr[1];\n    data.fArr[2];\n\n    return 0;\n}\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250326/#common-mistakes","title":"Common Mistakes","text":"<p>Trying to directly access a static variable outside its scope <pre><code>// ++iStatic; // Invalid - `iStatic` is local to Test(), cannot access directly\n</code></pre></p> <p>Forgetting to initialize dynamically allocated memory <pre><code>int* arr = (int*)malloc(10 * sizeof(int));\n// Always initialize or set the memory to avoid garbage values\nfree(arr); // Always remember to free dynamically allocated memory\n</code></pre></p>"},{"location":"C_C%2B%2B_Basics/AR250326/#tricky-case-static-inside-function","title":"Tricky Case: Static Inside Function","text":"<p>Even though a <code>static</code> variable is local to a function, you can manipulate its value from outside by returning its address.</p> <pre><code>int* p = Test();\n*p = 42; // Updates the static variable inside Test()\n</code></pre> <p>The static variable is still not globally accessible, but its address can leak outside the function scope for controlled use.</p>"},{"location":"C_C%2B%2B_Basics/AR250326/#interview-questions","title":"Interview Questions","text":"<p>Q: What is the difference between <code>static</code> and <code>global</code> variables in C? A: Both are stored in the data segment, but <code>static</code> limits the scope to the defining function or file, while global variables are accessible across files.</p> <p>Q: What are the different memory segments in a C program? A: Stack (local variables), Heap (dynamic allocation), Data (global/static), ROM (constants, code).</p> <p>Q: Can you return a pointer to a local variable from a function? A: No. Local variables are destroyed after function returns. But returning the address of a <code>static</code> variable is valid since it lives beyond the function scope.</p> <p>Q: Why is heap allocation not related to the heap data structure? A: The term \"heap\" here refers to a memory region, not the data structure. Dynamic allocation uses this region but not the heap structure (min/max trees).</p>"},{"location":"C_C%2B%2B_Basics/AR250326/#visual-memory-segments","title":"Visual: Memory Segments","text":"<pre><code>Memory Segment     | Contents                      | Example\n------------------ | ----------------------------- | ----------------------\nStack              | Local variables               | int x;\nHeap               | Dynamically allocated memory  | malloc()\nData               | Static/Global variables       | static int i;\nROM (Text)         | Code, constants, literals     | \"Hello\" string\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250326/#summary","title":"Summary","text":"<p>This study explores how variable storage classes affect memory usage and lifetime. <code>static</code> variables are powerful tools when persistent state is needed within function scope, while dynamic memory allows flexibility at runtime. Being aware of memory segment layout is essential for low-level optimization and preventing memory issues.</p>"},{"location":"C_C%2B%2B_Basics/AR250326/#references","title":"References","text":"<ul> <li>my_string.cpp</li> <li>my_string.h</li> <li>dynamic_allocation</li> <li>char_char_array.cpp</li> <li>char_and_pointer.cpp</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250327/","title":"Dynamic Memory Allocation and Heap Management","text":""},{"location":"C_C%2B%2B_Basics/AR250327/#date-2025-03-27","title":"Date: 2025-03-27","text":""},{"location":"C_C%2B%2B_Basics/AR250327/#key-points","title":"Key Points","text":"<ul> <li><code>malloc()</code> allocates memory in the heap based on the byte size.</li> <li>Always <code>free()</code> dynamically allocated memory to prevent memory leaks.</li> <li>The return type of <code>malloc()</code> is <code>void*</code> because it doesn't assume the type of allocated memory.</li> <li>Heap corruption can occur if memory is accessed beyond the allocated bounds.</li> <li>Using structures like dynamic arrays requires careful memory management.</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250327/#overview","title":"Overview","text":"<p>Dynamic memory allocation in C is a powerful tool that enables allocating memory at runtime using the heap. This is particularly useful for variable-sized data like dynamic arrays.</p> <p>The functions <code>malloc()</code> and <code>free()</code> are essential: - <code>malloc(size)</code> allocates <code>size</code> bytes and returns a pointer to the first byte. - <code>free(ptr)</code> deallocates memory previously allocated with <code>malloc()</code>.</p> <p>If memory is allocated and not freed, it leads to a memory leak, which can gradually consume all available memory.</p> <pre><code>#include &lt;stdlib.h&gt;\n\nint main()\n{\n    // Allocate 200 bytes in the heap\n    void* pData = malloc(200);\n\n    // Always free dynamically allocated memory\n    free(pData);\n\n    return 0;\n}\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250327/#dynamic-array-example","title":"Dynamic Array Example","text":"<p>This sample shows how a custom dynamic array is used via a user-defined structure and helper functions (<code>InitArr</code>, <code>PushBack</code>).</p> <pre><code>#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include \"Array.h\"\n\nint main()\n{\n    int iArr[10] = {}; // Static array\n\n    tArray arr = {};   // Custom dynamic array\n    InitArr(&amp;arr);     // Initialize dynamic array\n\n    // Push elements into dynamic array\n    PushBack(&amp;arr, 100);\n    PushBack(&amp;arr, 200);\n    PushBack(&amp;arr, 300);\n    PushBack(&amp;arr, 400);\n    PushBack(&amp;arr, 500);\n    PushBack(&amp;arr, 600);\n    PushBack(&amp;arr, 700);\n    PushBack(&amp;arr, 800);\n    PushBack(&amp;arr, 900);\n\n    // Print all elements\n    for (int i = 0; i &lt; arr.Size; ++i)\n    {\n        printf(\"%d\\n\", arr.pArr[i]);\n    }\n\n    // Free the allocated memory to avoid memory leak\n    free(arr.pArr);\n\n    return 0;\n}\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250327/#common-mistakes","title":"Common Mistakes","text":"<p>Memory Leak <pre><code>void* p = malloc(100);\n// forgot to free(p); -&gt; memory leak\n</code></pre></p> <p>Heap Corruption <pre><code>arr.pArr[1800] = 10; // Dangerous: Accessing memory beyond allocation\n</code></pre> Accessing beyond the allocated size may corrupt memory and lead to unpredictable behavior. It may or may not crash the program, making it hard to detect.</p>"},{"location":"C_C%2B%2B_Basics/AR250327/#tricky-case-void-pointer-and-casting","title":"Tricky Case: Void Pointer and Casting","text":"<p><code>malloc()</code> returns a <code>void*</code>, which must be cast to the appropriate type:</p> <p><pre><code>int* pData = (int*)malloc(sizeof(int));\n*pData = 10;\n</code></pre> This makes the allocation flexible but puts the responsibility of correct usage on the programmer.</p>"},{"location":"C_C%2B%2B_Basics/AR250327/#interview-questions","title":"Interview Questions","text":"<p>Q: Why does <code>malloc()</code> return <code>void*</code>? A: It returns <code>void*</code> to allow allocating memory for any data type. The caller casts the returned pointer to the appropriate type.</p> <p>Q: What happens if you forget to <code>free()</code> memory? A: It results in a memory leak ? memory stays allocated until the program terminates, reducing available memory over time.</p> <p>Q: How can you prevent heap corruption? A: Always ensure you access memory within the bounds of what you allocated. Use debugging tools like Valgrind or built-in runtime checks when available.</p> <p>Q: What's the difference between stack and heap allocation? A: Stack allocation is automatic and limited in size, suitable for small, fixed-size data. Heap allocation is manual and allows large or dynamic-sized data but must be freed manually.</p>"},{"location":"C_C%2B%2B_Basics/AR250327/#summary","title":"Summary","text":"<p>Dynamic memory is key to flexible C programs. Functions like <code>malloc()</code> and <code>free()</code> provide control but demand responsibility. Mismanagement leads to memory leaks or heap corruption. Understanding how and when to allocate/deallocate memory is essential to writing safe and efficient code.</p>"},{"location":"C_C%2B%2B_Basics/AR250327/#references","title":"References","text":"<ul> <li>dynamic_alloc_usage.cpp</li> <li>dynamic_alloc_apply.cpp</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250328/","title":"Linked List and Dynamic Array","text":""},{"location":"C_C%2B%2B_Basics/AR250328/#date-2025-03-28","title":"Date: 2025-03-28","text":""},{"location":"C_C%2B%2B_Basics/AR250328/#key-points","title":"Key Points","text":"<ul> <li>Linked lists enable constant time insertion at the front (<code>O(1)</code>), but traversal and indexing are linear (<code>O(N)</code>).</li> <li>Dynamic arrays allow fast indexing (<code>O(1)</code>), but insertion can require memory reallocation (<code>O(N)</code> worst case).</li> <li>Big-O notation is used to describe algorithm efficiency in terms of input size.</li> <li>Memory management is crucial: always <code>free()</code> dynamically allocated memory to avoid leaks.</li> <li>Debug flags like <code>_CRTDBG_LEAK_CHECK_DF</code> can help identify memory leaks in development.</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250328/#overview","title":"Overview","text":"<p>This example demonstrates dynamic memory management through a basic implementation of a dynamic array and a singly linked list. Key focus areas include:</p> <ul> <li>Dynamic allocation using <code>malloc</code></li> <li>Linked list operations: <code>PushBack</code>, <code>PushFront</code>, and <code>Release</code></li> <li>Manual memory management and debugging practices</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250328/#dynamic-array","title":"Dynamic Array","text":"<p>The array expands dynamically when capacity is exceeded:</p> <pre><code>void PushBack(tArray* _pArr, int _Data) {\n    if (_pArr-&gt;Size == _pArr-&gt;Capacity) {\n        int* pNew = (int*)malloc(sizeof(int) * _pArr-&gt;Capacity * 2);\n        for (int i = 0; i &lt; _pArr-&gt;Size; ++i) {\n            pNew[i] = _pArr-&gt;pArr[i];\n        }\n        free(_pArr-&gt;pArr);\n        _pArr-&gt;pArr = pNew;\n        _pArr-&gt;Capacity *= 2;\n    }\n    _pArr-&gt;pArr[_pArr-&gt;Size++] = _Data;\n}\n</code></pre> <p>This ensures capacity is doubled when full, mimicking vector-like behavior.</p>"},{"location":"C_C%2B%2B_Basics/AR250328/#linked-list","title":"Linked List","text":"<p>The list supports inserting data at both the front and the back:</p> <pre><code>void PushBack(tList* _List, int _Data) {\n    tNode* pNode = (tNode*)malloc(sizeof(tNode));\n    pNode-&gt;Data = _Data;\n    pNode-&gt;pNext = nullptr;\n\n    if (_List-&gt;pHead == nullptr) {\n        _List-&gt;pHead = pNode;\n    } else {\n        tNode* pLast = _List-&gt;pHead;\n        while (pLast-&gt;pNext != nullptr) {\n            pLast = pLast-&gt;pNext;\n        }\n        pLast-&gt;pNext = pNode;\n    }\n    ++_List-&gt;Size;\n}\n</code></pre> <pre><code>void PushFront(tList* _List, int _Data) {\n    tNode* pNewNode = (tNode*)malloc(sizeof(tNode));\n    pNewNode-&gt;Data = _Data;\n    pNewNode-&gt;pNext = _List-&gt;pHead;\n    _List-&gt;pHead = pNewNode;\n    ++_List-&gt;Size;\n}\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250328/#memory-management","title":"Memory Management","text":"<p>Every dynamic allocation must be paired with a corresponding deallocation to prevent memory leaks:</p> <pre><code>void Release(tList* _List) {\n    tNode* pNode = _List-&gt;pHead;\n    while (pNode != nullptr) {\n        tNode* pNext = pNode-&gt;pNext;\n        free(pNode);\n        pNode = pNext;\n    }\n    _List-&gt;pHead = nullptr;\n    _List-&gt;Size = 0;\n}\n</code></pre> <p>Enable memory leak checks in Visual Studio with:</p> <pre><code>_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250328/#common-mistakes","title":"Common Mistakes","text":"<p>Accessing Freed Memory <pre><code>Release(&amp;list);\nlist.pHead-&gt;Data = 5;  // Undefined behavior!\n</code></pre> Always reset pointers after <code>free</code> or inside cleanup functions.</p> <p>Forgetting to Resize Dynamic Arrays <pre><code>// Incorrect usage - no resize logic\narr.pArr[arr.Size++] = 999;  // May cause heap corruption\n</code></pre> Always check and resize when adding elements.</p>"},{"location":"C_C%2B%2B_Basics/AR250328/#tricky-case-memory-debugging","title":"Tricky Case: Memory Debugging","text":"<p>When using <code>_CrtSetDbgFlag</code>, memory leaks are printed automatically at the end of program execution in debug mode. This is particularly useful when working with dynamic structures like linked lists.</p>"},{"location":"C_C%2B%2B_Basics/AR250328/#interview-questions","title":"Interview Questions","text":"<p>Q: When would you choose a linked list over a dynamic array? A: When frequent insertions/removals at the beginning or middle of the collection are required. Linked lists allow <code>O(1)</code> front insertion, unlike arrays which require shifting elements.</p> <p>Q: Why is it dangerous to access memory after freeing it? A: The memory region may be reassigned or invalidated, leading to undefined behavior or program crashes.</p> <p>Q: What happens when you forget to <code>free()</code> dynamically allocated memory? A: It results in a memory leak, which can cause performance degradation over time.</p> <p>Q: Why does <code>malloc</code> return <code>void*</code>? A: Because <code>malloc</code> doesn't know the target type. It returns a generic pointer that must be cast by the programmer.</p> <p>Q: What is the time complexity of inserting at the end of a singly linked list? A: <code>O(N)</code>, unless a tail pointer is maintained, in which case it becomes <code>O(1)</code>.</p>"},{"location":"C_C%2B%2B_Basics/AR250328/#code-demonstration-output","title":"Code Demonstration Output","text":"<pre><code>// list2 stores 300, 200, 100 via PushFront()\ntNode* pNode = list2.pHead;\nwhile (pNode) {\n    printf(\"%d\\n\", pNode-&gt;Data);\n    pNode = pNode-&gt;pNext;\n}\n</code></pre> <p>Expected output: <pre><code>300\n200\n100\n</code></pre></p>"},{"location":"C_C%2B%2B_Basics/AR250328/#references","title":"References","text":"<ul> <li>dynamic_alloc_apply.cpp</li> <li>linked_list.cpp</li> <li>list.cpp</li> <li>list.h</li> <li>array.cpp</li> <li>array.h</li> <li>HW250328.cpp</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250331/","title":"Class vs Struct, Encapsulation, and Const-Correctness","text":""},{"location":"C_C%2B%2B_Basics/AR250331/#date-2025-03-31","title":"Date: 2025-03-31","text":""},{"location":"C_C%2B%2B_Basics/AR250331/#key-points","title":"Key Points","text":"<ul> <li>Both <code>class</code> and <code>struct</code> are user-defined types in C++, with default access specifiers differing.</li> <li>C++ <code>class</code> introduces object-oriented features: encapsulation, information hiding, inheritance, polymorphism, and abstraction.</li> <li>Use <code>private</code> to enforce data hiding and <code>public</code> to expose member functions.</li> <li>Const correctness (<code>const</code> after member functions) ensures safe access for constant objects.</li> <li>Member initialization for <code>const</code> variables must be done using initializer lists.</li> <li><code>this</code> pointer implicitly refers to the current object instance.</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250331/#overview","title":"Overview","text":"<p>C++ builds upon C by introducing the concept of <code>class</code> with rich object-oriented features. While C relies on <code>struct</code> for custom data types, C++ uses both <code>class</code> and <code>struct</code>, with the key distinction being the default access specifier (<code>private</code> for <code>class</code>, <code>public</code> for <code>struct</code>).</p>"},{"location":"C_C%2B%2B_Basics/AR250331/#example-basic-struct-and-class","title":"Example: Basic struct and class","text":"<pre><code>struct MyData {\npublic:\n    int iData;\n};\n\nclass CMyData {\nprivate:\n    int iData;\n};\n\nint main() {\n    MyData data = {};\n    data.iData = 0; // OK: public access\n\n    CMyData CData = {};\n    // CData.iData = 0; // Error: private member\n    return 0;\n}\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250331/#common-mistakes","title":"Common Mistakes","text":"<p>Assuming structs are limited compared to classes <pre><code>struct S {\n    void func(); // Valid in C++\n};\n</code></pre> In C++, <code>struct</code> can have methods, constructors, destructors, inheritance, etc.</p> <p>Ignoring access specifier defaults <pre><code>struct S { int a; };  // a is public\nclass C { int a; };   // a is private\n</code></pre></p> <p>Failing to use initializer list for <code>const</code> members <pre><code>class C {\n    const int val;\npublic:\n    C() : val(10) {}  // Required for const\n};\n</code></pre></p>"},{"location":"C_C%2B%2B_Basics/AR250331/#const-member-functions","title":"Const Member Functions","text":"<p>Member functions that do not modify the state of the object should be marked <code>const</code>. This ensures they can be safely called on constant objects or pointers to constant objects.</p> <pre><code>class CNewClass {\nprivate:\n    int m_i;\n    const int m_i2;\n\npublic:\n    int GetInt() const { return m_i; }\n    int GetInt2() const { return m_i2; }\n\n    void SetData(int _a) { m_i = _a; }\n\n    CNewClass() : m_i(200), m_i2(400) {}\n    ~CNewClass() {}\n};\n\nint main() {\n    const CNewClass obj;\n    int x = obj.GetInt();   // OK\n    int y = obj.GetInt2();  // OK\n    // obj.SetData(10);     // Error: cannot modify const object\n    return 0;\n}\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250331/#tricky-case-memory-alignment-in-structs","title":"Tricky Case: Memory Alignment in Structs","text":"<p>C++ aligns data in structs based on the size of the largest member unless specified otherwise.</p> <pre><code>#pragma pack(1)\nstruct tMyStruct {\n    int   i;\n    int   i2;\n    short s;\n    char  c;\n};\n\nint main() {\n    tMyStruct my = {};\n    int size = sizeof(tMyStruct); // Size tightly packed due to #pragma pack(1)\n    return 0;\n}\n</code></pre> <p>Without <code>#pragma pack(1)</code>, compilers may add padding for performance, changing the total size.</p>"},{"location":"C_C%2B%2B_Basics/AR250331/#interview-questions","title":"Interview Questions","text":"<p>Q: Difference between <code>struct</code> and <code>class</code> in C++? A: Functionally similar, but <code>struct</code> defaults to public members while <code>class</code> defaults to private.</p> <p>Q: Why mark getter functions as <code>const</code>? A: It ensures the method can be called on const objects and doesn\u00e2\u20ac\u2122t modify the object's state.</p> <p>Q: When must initializer lists be used? A: For initializing <code>const</code> or reference data members in constructors.</p> <p>Q: What does the <code>this</code> pointer represent? A: It holds the address of the current object and is used implicitly to access member variables inside class methods.</p>"},{"location":"C_C%2B%2B_Basics/AR250331/#visual-class-member-access","title":"Visual: Class Member Access","text":"<pre><code>Object: CNewClass my\n---------------------\nPrivate:\n  m_i   = accessible only via member functions\n  m_i2  = accessible only via member functions\n\nPublic:\n  GetInt()   --&gt; returns m_i\n  GetInt2()  --&gt; returns m_i2\n  SetData()  --&gt; modifies m_i\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250331/#code-demonstration","title":"Code Demonstration","text":"<pre><code>CNewClass my;\nint i = my.GetInt();\ni = my.GetInt2();\n\nCNewClass* pNC = &amp;my;\ni = pNC-&gt;GetInt();\ni = pNC-&gt;GetInt2();\n\nconst CNewClass* pConstNC = &amp;my;\ni = pConstNC-&gt;GetInt();\ni = pConstNC-&gt;GetInt2();\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250331/#references","title":"References","text":"<ul> <li>list.cpp</li> <li>list.h</li> <li>linked_list.cpp</li> <li>oop_access_specifier</li> <li>struct_size</li> <li>generator_terminator.cpp</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250401/","title":"Function &amp; Operator Overloading, Object Lifetime, and Const Safety","text":""},{"location":"C_C%2B%2B_Basics/AR250401/#date-2025-04-01","title":"Date: 2025-04-01","text":""},{"location":"C_C%2B%2B_Basics/AR250401/#key-points","title":"Key Points","text":"<ul> <li>Function overloading allows multiple functions with the same name but different parameters.</li> <li>Operator overloading lets user-defined types behave like built-in types.</li> <li>Special member functions (constructor, destructor) define object lifecycle.</li> <li>Use const correctness to enforce read-only access.</li> <li>Const member functions can be called on const objects or pointers.</li> <li>Overloading &lt;&lt; for custom behavior is useful in chaining calls.</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250401/#overview","title":"Overview","text":"<p>This note covers C++ concepts including function and operator overloading, references, object lifetime, const correctness, and tricky chaining using overloaded operators. Understanding these foundational concepts is crucial for writing safe and idiomatic C++ code.</p>"},{"location":"C_C%2B%2B_Basics/AR250401/#function-overloading","title":"Function Overloading","text":"<pre><code>int GetInt() {\n    int a = 100;\n    return a;\n}\n\nvoid EndL() {\n    printf(\"\\n\");\n}\n\nvoid Test() {\n    printf(\"a\");\n}\n</code></pre> <p>Multiple functions (<code>GetInt</code>, <code>EndL</code>, <code>Test</code>) are declared with different names and purposes. Function overloading would typically involve the same name with different parameters, though not directly used here.</p>"},{"location":"C_C%2B%2B_Basics/AR250401/#operator-overloading-in-a-class","title":"Operator Overloading in a Class","text":"<pre><code>class CMyDataType {\nprivate:\n    int m_Data;\n\npublic:\n    void SetData(int _i) {\n        m_Data = _i;\n    }\n\n    // Overload + to add two objects\n    CMyDataType operator+(CMyDataType _Other) {\n        CMyDataType data;\n        data.m_Data = m_Data + _Other.m_Data;\n        return data;\n    }\n\n    // Overload &lt;&lt; to output int\n    CMyDataType&amp; operator&lt;&lt;(int a) {\n        printf(\"%d\", a);\n        return *this;\n    }\n\n    // Overload &lt;&lt; to output float\n    CMyDataType&amp; operator&lt;&lt;(float a) {\n        printf(\"%f\", a);\n        return *this;\n    }\n\n    // Overload &lt;&lt; to output function (e.g., EndL)\n    CMyDataType&amp; operator&lt;&lt;(void(*pFunc)(void)) {\n        pFunc();\n        return *this;\n    }\n\n    CMyDataType() : m_Data(0) {}\n    ~CMyDataType() {}\n};\n</code></pre> <p>This class demonstrates: - Overloading <code>+</code> to add internal data of two <code>CMyDataType</code> instances. - Overloading <code>&lt;&lt;</code> for <code>int</code>, <code>float</code>, and function pointer types to support flexible output and chaining, similar to <code>std::cout</code> behavior.</p>"},{"location":"C_C%2B%2B_Basics/AR250401/#reference-vs-pointer","title":"Reference vs Pointer","text":"<pre><code>int a = 0;\nint* pInt = &amp;a;\n*pInt = 100;\n\nint&amp; Ref = a;\nRef = 200;\n</code></pre> <ul> <li>A pointer (<code>pInt</code>) can change what it points to and needs dereferencing.</li> <li>A reference (<code>Ref</code>) acts as an alias and must be initialized upon declaration. Cannot be changed later.</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250401/#const-correctness-and-object-lifetime","title":"Const Correctness and Object Lifetime","text":"<pre><code>class CNewClass {\nprivate:\n    int m_i;\n    const int m_i2;\n\npublic:\n    int GetInt() const {\n        return m_i;\n    }\n\n    int GetInt2() const {\n        return m_i2;\n    }\n\n    void SetData(int _a) {\n        m_i = _a;\n    }\n\n    CNewClass() : m_i(200), m_i2(400) {}\n    ~CNewClass() {}\n};\n</code></pre> <p>Key details: - Const members (<code>m_i2</code>) must be initialized in the constructor initializer list. - Member functions marked <code>const</code> ensure no modification to the object state.</p>"},{"location":"C_C%2B%2B_Basics/AR250401/#tricky-case-chaining-with-overloaded","title":"Tricky Case: Chaining With Overloaded &lt;&lt;","text":"<pre><code>d1 &lt;&lt; 20 &lt;&lt; 30 &lt;&lt; 40 &lt;&lt; EndL &lt;&lt; 10 &lt;&lt; 20 &lt;&lt; 30;\n</code></pre> <ul> <li>This works because <code>operator&lt;&lt;</code> returns a reference to <code>*this</code>, allowing the chain.</li> <li>Can even chain functions like <code>EndL</code> thanks to <code>operator&lt;&lt;(void(*)(void))</code>.</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250401/#common-mistakes","title":"Common Mistakes","text":"<p>Forgetting return by reference in operator overloading <pre><code>// BAD: returns by value, can't chain\nCMyDataType operator&lt;&lt;(int a) {\n    printf(\"%d\", a);\n    return *this; // Copies instead of referencing\n}\n\n// GOOD: returns by reference\nCMyDataType&amp; operator&lt;&lt;(int a) {\n    printf(\"%d\", a);\n    return *this;\n}\n</code></pre></p> <p>Not marking member functions as const <pre><code>int GetInt() { return m_i; } // Can't call on const object\nint GetInt() const { return m_i; } // OK for const object\n</code></pre></p> <p>Misusing initializer lists <pre><code>CNewClass() {\n    m_i = 200;       // OK\n    m_i2 = 400;      // Error: const must be initialized in initializer list\n}\n</code></pre></p>"},{"location":"C_C%2B%2B_Basics/AR250401/#interview-questions","title":"Interview Questions","text":"<p>Q: Why overload the <code>&lt;&lt;</code> operator for custom types? A: To allow expressive output similar to <code>std::cout</code>, especially when chaining multiple values.</p> <p>Q: What happens if you omit <code>const</code> in a getter function? A: You can't call that function on const objects or pointers to const.</p> <p>Q: Can const members be modified in the constructor body? A: No, they must be initialized in the constructor initializer list.</p> <p>Q: What is the difference between a pointer and a reference? A: A pointer can be reassigned and requires dereferencing; a reference is an alias and must be initialized immediately.</p> <p>Q: Why return <code>*this</code> by reference in operator overloading? A: To enable chaining calls without making copies.</p>"},{"location":"C_C%2B%2B_Basics/AR250401/#code-demonstration","title":"Code Demonstration","text":"<pre><code>CMyDataType d1, d2, d3;\nd1.SetData(10);\nd2.SetData(100);\nd3 = d1 + d2; // operator+\n\nd1 &lt;&lt; 20 &lt;&lt; 30 &lt;&lt; EndL &lt;&lt; 40; // operator&lt;&lt; chaining\n</code></pre> <pre><code>CNewClass obj;\nint x = obj.GetInt(); // Safe because of const\nconst CNewClass* pObj = &amp;obj;\nx = pObj-&gt;GetInt2(); // Also safe\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250401/#visual-chained-output-with-overloaded","title":"Visual: Chained Output With Overloaded &lt;&lt;","text":"<pre><code>Before:\nCall: d1 &lt;&lt; 20\n    Prints: 20\nReturns: reference to d1\n\nThen:\nd1 &lt;&lt; 30\n    Prints: 30\nReturns: reference to d1\n\n...\nSupports chaining like: d1 &lt;&lt; 20 &lt;&lt; 30 &lt;&lt; EndL &lt;&lt; 40\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250401/#references","title":"References","text":"<ul> <li>generator_and_terminator.cpp</li> <li>reference.cpp</li> <li>operator_overloading.cpp</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250402/","title":"Namespaces, Constructors, and Copy Mechanics","text":""},{"location":"C_C%2B%2B_Basics/AR250402/#date-2025-04-02","title":"Date: 2025-04-02","text":""},{"location":"C_C%2B%2B_Basics/AR250402/#key-points","title":"Key Points","text":"<ul> <li>Namespaces help avoid naming conflicts and allow scoped access to functions and variables.</li> <li>Function overloading works across namespaces.</li> <li>Pointer and reference manipulation has different semantics.</li> <li>Default constructors are not auto-generated if any constructor is explicitly declared.</li> <li>Copy constructors and assignment operators must be carefully defined together when deep copy behavior is needed.</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250402/#overview","title":"Overview","text":""},{"location":"C_C%2B%2B_Basics/AR250402/#namespace-use-and-overloading","title":"Namespace Use and Overloading","text":"<p>Namespaces are used to avoid name collisions in larger projects. You can access namespace members using <code>::</code>, or bring them into scope using <code>using</code>.</p> <pre><code>namespace MY_SPACE {\n    void IntChange(int* _Data) { *_Data = 200; }\n    void IntChange(int&amp; _Data) { _Data = 400; }\n\n    namespace SUB_SPACE {\n        void IntPtrChange(int*&amp; _Data) { _Data = (int*)10; }\n        void IntPtrChange(int** _Data) { *_Data = (int*)4; }\n    }\n\n    int g_Int = 0;\n}\n\nusing MY_SPACE::SUB_SPACE::IntPtrChange;\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250402/#main-function-demo","title":"Main Function Demo","text":"<pre><code>int main() {\n    int* p = nullptr;\n    IntChange(p);  // Function in global scope\n\n    int a = 10;\n    MY_SPACE::IntChange(&amp;a); // Pointer version\n    MY_SPACE::IntChange(a);  // Reference version\n\n    int* pInt = nullptr;\n    IntPtrChange(pInt);      // Reference to pointer\n    IntPtrChange(&amp;pInt);     // Pointer to pointer\n\n    MY_SPACE::g_Int = 100;\n    cout &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250402/#constructors-and-copy-semantics","title":"Constructors and Copy Semantics","text":""},{"location":"C_C%2B%2B_Basics/AR250402/#constructor-overloading","title":"Constructor Overloading","text":"<pre><code>class MyClass {\nprivate:\n    float m_Data;\n\npublic:\n    void SetData(float _Data) { m_Data = _Data; }\n\n    MyClass() : m_Data(0.f) {}\n    MyClass(float _Data) : m_Data(_Data) {}\n    MyClass(const MyClass&amp; _Other) : m_Data(_Other.m_Data) {}\n    ~MyClass() {}\n};\n</code></pre> <p>Important Notes: - If any constructor is explicitly defined, the default constructor is not generated. - Use initializer list for better performance and to initialize <code>const</code> or reference members.</p> <pre><code>MyClass data;        // OK\nMyClass data();      // Interpreted as function declaration, not object\nMyClass my2(my1);    // Uses copy constructor\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250402/#copy-constructor-and-assignment-operator","title":"Copy Constructor and Assignment Operator","text":""},{"location":"C_C%2B%2B_Basics/AR250402/#combined-concepts","title":"Combined Concepts","text":"<pre><code>class CNew {\nprivate:\n    int m_i; \n    short m_s; \n\npublic: \n    void SetInt(int _a) { m_i = _a; }\n\n    // Default assignment operator\n    CNew&amp; operator=(const CNew&amp; _Other) {\n        m_i = _Other.m_i; \n        m_s = _Other.m_s; \n        return *this; \n    }\n\npublic: \n    CNew() : m_i(0), m_s(0) {}\n\n    // Default copy constructor disabled\n    CNew(const CNew&amp; _Other) = delete;\n\n    // Custom copy constructor\n    CNew(const CNew&amp; _Other)\n        : m_i(_Other.m_i), m_s(_Other.m_s) {}\n};\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250402/#basic-object-creation","title":"Basic Object Creation","text":"<pre><code>CNew Inst1;         // Default constructor\n// CNew Inst1();    // Misinterpreted as function declaration\nInst1.SetInt(10);   // Initialize via setter\n\nCNew Inst2(Inst1);  // Uses copy constructor\n\nCNew Inst3;\nInst3 = Inst1;      // Uses assignment operator\n\nCNew Inst4 = Inst3; // Optimized as copy constructor\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250402/#notes","title":"Notes","text":"<ul> <li>If any constructor is implemented, the compiler does not auto-generate the default constructor.</li> <li>If the copy constructor is implemented, the default assignment operator must be implemented explicitly.</li> <li>Always define all necessary special member functions (Rule of Five).</li> </ul>"},{"location":"C_C%2B%2B_Basics/AR250402/#tricky-case-reference-vs-pointer-overloading","title":"Tricky Case: Reference vs Pointer Overloading","text":"<pre><code>namespace MY_SPACE {\n    void IntChange(int* _Data) { *_Data = 200; }\n    void IntChange(int&amp; _Data) { _Data = 400; }\n}\n\nint main() {\n    int a = 10;\n    MY_SPACE::IntChange(&amp;a); // Calls pointer version\n    MY_SPACE::IntChange(a);  // Calls reference version\n}\n</code></pre> <p>Understanding which overload is called is key when dealing with overloaded functions and pointer/reference parameters.</p>"},{"location":"C_C%2B%2B_Basics/AR250402/#common-mistakes","title":"Common Mistakes","text":"<ul> <li>Misinterpreting <code>ClassName obj();</code> as object creation \u2014 it's parsed as a function declaration.</li> <li>Forgetting to define the default constructor when defining copy/move constructors.</li> <li>Returning void in an assignment operator.</li> </ul> <pre><code>void operator=(const CNew&amp; _Other); // WRONG \u2014 should return reference\n</code></pre>"},{"location":"C_C%2B%2B_Basics/AR250402/#interview-questions","title":"Interview Questions","text":"<p>Q: What happens if you implement a copy constructor but not a default constructor? A: The compiler does not generate a default constructor automatically if any constructor is explicitly defined.</p> <p>Q: What's the difference between passing by pointer vs reference? A: Both allow modification of the original variable, but references are generally safer and clearer. Pointers can be reassigned and can be null.</p> <p>Q: What is the rule of three/five? A: If a class requires a custom destructor, copy constructor, or copy assignment operator, it likely requires all three. In modern C++, this extends to five: include move constructor and move assignment operator.</p> <p>Q: How can a constructor declaration become a function declaration by mistake? A: Declaring an object like <code>ClassName obj();</code> makes the compiler think it's a function returning <code>ClassName</code> instead of creating an object.</p>"},{"location":"C_C%2B%2B_Basics/AR250402/#references","title":"References","text":"<ul> <li>operator_overloading.cpp</li> <li>namespace.cpp</li> <li>class_default_copy_gen_oper.cpp</li> <li>class_copy_gen_assign_oper.cpp</li> </ul>"},{"location":"Computer_Network/NW0503/","title":"Macroscopic View of Networks","text":""},{"location":"Computer_Network/NW0503/#11-basic-network-structure","title":"1.1 Basic Network Structure","text":"<p>Networks are structured as graphs composed of: - Nodes (vertices): Desktop computers, servers, smartphones, tablets, IoT devices, etc. - Edges (links): Connections between nodes</p> <pre><code>    Visual: Network as a Graph\n\n    [Desktop] --------- [Router] --------- [Server]\n        |                  |                  |\n        |                  |                  |\n    [Laptop] ---------- [Switch] --------- [Printer]\n                          |\n                          |\n                      [Smartphone]\n</code></pre> <p>Nodes can be categorized as: - Edge nodes: End devices (computers, smartphones, etc.) - Intermediate nodes: Network devices (routers, switches, etc.)</p>"},{"location":"Computer_Network/NW0503/#12-network-components","title":"1.2 Network Components","text":""},{"location":"Computer_Network/NW0503/#hosts","title":"Hosts","text":"<ul> <li>End devices that generate or consume network traffic</li> <li>Can be categorized as:</li> </ul> <pre><code>    Visual: Client-Server Interaction\n\n    Client                       Server\n    ------                       ------\n    [Browser]                    [Web Server]\n        |                            |\n        |------ Request: GET -------&gt;|\n        |                            |\n        |&lt;---- Response: HTML ------ |\n</code></pre> <ul> <li>Clients: Requesting hosts (e.g., web browsers requesting webpages)</li> <li>Servers: Responding hosts (e.g., web servers providing content)</li> <li>Roles are not exclusive:</li> <li>A device can act as both client and server</li> <li>Function depends on the current operation</li> </ul>"},{"location":"Computer_Network/NW0503/#network-devices","title":"Network Devices","text":"<ul> <li>Intermediate nodes that facilitate data transfer</li> <li>Examples: Ethernet hubs, switches, routers, Wi-Fi access points</li> <li>Primary function is to forward data through the network</li> </ul> <pre><code>    Visual: Network Devices\n\n    [Host A] --- [Switch] --- [Host B]\n                    |\n                    |\n    [Host C] --- [Router] --- [Internet]\n                    |\n                    |\n    [Host D] --- [WiFi AP] --- [Mobile]\n</code></pre>"},{"location":"Computer_Network/NW0503/#edges-links","title":"Edges (Links)","text":"<ul> <li>Telecommunication methods connecting nodes</li> <li>Can be wired (Ethernet cables) or wireless (Wi-Fi)</li> <li>Link characteristics affect network performance</li> </ul>"},{"location":"Computer_Network/NW0503/#messages","title":"Messages","text":"<ul> <li>Information transferred between nodes through edges</li> <li>Examples: Webpages, files, emails, etc.</li> </ul>"},{"location":"Computer_Network/NW0503/#13-network-classifications","title":"1.3 Network Classifications","text":""},{"location":"Computer_Network/NW0503/#by-geographic-scope","title":"By Geographic Scope","text":"<pre><code>    Visual: Network Types by Scope\n\n    +----------+              +----------+\n    |   LAN    |              |   LAN    |\n    | (Office) |              |  (Home)  |\n    +----------+              +----------+\n         |                         |\n         |                         |\n    +----------+              +----------+\n    |   MAN    |--------------|   WAN    |--------------- Internet\n    |  (City)  |              | (Global) |\n    +----------+              +----------+\n         |\n         |\n    +----------+\n    |   CAN    |\n    | (Campus) |\n    +----------+\n</code></pre> <ul> <li>LAN (Local Area Network): Limited geographical area (home, office)</li> <li>CAN (Campus Area Network): Several buildings (school, company campus)</li> <li>MAN (Metropolitan Area Network): City or metropolitan area</li> <li>WAN (Wide Area Network): Broad geographical coverage</li> </ul> <p>Note: Internet is a WAN connecting multiple LANs</p>"},{"location":"Computer_Network/NW0503/#by-message-exchange-method","title":"By Message Exchange Method","text":"<ol> <li>Circuit-Switched Networks</li> </ol> <pre><code>    Visual: Circuit Switching\n\n    [A] ------- [B] ------- [C]\n     |           |           |\n     |           |           |\n    [D] ------- [E] ------- [F]\n\n    Dedicated path A\u2192B\u2192C is reserved for the entire session\n    Path D\u2192E\u2192F cannot use B\u2192C even if available\n</code></pre> <ul> <li>Establishes dedicated connection before data transfer</li> <li>Route is reserved for the entire communication session</li> <li>Provides stable data transfer rates</li> <li> <p>Less efficient use of network resources</p> </li> <li> <p>Packet-Switched Networks</p> </li> </ul> <pre><code>    Visual: Packet Switching\n\n    [A] ------- [B] ------- [C]\n     |           |           |\n     |           |           |\n    [D] ------- [E] ------- [F]\n\n    Packet 1: A\u2192B\u2192C\n    Packet 2: A\u2192D\u2192E\u2192F\u2192C\n    Packet 3: A\u2192B\u2192E\u2192C\n</code></pre> <ul> <li>Divides messages into smaller units called packets</li> <li>Each packet can take a different path to the destination</li> <li>More efficient use of network resources</li> <li>Modern internet uses packet switching</li> </ul>"},{"location":"Computer_Network/NW0503/#14-packet-structure","title":"1.4 Packet Structure","text":"<pre><code>    Visual: Packet Structure\n\n    +--------+-------------------+--------+\n    | Header |      Payload      | Trailer|\n    +--------+-------------------+--------+\n       |            |                |\n       |            |                |\n    Control      Actual           Error\n    Info         Data            Checking\n    (Address)\n</code></pre> <p>Packets are similar to parcels: - Payload: Actual data being transferred - Header/Trailer: Control information (addressing, error-checking)</p>"},{"location":"Computer_Network/NW0503/#headers-include","title":"Headers include:","text":"<ul> <li>Addressing information (IP address, MAC address)</li> <li>Identifies sender and receiver</li> <li>Routing information</li> </ul>"},{"location":"Computer_Network/NW0503/#15-transmission-methods","title":"1.5 Transmission Methods","text":"<pre><code>    Visual: Transmission Methods\n\n    Unicast:        Broadcast:\n    [S] \u2192 [R]       [S] \u2192 [R1]\n                     \u2193    \u2193\n                    [R2] [R3]\n\n    Multicast:      Anycast:\n    [S] \u2192 [R1]      [S] \u2192 [Nearest R]\n     \u2193     \n    [R2]   [R3]\n</code></pre> <ul> <li>Unicast: One sender to one receiver (most common)</li> <li>Broadcast: One sender to all hosts in a network</li> <li>Multicast: One sender to a specific group of hosts</li> <li>Anycast: One sender to the nearest host in a specific group</li> </ul>"},{"location":"Computer_Network/NW0504/","title":"2. Microscopic View of Networks","text":""},{"location":"Computer_Network/NW0504/#21-network-protocols","title":"2.1 Network Protocols","text":"<pre><code>    Visual: Protocol Communication\n\n    Computer A                 Computer B\n    ----------                 ----------\n    Application                Application\n        \u2193                          \u2191\n    Protocol                    Protocol\n    Processing                  Processing\n        \u2193                          \u2191\n    Network                     Network\n    Interface                   Interface\n        \u2193                          \u2191\n        -----------------------------\n                    Network\n</code></pre> <p>Protocols are rules and methods for exchanging information: - Define how data is formatted, transmitted, and received - Similar to language used between parcel senders and receivers - Modern networks use multiple protocols simultaneously - Each protocol has specific purposes and characteristics</p> <p>Examples: - IP: Routes packets to destinations - ARP: Maps IP addresses to MAC addresses - HTTP/HTTPS: Web communications (HTTPS is more secure) - TCP/UDP: Transport layer protocols (TCP is more reliable, UDP is faster)</p>"},{"location":"Computer_Network/NW0504/#22-network-reference-models","title":"2.2 Network Reference Models","text":""},{"location":"Computer_Network/NW0504/#osi-model-7-layers","title":"OSI Model (7 Layers)","text":"<pre><code>    Visual: OSI Model Layers\n\n    +-------------------------+\n    | 7. Application Layer    | &lt;- User interface, access to network services\n    +-------------------------+\n    | 6. Presentation Layer   | &lt;- Data formatting, encryption\n    +-------------------------+\n    | 5. Session Layer        | &lt;- Session establishment, maintenance\n    +-------------------------+\n    | 4. Transport Layer      | &lt;- End-to-end connections, reliability\n    +-------------------------+\n    | 3. Network Layer        | &lt;- Routing, IP addressing\n    +-------------------------+\n    | 2. Data Link Layer      | &lt;- Physical addressing, access to media\n    +-------------------------+\n    | 1. Physical Layer       | &lt;- Bit transmission, physical connections\n    +-------------------------+\n</code></pre> <ol> <li>Physical Layer: Transmits raw bit streams (0s and 1s)</li> <li>Data Link Layer: Node-to-node data transfer, error detection, MAC addressing</li> <li>Network Layer: Routing between networks, IP addressing</li> <li>Transport Layer: End-to-end communication, reliability, ports</li> <li>Session Layer: Manages connection sessions between applications</li> <li>Presentation Layer: Data formatting, encryption, compression</li> <li>Application Layer: User-facing network services</li> </ol>"},{"location":"Computer_Network/NW0504/#tcpip-model-4-layers","title":"TCP/IP Model (4 Layers)","text":"<pre><code>    Visual: TCP/IP Model vs OSI Model\n\n    +-------------------------+    +-------------------------+\n    | Application Layer       |    | 7. Application Layer    |\n    |                         |    | 6. Presentation Layer   |\n    |                         |    | 5. Session Layer        |\n    +-------------------------+    +-------------------------+\n    | Transport Layer         |    | 4. Transport Layer      |\n    +-------------------------+    +-------------------------+\n    | Internet Layer          |    | 3. Network Layer        |\n    +-------------------------+    +-------------------------+\n    | Network Access Layer    |    | 2. Data Link Layer      |\n    |                         |    | 1. Physical Layer       |\n    +-------------------------+    +-------------------------+\n          TCP/IP Model                   OSI Model\n</code></pre> <ol> <li>Network Access Layer: Similar to OSI's Data Link Layer</li> <li>Internet Layer: Similar to OSI's Network Layer</li> <li>Transport Layer: Similar to OSI's Transport Layer</li> <li>Application Layer: Combines OSI's Session, Presentation, and Application Layers</li> </ol> <p>Note: The Extended TCP/IP Model divides the Network Access Layer into Physical and Data Link Layers</p>"},{"location":"Computer_Network/NW0504/#23-encapsulation-and-decapsulation","title":"2.3 Encapsulation and Decapsulation","text":""},{"location":"Computer_Network/NW0504/#encapsulation-sending-process","title":"Encapsulation (Sending Process)","text":"<pre><code>    Visual: Encapsulation\n\n    Application Data\n    +--------------------------+\n    |        Data              |  Application Layer\n    +--------------------------+\n             \u2193\n    +---------+-----------------+\n    | App Hdr |      Data       |  Transport Layer\n    +---------+-----------------+\n               \u2193\n    +----------+---------+------+\n    | Net Hdr  | App Hdr | Data |  Network Layer\n    +----------+---------+------+\n                 \u2193\n    +-----+----------+---------+------+-----+\n    | MAC | Net Hdr  | App Hdr | Data | FCS |  Data Link Layer\n    +-----+----------+---------+------+-----+\n                   \u2193\n    01010101010101010101010101010101010101    Physical Layer\n</code></pre> <ul> <li>Data moves from highest layer to lowest layer</li> <li>Each layer adds its header (and sometimes trailer) to the data</li> <li>Upper layer's PDU becomes the payload for the current layer</li> <li>Similar to nesting boxes within boxes</li> </ul>"},{"location":"Computer_Network/NW0504/#decapsulation-receiving-process","title":"Decapsulation (Receiving Process)","text":"<pre><code>    Visual: Decapsulation\n\n    01010101010101010101010101010101010101    Physical Layer\n                   \u2193\n    +-----+----------+---------+------+-----+\n    | MAC | Net Hdr  | App Hdr | Data | FCS |  Data Link Layer\n    +-----+----------+---------+------+-----+\n                 \u2193\n    +----------+---------+------+\n    | Net Hdr  | App Hdr | Data |  Network Layer\n    +----------+---------+------+\n               \u2193\n    +---------+-----------------+\n    | App Hdr |      Data       |  Transport Layer\n    +---------+-----------------+\n             \u2193\n    +--------------------------+\n    |        Data              |  Application Layer\n    +--------------------------+\n</code></pre> <ul> <li>Data moves from lowest layer to highest layer</li> <li>Each layer removes its header/trailer and passes the payload up</li> <li>Process continues until the original data reaches the application</li> </ul>"},{"location":"Computer_Network/NW0504/#24-protocol-data-units-pdus","title":"2.4 Protocol Data Units (PDUs)","text":"<pre><code>    Visual: Protocol Data Units\n\n    OSI Layer            PDU\n    ---------            ---\n    Application  }\n    Presentation } ---&gt; Data\n    Session      }\n\n    Transport    -----&gt; Segment/Datagram\n\n    Network      -----&gt; Packet\n\n    Data Link    -----&gt; Frame\n\n    Physical     -----&gt; Bit\n</code></pre> <p>Each layer handles data in specific units: - Application/Presentation/Session: Data - Transport: Segments (TCP) or Datagrams (UDP) - Network: Packets - Data Link: Frames - Physical: Bits</p>"},{"location":"Computer_Network/NW0504/#25-practical-considerations","title":"2.5 Practical Considerations","text":"<ul> <li>Network reference models are theoretical frameworks</li> <li>Real protocols and devices don't always fit perfectly into specific layers</li> <li>For example, ARP is sometimes called a \"2.5 layer protocol\"</li> <li>Routers primarily operate at the Network layer but interact with other layers</li> <li>For software engineers, understanding protocols and devices is more important than memorizing models</li> <li>OSI and TCP/IP models are valuable for exams and interviews but may be less practical in industry</li> </ul>"},{"location":"Computer_Network/NW1/","title":"Computer Networks","text":"<p>How to Study Computer Networks </p> <p>Make Windows Client and Windows Server?  Goal is to make a Mafia Game Client and Server without pretty GUI. </p> <p><pre><code>wsl --install \n</code></pre> Automatically install ubuntu in default </p>"},{"location":"Computer_Network/TCPIP1/","title":"Network Programming and Comprehension about Socket","text":"<p>1 Open WSL Terminal and create files </p> <p>2 Compile Both Programs </p> <pre><code>gcc -o server hello_server.c\ngcc -o client hello_clinet.c\n</code></pre> <p>3 Run Server </p> <pre><code>./server 1234 \n</code></pre> <p>This starts the server and listens on port <code>1234</code>. Leave this running.</p> <p>4 Open Another Terminal for the Client</p> <pre><code>./clinet 127.0.0.1 1234 \n</code></pre> <p>This connects to the server running on the same machine (localhost, 127.0.0.1).</p> <p>5 If you hit a permissions error (e.g. \"Permission denied\") </p> <p>Make sure the files are executable:</p> <pre><code>chmod +x server client\n</code></pre> <p>6 for server terminal </p> <pre><code>gcc -o server hello_server.c \n./server 1234 \nbind() error\n</code></pre> <pre><code>gcc -o client hello_client.c \n./client 127.0.0.1 1234  \nconnect() error!\n</code></pre> <p>Because port 1234 is currently in usage </p> <p>However if real server is required </p>"},{"location":"Computer_Network/TCPIP1/#linux-clinet-code-hello_clinetc","title":"Linux Clinet Code: <code>hello_clinet.c</code>","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;arpa/inet.h&gt;\n#include &lt;sys/socket.h&gt;\n\nvoid error_handling(char *message);\n\nint main(int argc, char* argv[])\n{\n    int sock;\n    struct sockaddr_in serv_addr;\n    char message[30];\n    int str_len;\n\n    if(argc!=3){\n        printf(\"Usage : %s &lt;IP&gt; &lt;port&gt;\\n\", argv[0]);\n        exit(1);\n    }\n\n    sock=socket(PF_INET, SOCK_STREAM, 0);\n    if(sock == -1)\n        error_handling(\"socket() error\");\n\n    memset(&amp;serv_addr, 0, sizeof(serv_addr));\n    serv_addr.sin_family=AF_INET;\n    serv_addr.sin_addr.s_addr=inet_addr(argv[1]);\n    serv_addr.sin_port=htons(atoi(argv[2]));\n\n    if(connect(sock, (struct sockaddr*)&amp;serv_addr, sizeof(serv_addr))==-1) \n        error_handling(\"connect() error!\");\n\n    str_len=read(sock, message, sizeof(message)-1);\n    if(str_len==-1)\n        error_handling(\"read() error!\");\n\n    printf(\"Message from server: %s \\n\", message);  \n    close(sock);\n    return 0;\n}\n\nvoid error_handling(char *message)\n{\n    fputs(message, stderr);\n    fputc('\\n', stderr);\n    exit(1);\n}\n</code></pre>"},{"location":"Computer_Network/TCPIP1/#linux-server-code-hello_serverc","title":"Linux Server Code: <code>hello_server.c</code>","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;arpa/inet.h&gt;\n#include &lt;sys/socket.h&gt;\n\nvoid error_handling(char *message);\n\nint main(int argc, char *argv[])\n{\n    int serv_sock;\n    int clnt_sock;\n\n    struct sockaddr_in serv_addr;\n    struct sockaddr_in clnt_addr;\n    socklen_t clnt_addr_size;\n\n    char message[]=\"Hello World!\";\n\n    if(argc!=2){\n        printf(\"Usage : %s &lt;port&gt;\\n\", argv[0]);\n        exit(1);\n    }\n\n    serv_sock=socket(PF_INET, SOCK_STREAM, 0);\n    if(serv_sock == -1)\n        error_handling(\"socket() error\");\n\n    memset(&amp;serv_addr, 0, sizeof(serv_addr));\n    serv_addr.sin_family=AF_INET;\n    serv_addr.sin_addr.s_addr=htonl(INADDR_ANY);\n    serv_addr.sin_port=htons(atoi(argv[1]));\n\n    if(bind(serv_sock, (struct sockaddr*) &amp;serv_addr, sizeof(serv_addr))==-1 )\n        error_handling(\"bind() error\"); \n\n    if(listen(serv_sock, 5)==-1)\n        error_handling(\"listen() error\");\n\n    clnt_addr_size=sizeof(clnt_addr);  \n    clnt_sock=accept(serv_sock, (struct sockaddr*)&amp;clnt_addr,&amp;clnt_addr_size);\n    if(clnt_sock==-1)\n        error_handling(\"accept() error\");  \n\n    write(clnt_sock, message, sizeof(message));\n    close(clnt_sock);   \n    close(serv_sock);\n    return 0;\n}\n\nvoid error_handling(char *message)\n{\n    fputs(message, stderr);\n    fputc('\\n', stderr);\n    exit(1);\n}\n</code></pre> <p>Windows client  hello_client_win.c </p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;winsock2.h&gt;\nvoid ErrorHandling(char* message);\n\nint main(int argc, char* argv[])\n{\n    WSADATA wsaData;\n    SOCKET hSocket;\n    SOCKADDR_IN servAddr;\n\n    char message[30];\n    int strLen;\n\n    if(argc!=3)\n    {\n        printf(\"Usage : %s &lt;IP&gt; &lt;port&gt;\\n\", argv[0]);\n        exit(1);\n    }\n\n    if(WSAStartup(MAKEWORD(2, 2), &amp;wsaData) != 0)\n        ErrorHandling(\"WSAStartup() error!\");  \n\n    hSocket=socket(PF_INET, SOCK_STREAM, 0);\n    if(hSocket==INVALID_SOCKET)\n        ErrorHandling(\"socket() error\");\n\n    memset(&amp;servAddr, 0, sizeof(servAddr));\n    servAddr.sin_family=AF_INET;\n    servAddr.sin_addr.s_addr=inet_addr(argv[1]);\n    servAddr.sin_port=htons(atoi(argv[2]));\n\n    if(connect(hSocket, (SOCKADDR*)&amp;servAddr, sizeof(servAddr))==SOCKET_ERROR)\n        ErrorHandling(\"connect() error!\");\n\n    strLen=recv(hSocket, message, sizeof(message)-1, 0);\n    if(strLen==-1)\n        ErrorHandling(\"read() error!\");\n    printf(\"Message from server: %s \\n\", message);  \n\n    closesocket(hSocket);\n    WSACleanup();\n    return 0;\n}\n\nvoid ErrorHandling(char* message)\n{\n    fputs(message, stderr);\n    fputc('\\n', stderr);\n    exit(1);\n}\n</code></pre> <p>Windows Server  hello_server_win.c <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;winsock2.h&gt;\nvoid ErrorHandling(char* message);\n\nint main(int argc, char* argv[])\n{\n    WSADATA wsaData;\n    SOCKET hServSock, hClntSock;        \n    SOCKADDR_IN servAddr, clntAddr;     \n\n    int szClntAddr;\n    char message[]=\"Hello World!\";\n\n    if(argc!=2) \n    {\n        printf(\"Usage : %s &lt;port&gt;\\n\", argv[0]);\n        exit(1);\n    }\n\n    if(WSAStartup(MAKEWORD(2, 2), &amp;wsaData)!=0)\n        ErrorHandling(\"WSAStartup() error!\"); \n\n    hServSock=socket(PF_INET, SOCK_STREAM, 0);\n    if(hServSock==INVALID_SOCKET)\n        ErrorHandling(\"socket() error\");\n\n    memset(&amp;servAddr, 0, sizeof(servAddr));\n    servAddr.sin_family=AF_INET;\n    servAddr.sin_addr.s_addr=htonl(INADDR_ANY);\n    servAddr.sin_port=htons(atoi(argv[1]));\n\n    if(bind(hServSock, (SOCKADDR*) &amp;servAddr, sizeof(servAddr))==SOCKET_ERROR)\n        ErrorHandling(\"bind() error\");  \n\n    if(listen(hServSock, 5)==SOCKET_ERROR)\n        ErrorHandling(\"listen() error\");\n\n    szClntAddr=sizeof(clntAddr);        \n    hClntSock=accept(hServSock, (SOCKADDR*)&amp;clntAddr,&amp;szClntAddr);\n    if(hClntSock==INVALID_SOCKET)\n        ErrorHandling(\"accept() error\");  \n\n    send(hClntSock, message, sizeof(message), 0);\n    closesocket(hClntSock);\n    closesocket(hServSock);\n    WSACleanup();\n    return 0;\n}\n\nvoid ErrorHandling(char* message)\n{\n    fputs(message, stderr);\n    fputc('\\n', stderr);\n    exit(1);\n}\n</code></pre></p> <p>To compile by gcc in windows strongly recommended to install mingw gcc by chocolately  <pre><code>choco install mingw\ngcc --version \n</code></pre> Path will be  C:\\ProgramData\\chocolatey\\lib\\mingw\\tools\\install\\mingw64\\bin</p> <p>Compile by  <pre><code>gcc hello_server_win.c -o server.exe -lws2_32\ngcc hello_client_win.c -o client.exe -lws2_32\nserver.exe 1234\nclient.exe 127.0.0.1 1234\n</code></pre></p>"},{"location":"ECE482FA24/ECE482HW/ECE482H1/","title":"Assignment I","text":"<p>ECE4820 FA2024 Introduction to Operating Systems</p> <p>518370990004 Jae Heung Park</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H1/#exercise-1-review","title":"Exercise 1 Review","text":"<p>Explain the difference between the stack and the heap.</p> <p>Computer can allocate memory in two possible ways: Stack and Heap allocation.</p> Feature Stack Heap Memory Allocation Static, handled automatically Dynamic, handled manually Memory Management Managed by the system Managed by the programmer Data Structure FILO (First In Last Out) Tree Structure Access Speed Relatively Faster Relatively Slower Lifetime Tied to function call (short-lived) Flexible, persists until freed Size Limit Limited, generally 1-8 MB Larger, limited by available memory Error Types Stack Overflow Memory Leakage Example <code>int x = 10;</code> (Local Variable) <code>int* x = malloc(sizeof(int));</code> <p>Since the order of programming in C/C++ is defined, putting all variables in linear order will not cause problem. Thus, in static memory allocation, static variables can be handled by Stack in order of function call. However, dynamic memory allocation means variables can be created or removed directly. So, linear data structure is not available to manage order of variables, so heap data structure is more likely.</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H1/#exercise-2-personal-research","title":"Exercise 2 Personal research","text":""},{"location":"ECE482FA24/ECE482HW/ECE482H1/#21-briefly-explain-what-operations-are-performed-when-a-computer-is-powered-on","title":"2.1 Briefly explain what operations are performed when a computer is powered on.","text":"<p>When the computer is powered on, 4 steps are followed.</p> <ol> <li>POST (Power On Self Test) will test computer hardware before OS is loaded.</li> <li>BIOS (Basic Input/Output System) initialize and control basic hardware components including monitor, keyboard, HDD.</li> <li>Bootloader is located from Motherboard attached storage by BIOS</li> <li>OS kernel is loaded by bootloader so that OS can control bootloader now.</li> </ol> <p>What is the role of the BIOS and how does it interact with the OS?</p> <ol> <li>Initialize hardware components and check their functionality before OS loading.</li> <li>Boot processing will locate and load bootloader from storage.</li> <li>When bootloader launches OS, BIOS still runs on background to support features that might be useful to OS.</li> </ol>"},{"location":"ECE482FA24/ECE482HW/ECE482H1/#22-in-a-few-words-explain-what-are-hybrid-and-exo-kernels","title":"2.2 In a few words explain what are hybrid and exo kernels.","text":"<p>Monolithic Kernel is simple kernel form, so that both user and kernel are in same address. Since user and kernel use same space, process speed is faster, architecture is simple and flexible. However, entire volume of OS and kernel will be in large scale, making OS unstable and insecure. Linux, UNIX are common examples.</p> <p>Microkernel divides user space and kernel space. Thus, it is more secure and stable. Also, it will use relatively less amount of volume. However, since user and kernel will be divided, architecture is complicated and integration of kernel and user have several inconveniences. Also, several functions available on monolithic kernel might be limited. Minix is example.</p> <p>Hybrid Kernel is a combination of two kernel architecture above with smaller kernel volume. It has more various functions than microkernel, but still has less functions than monolithic kernel. Also, architecture design will be even more complicated than monolithic kernel. Microsoft Windows is example.</p> <p>Exo Kernel is currently in research by UC Berkeley rather than utilized in industries. It is developed concept based on monolithic kernel, with better speed and security. However, architecture will be more sophisticated, with potentially inefficient use of computer resources.</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H1/#exercise-3-course-application","title":"Exercise 3 Course Application","text":""},{"location":"ECE482FA24/ECE482HW/ECE482H1/#31-which-of-the-following-instructions-should-only-be-allowed-in-kernel-mode-explain","title":"3.1 Which of the following instructions should only be allowed in kernel mode? Explain.","text":"<ul> <li>a) Disable all interrupts</li> <li>b) Read the time-of-day clock</li> <li>c) Set the time-of-day clock</li> <li>d) Change the memory map</li> </ul> <p>(b) is allowed in both user mode and kernel mode. (a), (c), (d) are allowed only in kernel mode.</p> <p>Disabling all interruption in OS pipeline must be handled by kernel, since it will be entire reset of the process pipeline. User should not have full comprehension and access of the entire OS.</p> <p>Read the time of the day can be done in user level, especially considering the different time zone shared globally by several users. Basic time might be setup into UTC 0, and additional time zone calculation can be done for each user mode.</p> <p>However, set the time of the day must be in kernel level. Time is very closely related to the entire process of the Operating System and its logs. Thus, user level time clock setup should be prohibited.</p> <p>Memory map is also directly related to the operating system. Data structure of stack and heap to store each kind of memory should be handled under entire kernel. Thus, user level memory map access might compromise the running process of entire OS.</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H1/#32-consider-a-system-that-has-two-cpus-and-each-cpu-is-composed-of-two-threads","title":"3.2 Consider a system that has two CPUs and each CPU is composed of two threads.","text":"<p>Suppose three programs, P0, P1, and P2, are started with run times of 5, 10 and 20 ms, respectively. How long will it take to complete the execution of these programs? Assume that all three programs are 100% CPU bound, do not block during execution, and do not change CPUs once assigned.</p> <p>There are 2 CPUs, and 2 threads per 1 CPU, thus 4 threads exist. One thread can handle one process simultaneously, so all three programs P0, P1, and P2 are able to start simultaneously without waiting for thread scarcity.</p> <p>Execution time for each program will be P0 5ms, P1 10ms, P2 25ms. If each thread take each task simultaneously, P2 end time <code>25ms</code> will be complete time. Suppose core can take each task simultaneously. If program execution is optimized, P0 and P2 will be assigned together, so that P1 will start after P0 ends, resulting in same <code>25ms</code>. However, if programs execution list is in FIFO queue order, then it will take <code>30ms</code> since core handling. In worst case, if all projects require 2 cores, then time consumption will be <code>40ms</code>.</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H1/#exercise-4-command-lines-on-a-unix-system","title":"Exercise 4 Command lines on a Unix system","text":"<p>On Linux use the command line to:</p> <ol> <li>Create a new user;</li> <li>List all the currently running processes;</li> <li>Display the characteristics of the CPU and the available memory;</li> <li>Redirect random output read from a system device, into two different files;</li> <li>Concatenate the two previous files;</li> <li>Read the content of the resulting file as hexadecimal values (in other words find a command to    read a file as hexadecimal values);</li> <li>Go at the root of the kernel source you downloaded in l2 and use a single command to find all    the files in with the word mutex in their name and containing the whole word nest_lock;</li> </ol> <p>Note: follow the ?\uc40frogramming exercises??guidelines and save the list of commands in a shell file (.sh).</p> <p>Shell commandlines in <code>e4.sh</code> file.</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H1/#exercise-5-simple-problem","title":"Exercise 5 Simple problem","text":"<p>One reason GUIs were initially slow to be adopted was the cost of the hardware needed to support them. How much video RAM is needed to support a 25 lines by 80 rows character monochrome text screen? How much for a 1024 x 768 pixel 24-bit color bitmap? Assuming the cost of this RAM in the 1980es was $5/KB what was the price of those two solutions? How much is it now?</p> <p>Monochrome text character is ASCII, 2^8=256 bits, 1 byte per each character. The calculation will be 25 X 80 = 2000 Bytes = 2 KB</p> <p>One pixel is composed of 3 RGB values, each value from 0 to 255. It is 1 byte per each color, so 3 bytes per each pixel. Total memory required per each screen will be 3 X 1024 X 768 = 2359296 Bytes / 1024 = 2304 KB / 1024 = 2.25 MB</p> <p>In 1980, dealing 1024 X 768 RGB pixels represented 2304 KB X 5 $ = 11520 USD. Ignoring inflation for 40 years, this is enough to buy the 275 latest SK Hynix DDR5 16GB RAM, currently 42 USD per each in Amazon, for 2024 October.</p> <p>However, currently abandoned computers in school with 2GB RAM will be far more than enough to handle 3MB memory.</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H2/","title":"Assignment II","text":"<p>ECE4820 FA2024 Introduction to Operating Systems</p> <p>518370990004 Jae Heung Park</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H2/#exercise-1","title":"Exercise 1","text":"<p>A few years ago when computers featured less RAM it is was common to increase it in order to enhance CPU performance. In order to better understand the link between the two we now create a simple model for multiprogramming. We assume all the processes to be similar and spending the same fraction p of their time waiting for Input/Output (I/O) to complete.</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H2/#1-what-is-the-probability-for-n-processes-to-be-waiting-at-the-same-time-then-express-the-cpu-utilisation-as-a-function-of-n","title":"1. What is the probability for n processes to be waiting at the same time, then express the CPU utilisation as a function of n?","text":"<p>Probability \\(p^n\\)</p> <p>CPU Utilization \\(U(n)=1-p^n\\) where \\(n\\) is number of process.</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H2/#2-sketch-the-curve-representing-the-cpu-utilisation-as-a-function-of-the-number-of-processes-for-the-following-values-of-p-25-60-and-90","title":"2. Sketch the curve representing the CPU utilisation as a function of the number of processes for the following values of p: 25%, 60% and 90%.","text":"<p>Suppose CPU Utilization \\(U\\) function for \\(n\\) number of process \\(U(n)\\).</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H2/#3-a-certain-old-computer-has-256-mb-of-ram-once-loaded-a-light-operating-system-uses-96-mb-of-ram","title":"3. A certain old computer has 256 MB of RAM, once loaded a light operating system uses 96 MB of RAM.","text":"<p>Several programs are launched each of them using 48 MB.</p> <p>a) How many processes can be store simultaneously in memory?</p> <p>Given 256 MB RAM, OS uses 96 MB, 160 MB left and each process takes 48 MB. Suppose 4 processors share 160 MB, then it is 40 MB per each, which is less than 48 MB required for process to run. If 3 processors share 160MB, then its capacity is 53.3 per each, enough to handle each process. Thus, <code>3</code> processes can be store simultaneously in memory.</p> <p>b) Assuming an average of 90% I/O waiting time what is the CPU utilisation?</p> <p>Since \\(p=0.9\\) and \\(n=3\\), \\(U(n)=1-p^n=1-(0.9)^{3}=1-0.729=0.271\\) Thus, CPU utilization <code>U=27.1%</code></p> <p>c) What is the effect of adding 256 MB, 512 MB and 1024 MB of RAM. Argue on which amount would be the most beneficial and would be worth the investment.</p> <p>\\(256 + 256 \\rightarrow (512 - 96) / 48 = 416 / 48 = 8.67 \\rightarrow U(8)=1??.90^{8}=1??.430=0.570\\)</p> <p>\\(256 + 512 \\rightarrow (768 - 96) / 48 = 672 / 48 = 14 \\rightarrow U(8)=1??.90^{14}=1??.206=0.794\\)</p> <p>\\(256 + 1024 \\rightarrow (1280 - 96) / 48 = 1184 / 48 = 24.67 \\rightarrow U(8)=1??.90^{24}=1??.121=0.879\\)</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H2/#ex-2-understanding-system-calls","title":"Ex. 2 ??Understanding system calls","text":""},{"location":"ECE482FA24/ECE482HW/ECE482H2/#1-briefly-introduce-strace-and-ltrace-explain-they-could-be-helpful-along-the-semester","title":"1. Briefly introduce strace and ltrace. Explain they could be helpful along the semester.","text":"<p>Both <code>strace</code> and <code>ltrace</code> are trace debugging tools.</p> <p><code>strace</code> traces based on system calls by following interaction between Linux kernel and program.</p> <p><code>ltrace</code> traces library calls instead of system call. This shows logs of library dependent function calls.</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H2/#2-what-are-the-manpages-sections-for-system-calls-and-library-calls","title":"2. What are the manpages sections for system calls and library calls?","text":"<p>In convention, system calls are in section 2 and library calls are in section 3.</p> <p>Use command like <code>man 2 &lt;system_call_name&gt;</code> for system calls and <code>man 3 &lt;library_function_name&gt;</code> for library functions.</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H2/#3-system-calls","title":"3. System calls.","text":"<p>a) What are the main types of system calls?</p> <ol> <li>Process management: creation, termination, control <code>exit(0)</code>, <code>fork()</code>, <code>exec()</code></li> <li>File management: open close read write <code>open()</code>, <code>close()</code>, <code>read()</code>, <code>write()</code></li> <li>Device management: IO operation, peripheral interaction <code>ioctl()</code></li> <li>Information maintenance: system level info setup and retrieval <code>getpid()</code>, <code>getuid()</code>, <code>setuid()</code></li> <li>Inter Process Communication IPC: send message <code>pipe()</code>, <code>msgsnd()</code></li> </ol> <p>b) Run strace on the ls command and classify all the listed system calls.</p> <pre><code>strace ls\n</code></pre> <p>output file on <code>strace_ls.txt</code></p> <ul> <li>Process protocol <code>execve(\"/usr/bin/ls\", [\"ls\"], 0xfffff3920cf0 /* 53 vars */) = 0</code></li> <li>Memory management <code>brk, mmap, munmap</code></li> <li>File management <code>openat(AT_FDCWD, \"...\"), read(...), close(...)</code></li> <li>Device management <code>ioctl(...)</code></li> <li>Information maintenance <code>statfs(...), getrandom(...)</code></li> <li>Communication <code>prlimit64(...)</code></li> <li>Exit <code>exit_group(0)</code></li> </ul> <p>c) Select a line of your choice in strace output and explain its meaning.</p> <pre><code>openat(AT_FDCWD, \".\", O_RDONLY|O_NONBLOCK|O_CLOEXEC|O_DIRECTORY) = 3\n</code></pre> <ul> <li><code>openat()</code>: Open file relative to a directory file descriptor.</li> <li><code>AT_FDCWD</code> means directory is current working directory.</li> <li><code>/lib/aarch64-linux-gnu/libselinux.so.1</code> File opened in SELinux shared library.</li> <li><code>O_RDONLY|O_CLOEXEC</code>: File is opened in read-only mode <code>O_RDONLY</code>, and <code>O_CLOEXEC</code> means file descriptor will be automatically closed if process performs <code>exec()</code> system call.</li> <li><code>3</code>: This is the file descriptor returned by the system call.</li> </ul> <p>d) How to attach strace to a running process? Describe a scenario where this could be handy</p> <pre><code>strace -p &lt;pid&gt;\n</code></pre> <p><code>&lt;pid&gt;</code> should be ID of running process.</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H2/#ex-3-a-simple-system-call","title":"Ex. 3 ??A simple system call","text":""},{"location":"ECE482FA24/ECE482HW/ECE482H2/#1-kernel-printing","title":"1. Kernel printing.","text":"<p>a) What is the counterpart of printf() when working inside the Linux kernel?</p> <p>The <code>printk</code> is the counterpart of <code>printf</code> inside Linux kernel log. It is visible in <code>dmesg</code>.</p> <p>b) Write the body a simple ?\uc40aernel function??displaying ?\uc3eeum is proud of you!??</p> <pre><code>void mum_is_proud(void) {\n    printk(KERN_INFO \"Mum is proud of you!\\n\");\n}\n</code></pre> <p><code>KERN_INFO</code> is one level of log, meaning it is not information.</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H2/#2-headers-and-function-name","title":"2. Headers and function name.","text":"<p>a) What header files should be included when adding a new system call?</p> <pre><code>#include &lt;linux/kernel.h&gt;    // kernel-related functions including printk().\n#include &lt;linux/syscalls.h&gt;  // system call macros like SYSCALL_DEFINE.\n</code></pre> <p>b) How are the macros <code>SYSCALL_DEFINE0</code> and <code>SYSCALL_DEFINEx</code> working?</p> <p><code>SYSCALL_DEFINE0(name)</code> defines system call with zero arguments. It internally uses the <code>asmlinkage</code> keyword, ensuring function called follows convention for system calls.</p> <p><code>SYSCALL_DEFINEx</code> defines system call with x number of arguments where xrange from 0 to 6.</p> <p>c) Use the SYSCALL_DEFINE0 to define the new system call encouragement. Name your file encouragement.c and save it in a folder encouragement at the root of the kernel source code</p> <pre><code>#include &lt;linux/kernel.h&gt;\n#include &lt;linux/syscalls.h&gt;\n\nSYSCALL_DEFINE0(encouragement) {\n    printk(KERN_INFO \"Mum is proud of you!\\n\");\n    return 0;\n}\n</code></pre> <p>Save at root of the kernel source code.</p> <pre><code>cd ~/sched_ext-for-6.11/\nmkdir encouragement\ncd encouragement\necho '#include &lt;linux/kernel.h&gt;\n#include &lt;linux/syscalls.h&gt;\n\nSYSCALL_DEFINE0(encouragement) {\n    printk(KERN_INFO \"Mum is proud of you!\\n\");\n    return 0;\n}' &gt; encouragement.c\n</code></pre>"},{"location":"ECE482FA24/ECE482HW/ECE482H2/#3-makefile-and-kbuild","title":"3. Makefile and Kbuild.","text":"<p>a) Jump to the end of Kbuild file and following the same patterns as on the last few lines, add your encouragement directory there.</p> <pre><code>nano Kbuild\n</code></pre> <pre><code>obj-$(CONFIG_SAMPLES)   += samples/\nobj-$(CONFIG_NET)       += net/\nobj-y                   += virt/\nobj-y                   += $(ARCH_DRIVERS)\nobj-y                   += encouragement/\n</code></pre> <p>b) Check the Makefiles for the directories listed at the end of Kbuild file and create a Makefile for your encouragement directory.</p> <pre><code>touch Makefile\n</code></pre> <pre><code># Makefile of J H Park\n\nobj-y := encouragement.o\n</code></pre>"},{"location":"ECE482FA24/ECE482HW/ECE482H2/#4-system-call-registration","title":"4. System call registration.","text":"<p>a) Add your new system call to <code>syscalls.h</code>.</p> <p>Hint: there are more than one such file, make sure to edit the correct one!</p> <p>Correct position at <code>/include/linux/syscalls.h</code> in my M3 Mac will be ARM64. However, <code>cat arch/aarch64/include/asm/syscalls.h</code> does not exist. Only <code>cat arch/arm/include/asm/syscall.h</code> exist.</p> <pre><code>uname -m\naarch64\ncat arch/arm64/include/asm/syscall\nsyscall.h          syscall_wrapper.h\ncat arch/arm/include/asm/syscalls.h\n</code></pre> <p>Instead of editing <code>arch/arm64/include/asm/syscall.h</code></p> <p>I edited <code>arch/arm64/include/asm/syscall.h</code></p> <pre><code> # nano arch/arm64/include/asm/syscall.h\nnano include/linux/syscalls.h\n\nasmlinkage long sys_encouragement(void);\n</code></pre> <p>b) Add your new system call to <code>syscall_64.tbl</code>. Hint: what architecture is your Linux running on?</p> <p>M3 Mac should set system call value in different position.</p> <pre><code>nano arch/arm64/kernel/syscall.c\n\n#include &lt;linux/kernel.h&gt; // Included\n#include &lt;linux/syscalls.h&gt; // Included\n\nSYSCALL_DEFINE0(encouragement) {\n    printk(KERN_INFO \"Mum is proud of you!\\n\");\n    return 0;\n}\n</code></pre>"},{"location":"ECE482FA24/ECE482HW/ECE482H2/#5-recompile-the-kernel-and-reboot-do-not-forget-to-update-the-bootloader","title":"5. Recompile the kernel and reboot (do not forget to update the bootloader).","text":"<p>Recompile</p> <pre><code>make -j$(nproc)\n</code></pre> <p>If modules are not installed install</p> <pre><code>make modules_install\nmake install\nreboot\n</code></pre>"},{"location":"ECE482FA24/ECE482HW/ECE482H2/#6-write-a-simple-user-space-program-to-demonstrate-the-well-functioning-of-your-system-call","title":"6. Write a simple user space program to demonstrate the well functioning of your system call.","text":"<p>This is program.</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/syscall.h&gt;\n\nint main() {\n    long result = syscall(438);\n    printf(\"Syscall returned: %ld\\n\", result);\n    return 0;\n}\n</code></pre> <p>If kernel reaches storage issue</p> <pre><code>df -h\nmake clean\nmake mrproper\ndf -h\n</code></pre>"},{"location":"ECE482FA24/ECE482HW/ECE482H3/","title":"Assignment III","text":"<p>ECE4820 FA2024 Introduction to Operating Systems</p> <p>518370990004 Jae Heung Park</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H3/#exercise-1-general-questions","title":"Exercise 1 - General questions","text":""},{"location":"ECE482FA24/ECE482HW/ECE482H3/#exercise-11-if-a-multithreaded-process-forks-a-problem-occurs-if-the-child-gets-copies-of-all-the-parents-threads","title":"Exercise 1.1 If a multithreaded process forks, a problem occurs if the child gets copies of all the parent's threads.","text":"<p>Suppose that one of the original threads was waiting for keyboard input. Now two threads are waiting for keyboard input, one in each process. Does this problem ever occur in single-threaded processes?</p> <p>NO. In single thread, <code>fork()</code> call of process id will receive child process as copy of single thread. Only one process can wait for input. Thus, it is not likely for single thread CPU to have this kind of duplicated input acquisition.</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H3/#exercise-12-many-unix-system-calls-have-no-win32-api-equivalents","title":"Exercise 1.2 Many UNIX system calls have no Win32 API equivalents.","text":"<p>For each such call, what are the consequences when porting a program from a UNIX system to a Windows system?</p> <p>Some OS concepts in UNIX exist in WIN32 too, but their commands are different, such as process generation command <code>fork()</code> is either in Windows threads or <code>CreateProcess()</code> function. So, UNIX command is mostly incompatible. Thus, consequences when porting a program from a UNIX system to a Windows system will be unlikely to work due to incompatible calls.</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H3/#exercise-2-c-programming-the-code-of-this-exercise-will-be-reused-in-future-labs","title":"Exercise 2 - C programming - The code of this exercise will be reused in future labs","text":"<p>The goal of this exercise is to improve the programming skills and get more familiar with pointers and function pointers.</p> <ol> <li>Implement a linked list structure containing two pointers of type char and void. It should be    possible to at least add elements to the list.</li> <li>Knowing that the void pointer in the structure could contain some char*, int, or double, write a    search function for this linked list.</li> <li>The linked list will store elements read from an ASCII file where each line is in the format    <code>somestring=somedata</code>. The type of the data is defined in the filename; for instance a file    containing unsorted integers will be named rand_int.txt. Implement the necessary functions to    read and write such files.</li> <li>Use a function pointers to compare and sort the elements from the structure with respect to the    data field. Implement the following sorting orders: increasing, decreasing, and random. The    filename is <code>sortingtype_dataype.txt</code>, where <code>sortingtype</code> is rand, inc, or dec.s</li> <li>Write a function to test the implementation.</li> </ol> <p>Sample output, test on JOJ using <code>git commit -m \"joj.h3</code></p> <pre><code>git add .\ngit commit --allow-empty -m \"test(h3): joj\"\ngit push\nclang-18 -std=gnu17 -O2 -Wall -Wextra -Werror -pedantic -Wno-unused-result -Wconversion -Wvla main.c -o h3\n./h3 rand_int.txt inc\n</code></pre> <p>File name structure <code>[Sort Type]_[Data Type].txt</code></p>"},{"location":"ECE482FA24/ECE482HW/ECE482H3/#ex-3-research-on-posix","title":"Ex. 3 - Research on POSIX","text":"<p>Write a few paragraphs about the POSIX standards. What are they, why do they exist, what kind of things are included in the norms.</p> <p>POSIX (Portable Operating System Interface) is IEEE standard designed for OS compatibility. It defines API and Interface of OS to be conventional primarily targeting UNIX based systems. Not only Linux and MacOS but also even Microsoft Windows can offer some POSIX compatibility based on Windows Subsystem for Linux (WSL).</p> <p>During the warring states of OS, a lot of OS emerged and competed against each other. Almost all of them had different form of commands, functions, system calls, and utilities without any compatibility. This made programmers to make different codes of system call for each OS, making it extremely inefficient. POSIX standard application in OS industry promised way much portable software for all software programs in different OS.</p> <p>POSIX standard has several key concepts.</p> <ol> <li>System Calls for process creation<code>fork()</code>, execution<code>exec()</code>, and termination <code>exit()</code>, <code>kill()</code>.</li> <li>File IO (input output) stream operations <code>read()</code>, <code>write()</code>, permissions, directory functions <code>opendir()</code>, <code>readdir()</code>.</li> <li>Multi Threading APIs like POSIX Threads or Pthreads</li> <li>IPC (Inter Process Communication) and Process Management lik <code>pipe()</code></li> <li>Network Standards including socket based communication</li> <li>Command Line Interface basic functions like <code>ls</code>, <code>cd</code>, <code>grep</code>, <code>awk</code>, <code>sed</code>, etc...</li> <li>Shell Script standards</li> </ol> <p>POSIX allow compatible software for different OS, so code portability is way much better, and programmers don't need to make software for each different Operating Systems.</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H4/","title":"Assignment IV","text":"<p>ECE4820 FA2024 Introduction to Operating Systems</p> <p>518370990004 Jae Heung Park</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H4/#exercise-1-simple-questions","title":"Exercise 1 Simple questions","text":""},{"location":"ECE482FA24/ECE482HW/ECE482H4/#1","title":"1.","text":"<p>Consider a system in which threads are implemented entirely in user space, with the run-time system getting a clock interrupt once a second. Suppose that a clock interrupt occurs while some thread is executing in the run-time system. What problem might occur? Can you suggest a way to solve it?</p> <p>Thread control data corruption is likely if system runtime is during thread update including thread status, program counter, or stack pointer. Clock interruption might compromise thread data structure. Also, interruption handling malfunction might also happen. Implementation of interrupt masking in runtime system can solve this issue, since it will basically prohibit interruption temporarily during thread process that would compromise system is not finished. Once these operations are complete, the interrupts can be enabled again. This approach will ensure no interruption during thread processes that might damage if stopped without finish.</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H4/#2","title":"2.","text":"<p>Suppose that an operating system does not have anything like the select system call (man select for more details on the command) to see in advance if it is safe to read from a file, pipe, or device, but it does allow alarm clocks to be set that interrupt blocked system calls. Is it possible to implement a threads package in user space under these conditions? Discuss.</p> <p>It is possible to implement a threads package in user space under conditions without any commands similar to <code>select</code> system call. It is important to remember that blocked threads are not blocking entire process. Kernel manages all processes, but they are not controlling each thread. It will be impossible to check whether file or pipe are ready to be used during Input / Output, without <code>select()</code> function. However, <code>alarm clock</code> can be used to get worktime in the following order.</p> <ol> <li>Thread request to read from file or pipe</li> <li>Runtime system call <code>read()</code></li> <li>If call blocks, alarm clock like <code>alarm()</code> or <code>settimer()</code> interrupt blocked system call</li> <li>Receive alarm interrupt, runtime system save blocked thread status</li> <li>Blocked thread switch to another thread</li> <li>Original thread retry IO operation</li> </ol> <p>Even though this clock using approach wastes resource for counting times for each process I/O, this method will successfully prevent process blocking during I/O by thread switch.</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H4/#exercise-2-race-condition-in-bash","title":"Exercise 2 Race condition in Bash","text":"<p>Write a Bash script which generates a file composed of one integer per line. The script should read the last number in the file, add one to it, and append the result to the file.</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H4/#1-run-the-script-in-both-background-and-foreground-at-the-same-time-how-long-does-it-take-before-observing-a-race-condition","title":"1. Run the script in both background and foreground at the same time. How long does it take before observing a race condition?","text":"<p>Code implemented at <code>h4/ex2.sh</code>. Foreground on front line and background on back line.</p> <pre><code># If file does not exist create starting with 0\nif [ ! -f counter.txt ]; then\n    echo 0 &gt; counter.txt\nfi\n\n# Read the last number from the file\nlast_num=$(tail -n 1 counter.txt)\n\n# Create new number incremented one from last number\nnew_num=$((last_num + 1))\n\n# Append new number to result\necho $new_num &gt;&gt; counter.txt\n</code></pre> <p>Foreground Terminal</p> <pre><code>chmod +x ex2.sh\n./ex2.sh\n</code></pre> <p>Background Terminal</p> <pre><code>while true; do ./ex2.sh &amp; sleep 0.1; done\n</code></pre> <p>The background terminal will iterate to execute <code>ex2.sh</code> forever until it is interrupted.</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H4/#2-modify-the-script-such-as-to-prevent-the-race-condition","title":"2. Modify the script such as to prevent the race condition.","text":"<p>Code implementation to lock infinite loop is required.</p> <pre><code># Flock usage, only one process write to file at same time\nexec 200&gt;counter.txt.lock      # Create or open lock file\nflock -n 200 || exit 1         # Get lock, exit if locked\n</code></pre> <p>Added the following lines of code to implement lock.</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H4/#exercise-3-programming-with-semaphores","title":"Exercise 3 Programming with semaphores","text":"<p>The following C code creates two threads which increment a common global variable. When run it generates a random and inaccurate output. In order to solve this problem we want to use semaphores.</p> <ol> <li>On Linux, find the file semaphore.h.</li> <li>Read the documentation to understand how to use the functions described in the file <code>semaphore.h</code>.</li> <li>Using semaphores adjust the program such as to always return the correct answer.</li> </ol> <pre><code>find /usr/include -name semaphore.h\n/usr/include/semaphore.h\ncat /usr/include/semaphore.h\n</code></pre> <p>Semaphore file attached as <code>semaphore.h</code> in folder.</p> <p>The GNU C Library (glibc) manual Semaphore</p> <p>Linux shell manual check by following command</p> <pre><code>man sem_init\nman sem_wait\n</code></pre> <p>Semaphore code to always return the correct answer is in <code>semaphore.c</code> file.</p> <pre><code>clang-18 -std=gnu17 -O2 -Wall -Wextra -Werror -pedantic -Wno-unused-result -Wconversion -Wvla code.c -o code\n</code></pre>"},{"location":"ECE482FA24/ECE482HW/ECE482H5/","title":"Assignment V","text":"<p>ECE4820 FA2024 Introduction to Operating Systems</p> <p>518370990004 Jae Heung Park</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H5/#ex-1-simple-questions","title":"Ex. 1 ??Simple questions","text":"<p>1. A system has two processes and three identical resources. Each process needs a maximum of two resources. Can a deadlock occur? Explain.</p> <p>Deadlock can occur in the following circumstances.</p> <ol> <li>Mutual Exclusion</li> <li>Hold and Wait</li> <li>No Preemption</li> <li>Circular Wait</li> </ol> <p>System has two processes and one process can handle maximum 2 resources, meaning that the entire system can handle maximum 4 resources. Each process require maximum 2 resources. However, only 3 resources exist in current circumstance. Thus, since process capability of system is not full, deadlock is NOT going to occur.</p> <p>2. A computer has six tape drives, with n processes competing for them. Each process may need two drives. For which values of n is the system deadlock free?</p> <p>Similar to the answer made at previous problem, System might potentially have deadlock at least \\(n \\geq 6\\). Thus, if \\(n \\in {1,2,3,4,5}\\), then deadlock is not likely to happen.</p> <p>3. A real-time system has four periodic events with periods of 50, 100, 200, and 250 msec each. Suppose the four events require 35, 20, 10, and x msec of CPU time, respectively. What is the largest value x for which the system is schedulable?</p> <p>\\(\\frac{35}{50} + \\frac{20}{100} + \\frac{10}{200} + \\frac{x}{250} &lt; 1\\)</p> <p>\\(0.95 + \\frac{x}{250} &lt; 1 \\implies \\frac{x}{250} &lt; 0.05 \\implies x &lt; 12.5\\)</p> <p>Thus, 12.5 will be maximum.</p> <p>4. Round-robin schedulers normally maintain a list of all runnable processes, with each process occurring exactly once in the list. What would happen if a process occurred more than once in the list? Would there be any reason for allowing this?</p> <p>If same process occurred more than once, then CPU Time will be allocated more to that process.</p> <p>5. Can a measure of whether a process is likely to be CPU bound or I/O bound be detected by analyzing the source code. How to determine it at runtime?</p> <p>CPU bound process is heavily composed of computation.</p> <p>Input Output bound is literally handling reading input and writing output of files.</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H5/#exercise-2-deadlocks","title":"Exercise 2 ??Deadlocks","text":"<p>Assuming three resources consider the following snapshot of a system.</p> Process Allocated Maximum Available P1 010 753 332 P2 200 322 P3 302 902 P4 211 222 P5 002 433 <p>1. Determine the content of the Request matrix.</p> <p>$ \\begin{bmatrix} 7 &amp; 4 &amp; 3 \\ 1 &amp; 2 &amp; 2 \\ 6 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 1 \\ 4 &amp; 3 &amp; 1 \\ \\end{bmatrix} $</p> <p>2. Is the system in a safe state?</p> <p>Banker's algorithm should be used to check system status safety. Available resources are \\([3,3,2]\\).</p> <p>\\(P4=(0,1,1) \\rightarrow (3 + 2, 3 + 1, 2 + 1) = (5, 4, 3)\\)</p> <p>\\(P2=(1,2,2) \\rightarrow (5 + 2, 4 + 0, 3 + 0) = (7, 4, 3)\\)</p> <p>\\(P1=(7,4,3) \\rightarrow  (7 + 0, 4 + 1, 3 + 0) = (7, 5, 3)\\)</p> <p>\\(P3=(6,0,0) \\rightarrow (7 + 3, 5 + 0, 3 + 2) = (10, 5, 5)\\)</p> <p>\\(P5=(10, 5, 5) \\rightarrow (10 + 0, 5 + 0, 5 + 2) = (10, 5, 5)\\)</p> <p>3. Can all the processes be completed without the system being in an unsafe state at any stage?</p> <p>Yes. Sequence will be \\(P4 \\rightarrow P2 \\rightarrow P1 \\rightarrow P3 \\rightarrow P5\\) with no safety vulnerable part.</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H5/#ex-3-the-reader-writer-problem","title":"Ex. 3 ??The reader-writer problem","text":"<p>In the reader-writer problem, some data could be accessed for reading but also sometimes for writing. When processes want to read the data they get a read lock and a write lock for writing. Multiple processes could get a read lock at the same time while a write lock should prevent anybody else from reading or writing the data until the write lock is released.</p> <p>To solve the problem we decide to use a global variable count together with two semaphores: count_lock for locking the count variable, and db_lock for locking the database. To get a write lock we can proceed as follows:</p> <pre><code>void write_lock() {\n    down(db_lock);\n}\n\nvoid write_unlock() {\n    up(db_lock);\n}\n</code></pre> <p>1. Explain how to get a read lock, and write the corresponding pseudocode.</p> <p>Counter for counting active readers number is required. When reader start, increase count. For first reader, lock database. If reader ends, decrease count. If it is last reader, release db lock. This is following pseudocode.</p> <pre><code>void read_lock(){\n    down(count_lock);\n    if(count == 0) down(db_lock); // First reader lock databas e\n    count++;\n    up(count_lock);\n}\n\nvoid read_unlock(){\n    down(count_lock);\n    count--;\n    if(count==0) up(db_lock); // Last reader unlocks the database\n    up(count_lock);\n}\n</code></pre> <p>2. Describe what is happening if many readers request a lock.</p> <p>When several lock request is made by several readers, then each reader could increase count and only first reader will lock database. Every following readers could skip database lock. Block any new reader when a writer becomes available.</p> <p>3. Explain how to implement this idea using another semaphore called read_lock.</p> <p>Prevent writer to unclearly handle reader influx by using semaphore <code>read lock</code>. This blocks new readers and allow readers to operate properly.</p> <pre><code>void read_lock() {\n    down(read_lock); // New reader prevention\n    down(count_lock);\n    if(count == 0) down(db_lock);\n    count++;\n    up(count_lock);\n    up(read_lock);\n}\n\nvoid read_unlock() {\n    down(count_lock);\n    count--;\n    if(count==0) up(db_lock);\n    up(count_lock);\n}\n</code></pre> <p>4. Is this solution giving any unfair priority to the writer or the reader? Can the problem be considered as solved?</p> <p>Since this solution prohibits new readers to start, it will primarily process writer if resource gets available. It will prevent writer starving, but it causes reader starving instead. Thus, balancing resources for both read and write will be more applicable. Queue or algorithm implementation will be required to give 'fair' priority for both writer and reader.</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H6/","title":"Assignment VI","text":"<p>ECE4820 FA2024 Introduction to Operating Systems</p> <p>518370990004 Jae Heung Park</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H6/#exercise-1","title":"Exercise 1","text":""},{"location":"ECE482FA24/ECE482HW/ECE482H6/#11","title":"1.1","text":"<p>Consider a swapping system in which memory consists of the following hole sizes in memory order: 10 KB, 4 KB, 20 KB, 18 KB, 7 KB, 9 KB, 12 KB, and 15 KB. Assuming first fit is used, which hole is taken for successive segment requests of: (i) 12 KB, (ii) 10 KB and (iii) 9KB. Repeat for best fit and quick fit.</p> <p>Available hole sizes: 10 4 20 18 7 9 12 15</p> <p>First Fit</p> <p>(i) 12KB TO 20KB (ii) 10KB TO 18KB (iii) 9KB TO 15KB</p> <p>Best Fit</p> <p>(i) 12KB TO 12KB (ii) 10KB TO 10KB (iii) 9KB TO 9KB</p> <p>Quick Fit</p> <p>(i) 12KB TO 12KB (ii) 10KB TO 10KB (iii) 9KB TO 9KB</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H6/#12","title":"1.2","text":"<p>If an instruction takes 10 nsec and a page fault takes an additional n nsec, give a formula for the effective instruction time if page faults occur every k instructions.</p> <p>Formula for Effective Instruction Time</p> <p>instruction time \\(t=10\\) nanoseconds Page fault additional \\(n\\) nanoseconds Page fault occur every \\(k\\) instructions</p> <p>Effective Time \\(= t + \\frac{n}{k}\\)</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H6/#13","title":"1.3","text":"<p>A small computer has four page frames. At the first clock tick, the R bits are 0111. At t subsequent clock tics, the values are 1011, 1010, 1101, 0010, 1010, 1100 and 0001. Assuming the aging algorithm is used with an 8-bit counter what is the value of the four counters after the last tick.</p> Page Counter Value Page 0 <code>01101110</code> Page 1 <code>01001001</code> Page 2 <code>00110111</code> Page 3 <code>10001011</code>"},{"location":"ECE482FA24/ECE482HW/ECE482H6/#exercise-2-page-tables","title":"Exercise 2 Page tables","text":"<p>In the lecture it was mentioned that the translation from virtual address into physical address could be sped up using the TLB. Unfortunately this solution is not of much help in the case of large page tables. Investigate the two following alternative solutions: inverted page tables and multilevel page tables.</p> Feature Inverted Page Tables Multilevel Page Tables Description Single table for physical frames Hierarchical table structure Table Size Based on physical memory size Based on used virtual pages Benefits Saves memory for large virtual spaces Efficient for sparse address spaces Limitations Slower lookups due to table search Requires multiple memory accesses Implementation Uses a hash function or search mechanism Adds memory for hierarchical levels"},{"location":"ECE482FA24/ECE482HW/ECE482H6/#ex-3-research","title":"Ex. 3 ??Research","text":"<p>Write about half a page on the topic of codes bugs that lead to security holes; In particular illustrate the discussion using common examples. Do not forget to reference your sources of information.</p> <p>Generally subtle bugs inside code files are vulnerable against hacker attack. It can allow external attack to compromise computer system. Flaw logic and insufficient input validation are two core reasons that might potentially cause vulnerabilities.</p> <p>SQL user input query sanitization failure made SQL query execution that are not actually input. This attack is named as <code>SQL injection</code>. Wikipedia: SQL injection</p> <p>Multi Threading environment has <code>race condition</code> if process result in unexpected behavior. Dirty Cow is one good example using write access to read only files. Red Hat: Dirty COW Race Condition. Dirty COW Vulnerability</p> <p>When program access beyond allocated memory, then adjacent memory not allocated will be overwritten. This part can have attack code, named as <code>Buffer overflow</code>. Wikipedia: Morris Worm</p> <p>When validation of user input in file path is not correct, attacker can access inside system, navigating directories. Even access to the <code>etc/passwd</code> might be possible. This is <code>Directory Traversal</code>. Fortinet Security Advisory</p> <p>Attackers use bug in <code>Privilege Escalation</code> aiming higher access privilege than programming system. For instance, Microsoft OpenSSL was attacked by Heartbleed bug. OpenSSL Heartbleed Bug</p> <p>When validation failure or user input encoding error occurs, <code>XSS (Cross Side Scripting)</code> became vulnerable against attacks. Then, other user's web browser can be injected with attack codes that might save tokens and cookies required for login. Wikipedia: Samy (computer worm)</p> <p>When memory is accessed after free, <code>UAF (Use After Free)</code> bug appears. Internet Explorer had this, so had a lot of security issues. CVE Details. Database of Software Vulnerabilities.</p> <p>Applications that have deserialized data is good way for attackers, <code>Deserialization Vulnerabilities</code> inside code. Apache Struts had similar issue, leaking 147 million individual information! Apache Strtus</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H6/#ex-4-linux","title":"Ex. 4 ??Linux","text":"<p>Write a very short C program that leads to thrashing.</p> <p>Code in <code>main.c</code></p>"},{"location":"ECE482FA24/ECE482HW/ECE482H7/","title":"Assignment VII","text":"<p>ECE4820 FA2024 Introduction to Operating Systems</p> <p>518370990004 Jae Heung Park</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H7/#ex-1-page-replacement-algorithm","title":"Ex. 1 ??Page replacement algorithm","text":"<p>In this exercise we consider the WSClock page replacement algorithm with a ? value of two ticks. The system state is given as follows.</p> Page Time Stamp Present Referenced Modified 0 6 1 0 1 1 9 1 1 0 2 9 1 1 1 3 7 1 0 0 4 4 0 0 0"},{"location":"ECE482FA24/ECE482HW/ECE482H7/#ex-11-explain-the-content-of-the-new-table-entries-if-a-clock-interrupt-occurs-at-tick-10","title":"Ex. 1.1. Explain the content of the new table entries if a clock interrupt occurs at tick 10.","text":"<p>Page 0, <code>Time Stamp</code> \\(= 6 \\leq 8\\), old, <code>Referenced</code> \\(=0\\), Replacement candidate, <code>Modified</code> \\(=1\\), Should be written in disk.</p> <p>Page 1, <code>Time Stamp</code> \\(= 9 \\geq 8\\), Not old, No change</p> <p>Page 2, <code>Time Stamp</code> \\(= 9 \\geq 8\\), Not old, No change</p> <p>Page 3, <code>Time Stamp</code> \\(= 7 \\leq 8\\), old, Replacement candidate, with no need to write back to disk</p> <p>Page 4, <code>Present</code>\\(=0\\), so not in memory, not considered for replacement</p> <p>Table after Tick 10 interrupt is following.</p> Page Time Stamp Present Referenced Modified 0 6 1 0 0 1 9 1 1 0 2 9 1 1 1 3 7 1 0 0 4 4 0 0 0"},{"location":"ECE482FA24/ECE482HW/ECE482H7/#ex-12-due-to-a-read-request-to-page-4-a-page-fault-occurs-at-tick-10-describe-the-new-table-entry","title":"Ex. 1.2. Due to a read request to page 4 a page fault occurs at tick 10. Describe the new table entry.","text":"<p>Suppose read request for page 4 is made. Since <code>Present</code> = 0, page is not in memory. Page Fault.</p> <p>WSLock Algorithm</p> <p>First, select victim page. For page 3, <code>Time Stamp</code> \\(= 7 \\leq 8\\), old, <code>Referenced</code>\\(=0\\), <code>Modified</code>\\(=0\\), No need to write back in disk.</p> <p>Now remove page 3 and load page 4. Update <code>Present</code> \\(=1\\), <code>Referenced</code>\\(=0\\), <code>Modified</code>\\(=0\\). Result table will be following.</p> Page Time Stamp Present Referenced Modified 0 6 1 0 0 1 9 1 1 0 2 9 1 1 1 3 7 0 0 0 4 10 1 0 0"},{"location":"ECE482FA24/ECE482HW/ECE482H7/#ex-2-minix-3","title":"Ex. 2 ??Minix 3","text":"<p>The goal of this exercise is to understand and implement system calls.</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H7/#ex-21-in-which-files-are","title":"Ex. 2.1. In which files are:","text":""},{"location":"ECE482FA24/ECE482HW/ECE482H7/#a-the-constants-with-number-and-name-for-the-system-calls","title":"a) the constants with number and name for the system calls?","text":"<p>Path is <code>/include/minix/callnr.h</code></p>"},{"location":"ECE482FA24/ECE482HW/ECE482H7/#b-the-names-of-the-system-call-routines","title":"b) the names of the system call routines?","text":"<p><code>/servers/*/table.c</code></p>"},{"location":"ECE482FA24/ECE482HW/ECE482H7/#c-the-prototypes-of-the-system-call-routines","title":"c) the prototypes of the system call routines?","text":"<p><code>/servers/*/proto.h</code></p>"},{"location":"ECE482FA24/ECE482HW/ECE482H7/#d-the-system-calls-of-type-ignalcoded","title":"d) the system calls of type ?\uc413ignal??coded?","text":"<p><code>/servers/pm/signal.c</code></p>"},{"location":"ECE482FA24/ECE482HW/ECE482H7/#ex-22-what-problems-arise-when-trying-to-implement-a-system-call-int-getchpidsint-n-pid_t-childpid","title":"Ex. 2.2. What problems arise when trying to implement a system call int getchpids(int n, pid_t *childpid)","text":""},{"location":"ECE482FA24/ECE482HW/ECE482H7/#which-ritesthe-pids-of-up-to-n-children-of-the-current-process-into-childpid","title":"which ?\uc417rites??the pids of up to n children of the current process into *childpid?","text":"<ul> <li>Since <code>*childpid</code> is located in user space, kernel code will not directly access to user space pointers</li> <li>Secure copy mechanism (<code>sys_datacopy</code>) is required.</li> <li>Validate Buffer size sufficiency to handle <code>n</code> child PIDs.</li> <li>Concurrent issue appears when process create or remove children during execution.</li> </ul>"},{"location":"ECE482FA24/ECE482HW/ECE482H7/#ex-23-write-a-ub-system-callint-getnchpidint-n-pid_t-childpid-which-retrieves-the-n-th-child-process","title":"Ex. 2.3. Write a ?\uc413ub-system call??int getnchpid(int n, pid_t childpid) which retrieves the n-th child process.","text":"<pre><code>#include \"pm.h\"\n#include \"mproc.h\"\n\nint getnchpid(int n, pid_t *childpid) {\n    if (childpid == NULL) return -1;\n    if (n &gt;= NR_PROCS) return -1;\n\n    struct mproc *child = &amp;mproc[n];\n    if (child-&gt;mp_parent != who_p) return -1;    // Ensure the process is a child of caller\n\n    *childpid = child-&gt;mp_pid;                    // Retrieve PID of the child\n    return 0;\n}\n</code></pre>"},{"location":"ECE482FA24/ECE482HW/ECE482H7/#ex-24-using-the-previous-sub-system-call-implement-the-original-getchpids-system-call","title":"Ex. 2.4. Using the previous sub-system call, implement the original getchpids system call.","text":""},{"location":"ECE482FA24/ECE482HW/ECE482H7/#the-returned-int-value-corresponds-to-the-number-of-pids-in-childpid-or-1-on-an-error","title":"The returned int value corresponds to the number of pids in *childpid, or -1 on an error.","text":"<pre><code>#include \"pm.h\"\n#include \"mproc.h\"\n\nint do_getchpids(int n, pid_t *childpid) {\n    if (childpid == NULL) return -1;\n    if (n &gt; NR_PROCS) return -1;\n\n    int count = 0;\n    for (int i = 0; i &lt; n; i++) {\n        int result = getnchpid(i, &amp;childpid[i]);\n        if (result == -1) break;  // Stop if no more children\n        count++;\n    }\n    return count;                 // Return children retrieved count\n}\n</code></pre>"},{"location":"ECE482FA24/ECE482HW/ECE482H7/#ex-25-write-a-short-program-that-demonstrate-the-previous-system-calls","title":"Ex. 2.5. Write a short program that demonstrate the previous system calls.","text":"<pre><code>#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/wait.h&gt;\n\n#define NUM 10  // Number of child processes to create\n\nint main() {\n    pid_t child_pids[NUM];\n    pid_t retrieved_pids[NUM];\n\n    // Create child processes\n    for (int i = 0; i &lt; NUM; i++) {\n        pid_t pid = fork();\n        if (pid == 0) { // Child process\n            printf(\"Child %d: PID = %d\\n\", i, getpid());\n            exit(0);\n        } else if (pid &gt; 0) { // Parent process\n            child_pids[i] = pid;\n        } else {\n            perror(\"fork failed\");\n            exit(1);\n        }\n    }\n\n    // Wait for all child processes to terminate\n    for (int i = 0; i &lt; NUM; i++) {\n        wait(NULL);\n    }\n\n    // Call `getchpids` to retrieve child PIDs\n    int result = getchpids(NUM, retrieved_pids);\n    if (result &lt; 0) {\n        fprintf(stderr, \"getchpids fail\\n\");\n        return -1;\n    }\n\n    // Validate and print results\n    for (int i = 0; i &lt; result; i++) {\n        printf(\"Retrieved PID: %d\\n\", retrieved_pids[i]);\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"ECE482FA24/ECE482HW/ECE482H7/#ex-26-the-above-strategy-solves-the-initial-problem-through-the-introduction-of-a-sub-system-call","title":"Ex. 2.6. The above strategy solves the initial problem through the introduction of a sub-system call.","text":""},{"location":"ECE482FA24/ECE482HW/ECE482H7/#a-what-are-the-drawbacks-and-benefits-of-this-solution","title":"a) What are the drawbacks and benefits of this solution?","text":"<p>Drawbacks:</p> <ul> <li>Additional overhead due to multiple calls to <code>getnchpid</code>.</li> <li>Complexity in handling edge cases (e.g., invalid indices).</li> <li>Higher potential for race conditions.</li> </ul> <p>Benefits:</p> <ul> <li>Modular design makes debugging easier.</li> <li>Reusability of the <code>getnchpid</code> function.</li> </ul>"},{"location":"ECE482FA24/ECE482HW/ECE482H7/#b-without-implementing-it-describe-the-basic-details-of-an-alternative-approach","title":"b) Without implementing it, describe the basic details of an alternative approach.","text":"<p>Implement <code>getchpids</code> as single system call</p> <ul> <li>Iteration through the process table in one pass.</li> <li>Retrieval of all child PIDs directly into user-provided buffer.</li> </ul>"},{"location":"ECE482FA24/ECE482HW/ECE482H7/#ex-3-research","title":"Ex. 3 ??Research","text":""},{"location":"ECE482FA24/ECE482HW/ECE482H7/#write-about-a-page-on-the-topic-of-the-ext2-filesystem-do-not-forget-to-reference-your-sources","title":"Write about a page on the topic of the ext2 filesystem. Do not forget to reference your sources.","text":"<p>Second Extended File System, or ext2 file system is a non-journaling filesystem introduced in 1993 for Linux. It was designed to overcome the limit of the ext filesystem by improving performance, flexibility, and scalability. due to its simplicity and efficiency, ext2 is still used for certain applications. Key components of ext2 are followings.</p> <ul> <li>Superblock contains filesystem metadata, its size, block num, inodes, etc</li> <li>Inode Table represent file or directory and contain information like size, owner, timestamp, etc</li> <li>Data Blocks save file contents. Large files are supported by indirect, double indirect, etc.</li> <li>Block Group divide filesystem to block group, each containing inode table, data block, etc.</li> </ul> <p>Since ext2 does not use journaling, overhead is reduced and writing speed is faster than later generation filesystems like ext3 or ext4 sometimes. This make it appropriate for devices with limited resources like USB or embedded systems. Its flexible inode allocation system allow optimized work performance with large quantity of volumes, even up to 2TB in size on 4KB block systems at maximum.</p> <p>However, absence of journaling represents crash or system power fail will require <code>fsck</code> check to restart. It might compromise data, and much slower. Also, its workload is not enough to handle huge quantity of volumes nowadays.</p> <p>References</p> <ul> <li>\"The Linux Kernel Archives\" - https://www.kernel.org</li> <li>\"Understanding Linux Filesystems\" - https://tldp.org</li> <li>Linux terminal man pages (man ext2, man fsck).</li> </ul>"},{"location":"ECE482FA24/ECE482HW/ECE482H7/#ex-4-simple-questions","title":"Ex. 4 ??Simple questions","text":""},{"location":"ECE482FA24/ECE482HW/ECE482H7/#ex-41-if-a-page-is-shared-between-two-processes","title":"Ex. 4.1. If a page is shared between two processes,","text":""},{"location":"ECE482FA24/ECE482HW/ECE482H7/#is-it-possible-that-the-page-is-read-only-for-one-process-and-read-write-for-the-other-why-or-why-not","title":"is it possible that the page is read-only for one process and read-write for the other? Why or why not?","text":"<p>Yes. Memory Management Unit (MMU) will enforce access permission based on page table of each process. One process will map page for read only, and other process will map as read and write.</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H7/#ex-42-when-both-paging-and-segmentation-are-being-used","title":"Ex. 4.2. When both paging and segmentation are being used,","text":""},{"location":"ECE482FA24/ECE482HW/ECE482H7/#first-the-segment-descriptor-is-found-and-then-the-page-descriptor-does-the-tlb-also-need-a-two-levels-lookup","title":"first the segment descriptor is found and then the page descriptor. Does the TLB also need a two-levels lookup?","text":"<p>No. TLB will not need two process layers. TLB acquire virtual to physical transition after page lookup and full segment. TLB will miss trigger two level lookup to update TLB.</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H8/","title":"Assignment VIII","text":"<p>ECE4820 FA2024 Introduction to Operating Systems</p> <p>518370990004 Jae Heung Park</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H8/#exercise-1-inputoutput","title":"Exercise 1 - Input/Output","text":""},{"location":"ECE482FA24/ECE482HW/ECE482H8/#1-is-it-possible-to-scan-a-document-and-send-it-through-a-wireless-network-at-full-speed-explain-why-why-not","title":"1. Is it possible to scan a document and send it through a wireless network at full speed? Explain why, why not.","text":"<p>It is theoretically possible depends on system bottleneck. Factors are scan resolution, scanner scan speed, and bandwidth of wireless network. If network speed is faster than scanner output rate, scan time will be fine. However, delays like image compression will prevent to send data to full speed of wireless network.</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H8/#2-how-can-an-os-facilitate-the-installation-of-a-new-device-without-any-need-to-recompile-the-os-or-even-to-reboot-it","title":"2. How can an OS facilitate the installation of a new device without any need to recompile the OS or even to reboot it?","text":"<p>OS can use modular designs to dynamically load device drivers. When new device is connected, OS will detect device by plug and play mechanism. Then, load the appropriate driver without requiring any reboot or recompile.</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H8/#3-in-the-slides-four-io-software-layers-are-listed-in-which-layers-are-the-following-operations-done","title":"3. In the slides four I/O software layers are listed; in which layers are the following operations done:","text":"<ul> <li>a) Computing the track, sector, and head for a disk read -&gt; Device Driver Layer</li> <li>b) Writing command to the device registers -&gt; Hardware Layer</li> <li>c) Checking if the user is allowed to use the device -&gt; User Level Software Layer or OS Layer</li> <li>d) Converting binary integers to ASCII for printing -&gt; User Level Software Layer</li> </ul>"},{"location":"ECE482FA24/ECE482HW/ECE482H8/#a-dma-controller-has-four-channels-the-controller-is-able-to-request-a-32bit-word-every-100-nsec","title":"A DMA controller has four channels. The controller is able to request a 32bit word every 100 <code>nsec</code>.","text":"<p>A response takes equally long. How fats should the bus be in order to avoid being a bottleneck?</p> <p>DMA controller request and response per 100<code>ns</code> for 32-bit words. Bus support speed \\(\\frac{32 <code>bits</code>}{100 <code>ns</code>} = 320\\)MB/<code>sec</code> = 40 MB/<code>sec</code> to avoid bottleneck.</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H8/#5-briefly-explain-what-a-thin-client-is","title":"5. Briefly explain what a thin client is.","text":"<p>Thin client is lightweight computer system. It mostly relies on server to process and store data. It is primarily used for application access, data, or remote desktop.</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H8/#6-describe-how-a-hard-disk-is-working-and-give-a-few-details-regarding-its-geometry","title":"6. Describe how a hard disk is working and give a few details regarding its geometry.","text":"<p>Hard disk can store a large quantity of data in a huge scale by platters. Each platter is divided by tracks, and each track is divided by sectors. The read/write head</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H8/#7-what-are-differences-between-raid-0-1-5-6-and-10","title":"7. What are differences between RAID 0, 1, 5, 6, and 10?","text":"<ul> <li>RAID 0 - Stripe without redundancy, fast, no fault tolerance</li> <li>RAID 1 - Stripe with redundancy, mirroring</li> <li>RAID 5 - Stripe with distributed parity, need at minimum 3 disks.</li> <li>RAID 6 - Stripe with distributed dual parity, can handle 2 disk failures</li> <li>RAID 10 Combine RAID 0 and 1, high performance by mirroring and stripe without redundancy</li> </ul>"},{"location":"ECE482FA24/ECE482HW/ECE482H8/#exercise-2-multiprocessors","title":"Exercise 2 - Multiprocessors","text":""},{"location":"ECE482FA24/ECE482HW/ECE482H8/#1-suppose-that-the-tsl-instruction-was-not-available-for-synchronizing-a-multiprocessor","title":"1. Suppose that the TSL instruction was not available for synchronizing a multiprocessor.","text":"<p>Instead, another instruction, SWP was provided that atomically swapped the contents of a register with a word in memory. How could that be used to provide multiprocessor synchronisation?</p> <p>The <code>SWP</code> instruction could swap register by lock with memory allocation easily. If lock is free, SWAP will lock variable to ensure mutual exclusion.</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H8/#2-briefly-describe-virtualization-and-the-main-challenges-that-need-to-be-overcome","title":"2. Briefly describe virtualization and the main challenges that need to be overcome.","text":"<p>Virtualization make several operating systems to run in one physical PC. However, resource allocation and isolation would be key technological challenges. Specifically, CPU scheduling, I/O virtualization, and security isolation will be important.</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H8/#exercise-3-file-systems","title":"Exercise 3 - File systems","text":""},{"location":"ECE482FA24/ECE482HW/ECE482H8/#1-assuming-the-current-working-directory-is-usrsharedocmuttexamples","title":"1. Assuming the current working directory is <code>/usr/share/doc/mutt/examples</code>","text":"<p>what is the absolute path of <code>../../../doc/../../lib/mutt</code>?</p> <p><code>/usr/share/doc/mutt/examples</code> to <code>../../../doc</code> is <code>/usr/share/doc</code>. <code>/usr/share/doc</code> to <code>../../lib/mutt</code> is <code>/usr/lib/mutt</code> Thus, absolute path will be <code>/usr/lib/mutt</code>.</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H8/#2-a-unix-system-has-1kb-blocks-and-4b-disk-addresses","title":"2. A Unix system has 1KB blocks and 4B disk addresses.","text":"<p>What is the maximum file size if i-nodes contain 13 direct entries, and one single, double , and triple indirect entry each?</p> <p>Each block can hold \\(\\frac{1KB}{4KB}=256\\) addresses.</p> <ul> <li>Direct entries are \\(13 \\times 1KB = 13KB\\)</li> <li>Single Indirect Entry \\(256 \\times 1KB = 256KB\\)</li> <li>Double Indirect Entry \\(256 \\times 256 \\times 1KB = 65536KB = 64MB\\)</li> <li>Triple Indirect Entry \\(256 \\times 256 \\times 256 \\times 1KB = 16777216MB = 16384MB = 16GB\\)</li> <li>Maximum File Size \\(13KB + 256KB + 64MB + 16GB = 16448.2627 MB = 16.06GB\\)</li> </ul>"},{"location":"ECE482FA24/ECE482HW/ECE482H8/#3-the-time-required-to-read-a-certain-number-of-bytes-can-be-approximated-by-summing-the-seek-rotation-delay-and-transfer-times","title":"3. The time required to read a certain number of bytes can be approximated by summing the seek, rotation delay, and transfer times.","text":"<p>Given a disk with mean seek time of 8 msec, a rotation rate of 15,000 rpm and 262,144 bytes per track what are the data rates for block sizes of</p> <ul> <li>(i) 1 KB,</li> <li>(ii) 2 KB, and</li> <li>(iii) 4 KB?</li> </ul> <p>Parameters Provided</p> <ul> <li>Mean seek time = $ 8 \\, \\text{ms} $</li> <li>Rotation time per revolution = $ \\frac{1}{15,000} \\times 60,000 = 4 \\, \\text{ms} $</li> <li>Bytes per track = $ 262,144 \\, \\text{bytes} $</li> </ul> <p>Transfer Time Formula: $ \\text{Transfer Time} = \\frac{\\text{Block Size}}{\\text{Bytes per Track}} \\times 4 \\, \\text{ms} $</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H8/#i-block-size-1-kb-1024-textbytes","title":"(i) Block Size = 1 KB ($ 1,024 \\, \\text{bytes} $)","text":"<ul> <li>Transfer Time = $ \\frac{1,024}{262,144} \\times 4 \\approx 0.0156 \\, \\text{ms} $</li> <li>Total Time = $ 8 + 4 + 0.0156 = 12.0156 \\, \\text{ms} $</li> <li>Data Rate = $ \\frac{1,024 \\, \\text{bytes}}{12.0156 \\, \\text{ms}} \\approx 85.2 \\, \\text{KB/s} $.</li> </ul>"},{"location":"ECE482FA24/ECE482HW/ECE482H8/#ii-block-size-2-kb-2048-textbytes","title":"(ii) Block Size = 2 KB ($ 2,048 \\, \\text{bytes} $)","text":"<ul> <li>Transfer Time = $ \\frac{2,048}{262,144} \\times 4 \\approx 0.0312 \\, \\text{ms} $</li> <li>Total Time = $ 8 + 4 + 0.0312 = 12.0312 \\, \\text{ms} $</li> <li>Data Rate = $ \\frac{2,048 \\, \\text{bytes}}{12.0312 \\, \\text{ms}} \\approx 170.3 \\, \\text{KB/s} $.</li> </ul>"},{"location":"ECE482FA24/ECE482HW/ECE482H8/#iii-block-size-4-kb-4096-textbytes","title":"(iii) Block Size = 4 KB ($ 4,096 \\, \\text{bytes} $)","text":"<ul> <li>Transfer Time = $ \\frac{4,096}{262,144} \\times 4 \\approx 0.0624 \\, \\text{ms} $</li> <li>Total Time = $ 8 + 4 + 0.0624 = 12.0624 \\, \\text{ms} $</li> <li>Data Rate = $ \\frac{4,096 \\, \\text{bytes}}{12.0624 \\, \\text{ms}} \\approx 339.7 \\, \\text{KB/s} $.</li> </ul>"},{"location":"ECE482FA24/ECE482HW/ECE482H8/#exercise-4-security","title":"Exercise 4 - Security","text":""},{"location":"ECE482FA24/ECE482HW/ECE482H8/#1-if-using-only-lowercase-letters-how-many-possible-8-letter-words-can-be-chosen","title":"1. If using only lowercase letters how many possible 8 letter words can be chosen?","text":"<p>Explain why a password should always contain lower and uppercase letters, numbers and symbols.</p> <p>8 Character Word, use only lowercase letters, 26 probabilities per each character. Possible combination likelihood will be \\(26^8 = 208827064576\\) cases.</p> <p>It is important to contain lower case, upper case letter, number, and symbols because it will increment probability of password search space exponentially. Entropy of password increases, so brute Force attack will be more resource unlikely. For instance, uppercase multiplies twice probability per character, \\(2^8=256\\) times for 8 characters.</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H8/#2-explain-why-memory-dynamically-allocated-using-malloc-is-sometimes-random-and-some-other-times-set-to-0","title":"2. Explain why memory dynamically allocated using malloc is sometimes random and some other times set to 0.","text":"<p>Memory allocation by <code>malloc</code> does not initialize memory. It reserves size but may return memory with no leftover values from previous use, while <code>calloc</code> explicitly initialize to 0. If <code>calloc</code> is called, or memory is initialized explicitly, checking whether memory start is 0 or not is crucial.</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H8/#3-a-computer-system-is-made-of-several-components-each-featuring-a-different-level-of-security-how-secure-is-this-system","title":"3. A computer system is made of several components each featuring a different level of security. How secure is this system?","text":"<p>Computer system security is same as the most vulnerable part of the computer system. Attackers might detect and exploit the least secure component so that entire system is under attack. For instance, old firmware security vulnerability might be a trigger to compromise the entire OS, that has no security problem in the OS. Defense in depth strategies are minor ways to support weakest vulnerabilities.</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H8/#4-can-security-be-achieved-explain-your-answer","title":"4. Can security be achieved? Explain your answer.","text":"<p>Even theoretically, accomplishment of computer system to secure 100% perfect security is not achievable considering the complexity of computer system and its continuous technological progress. In some perspective, some super computer that does not exist in real world might make all computer systems insecure by brute force. In reality, it is even harder, due to several updates, conflicts, computer external problems like electricity supply or network, human mistakes, etc. So, people generally compromise by implementation of defence layer, regular updates, access controls, and continuous monitor.</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H8/#exercise-5-research","title":"Exercise 5 - Research","text":"<p>Write about half a page on the topic of firewalls on Linux systems; include information on iptables. Do not forget to reference your sources of information.</p> <p>In Linux Operating System, Firewalls manage and secure network traffic by controlling incoming and outgoing traffic based on predefined rules. It could protect against not authorized access and attacks. Firewall acts as barrier located between trusted networks and untrusted networks. It protects system access from unauthorized access, so that attacks and data breaches are prevented.</p> <p>Firework analyze packets and decide whether they are allowed by defined rules including:</p> <ul> <li>IP Address : allow or block traffic from specific source or destination</li> <li>Port Numbers : Filter by services (Block SSH by block port 22)</li> <li>Protocols : Protocol type based filtering like TCP or UDP</li> </ul> <p>There are several types of firewalls available.</p> <ul> <li>Packet Filtering Firewall work at network layer to inspect each individual packet, regardless of connection status.</li> <li>Stateful Firewall could work and track connection status to make more context aware decisions</li> <li>Application Firewall inspect packet contents in application layer</li> <li>Proxy Firewalls act between server and client to mask internal network</li> </ul> <p>One of the most commonly applied tool on Linux firewall is <code>iptables</code>. It is a part of the <code>netfilter</code> framework inside Linux OS kernel. It could operate on chains including <code>INPUT</code>, <code>OUTPUT</code>, and <code>FORWARD</code> so that traffic filtering is possible through IO address, ports, or protocols.</p> <p>Administrator access could allow and block network traffic by making <code>iptables</code> rules. For example, following command can be used to prevent any SSH traffic on part 22.</p> <pre><code>sudo iptables -A INPUT -p tcp --dport 22 -j DROP\n</code></pre> <p>Even though <code>nftables</code>, more recent version that provide higher performance and better usability, <code>iptables</code> are still used in some modern distributions due to its stability and reliability. Additional tools like Uncomplicated Firewall (UFU) and firewalld support interfaces that are friendly for users to manage firewall rules, sot that complexity of iptables is in abstract.</p> <p>Although firewalls are powerful and have several functionalities, their limitation would be due to its subordinate part of layered security approach as some framework or tool than could be part of consistent update and intrusion detection systems (IDS).</p>"},{"location":"ECE482FA24/ECE482HW/ECE482H8/#references","title":"References","text":"<ul> <li>Linux Foundation. \"iptables Documentation.\"</li> <li>Red Hat. \"Introduction to Firewalld and iptables.\"</li> <li>Ubuntu Documentation. \"Uncomplicated Firewall (UFW).\"</li> <li>Netfilter Project. \"nftables Overview.\"</li> <li>Iptables HowTo.</li> <li>Introduction to nftables</li> </ul>"},{"location":"ECE482FA24/ECE482LAB/ECE482L1/","title":"Lab 01","text":"<p>ECE4820 FA2024 Introduction to Operating Systems</p> <p>518370990004 Jae Heung Park</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L1/#1-hardware-overview","title":"1 Hardware overview","text":""},{"location":"ECE482FA24/ECE482LAB/ECE482L1/#in-the-computer","title":"In the computer","text":"<p>The motherboard</p> <p></p> <p>A Hard Disk Drive</p> <p></p> <p>An Optical disk drive</p> <p></p> <p>The PC power supply</p> <p></p> <p>A PCI card</p> <p>PCI card did not exist in computer disassembled during lab.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L1/#on-the-motherboard","title":"On the motherboard","text":"<p>The RAM</p> <p></p> <p>A SATA socket</p> <p></p> <p>A PCI/PCI-e slot</p> <p></p> <p>The CPU</p> <p></p> <p>The North and South bridges</p> <p></p> <p>The battery</p> <p></p> <p>The BIOS</p> <p></p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L1/#answer-the-following-questions","title":"Answer the following questions","text":"<ul> <li>Where is the CPU hidden, and why?</li> </ul> <p>CPU (Central Processing Unit) is located below a fan and heat sink in CPU dismantled during lab. CPU creates a lot of heat during computer is operating, so it is necessary to have a cooling system attached to CPU. Air cooling by fan is universal, but sometimes liquid based cooling system can be used.</p> <ul> <li>What are the North and South bridges?</li> </ul> <p>North and South bridges are chips only existing in old motherboard chips. North Bridge controls CPU, RAM, internal Graphics Card interaction to be fast South Bridge controls HDD, USB, or PCIs like external VGA.</p> <ul> <li>How are the North and South bridges connected together?</li> </ul> <p>North &amp; South Bridges are connected through a bus. In motherboard, bus let data flow between these two bridges.</p> <ul> <li>What is the BIOS?</li> </ul> <p>BIOS(Basic Input/Output System) is a firmware software saved in motherboard chip. After the power is on, BIOS will be launched in computer, initializing CPU and RAM to either start Operating Systems like Windows or Linux, or changing setup.</p> <ul> <li>Take out the CPU, rotate it and try to plug it back in a different position, is that working?</li> </ul> <p>CPU is specifically designed compatible for only certain type of socket. Thus, CPU will be inserted only in the way it was inserted before. Forcing different position will result in compromising both CPU and motherboard CPU socket.</p> <ul> <li>Explain what overclocking is?</li> </ul> <p>Instructed in ECE370 Computer organization course, CPU is operating by each clock. More clocks per same time means faster CPU operation, but more consumption of electricity and creation of heat, so that CPU lifespan or even CPU circuit might be compromised if cooling system cannot handle it.</p> <ul> <li>What are pins on a PCI/PCI-e card and what are they used for?</li> </ul> <p>PCI PCI-e card pins connect PCI card to motherboard by their slots. These pins will let PCI card to interact with data transfer to motherboard. Thus, card and motherboard will communicate. One of the most popular type of PCI PCI-e card are VGA (Video Graphics Array), we call as external graphic cards like Nvidia RTX4090 or GTX1650.</p> <ul> <li>Before PCI-e became a common standard many graphics cards were using Accelerated Graphics   Port (AGP), explain why.</li> </ul> <p>AGP was specifically designed only for fast communication between CPU and graphic card. Before PCI-e, AGP was standard since it had better performance than PCI bus for data interaction with motherboard, but PCI-e performance was better in speed and compatibility, so it replaced AGP.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L1/#2-gitea-usage","title":"2 Gitea usage","text":"<p>Register on our git server at http://focs.ji.sjtu.edu.cn/git. We will use Gitea all along the semester. For the various group projects student must use git: part of their grade will be based on their commits. Please closely follow the TAs??instructions and ensure your are fully setup for the rest of the semester. In particular by the end of the lab you should have uploaded your ssh public key on Gitea.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L1/#21-git-usage","title":"2.1 Git Usage","text":"<p>Basic git usage will be studied in a future lab. In the meantime get familiar with:</p> <ul> <li>Opening and using issues;</li> <li>Simple commands such as clone, commit, push, and pull;</li> <li>Using the Wiki and markdown, they will be used for the projects documentation;</li> </ul>"},{"location":"ECE482FA24/ECE482LAB/ECE482L1/#22-agile-development-with-gitea","title":"2.2 Agile development with Gitea","text":"<p>In ECE482 we expect you follow the adgile development strategy which is adopted by most companies nowadays. If you have any question of need further explanations feel free to ask. Here is a brief summary of the expected Gitea workflow in the course.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L1/#3-command-line-interface","title":"3 Command line interface","text":""},{"location":"ECE482FA24/ECE482LAB/ECE482L1/#31-basic-unix-commands","title":"3.1 Basic Unix commands","text":""},{"location":"ECE482FA24/ECE482LAB/ECE482L1/#32-shell-scripting","title":"3.2 Shell scripting","text":""},{"location":"ECE482FA24/ECE482LAB/ECE482L1/#33-tasks","title":"3.3 Tasks","text":"<p>Answer the following questions, only refering to man pages:</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L1/#use-the-mkdir-touch-mv-cp-and-ls-commands-to","title":"Use the mkdir, touch, mv, cp, and ls commands to:","text":"<ul> <li>Create a file named test.</li> <li>Move test to dir/test.txt, where dir is a new directory.</li> <li>Copy dir/test.txt to dir/test_copy.txt.</li> <li>List all the files contained in dir.</li> </ul> <pre><code>touch test\nmkdir dir\nmv test dir\nls dir\n</code></pre>"},{"location":"ECE482FA24/ECE482LAB/ECE482L1/#use-the-grep-command-to","title":"Use the grep command to:","text":"<p>List all the files form /etc containing the pattern 127.0.0.1.</p> <pre><code>grep -rl '127.0.0.1' /etc\n</code></pre> <p>Returned nothing</p> <p>Only print the lines containing your username and root in the file /etc/passwd (only one grep should be used)</p> <pre><code>grep -rE 'root|jaeheungpark' /etc/passwd\n</code></pre> <p>Returns following</p> <pre><code>/etc/passwd:root:*:0:0:System Administrator:/var/root:/bin/sh\n/etc/passwd:daemon:*:1:1:System Services:/var/root:/usr/bin/false\n/etc/passwd:_cvmsroot:*:212:212:CVMS Root:/var/empty:/usr/bin/false\n</code></pre>"},{"location":"ECE482FA24/ECE482LAB/ECE482L1/#use-the-find-command-to","title":"Use the find command to:","text":"<p>List all the files from /etc that have been accessed less than 24 hours ago.</p> <pre><code>find /etc -atime -1\n</code></pre> <p>Returned nothing</p> <p>List all the files from /etc whose name contains the pattern ?\uc40detw??</p> <pre><code>find /etc -name \"*netw*\"\n</code></pre> <p>Returned nothing</p> <p>In the bash man-page read the part related to redirections. Explain the following operators &gt;, &gt;&gt;, &lt;&lt;&lt;, &gt;&amp;1, and 2&gt;&amp;1 &gt;. What is the use of the tee command.</p> <p>Use <code>bash</code> instead of <code>zsh</code> terminal if you are MacOS user. Simply type <code>bash</code> or <code>zsh</code> to switch.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L1/#output-redirection","title":"<code>&gt;</code> Output Redirection","text":"<p>Output Redirection redirect output from command to file. If file already exists, it will be overwritten.</p> <pre><code>echo \"Hello, Shell!\" &gt; output.txt\n</code></pre> <p>This will generate <code>output.txt</code> file or if it exists, overwrite it with contents written as <code>Hello Shell!</code>.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L1/#append-output-redirection","title":"<code>&gt;&gt;</code> Append Output Redirection","text":"<p>Append Output Redirection redirect output from command to file. However, this time, command will be appended to originally existing file, instead of getting overwritten.</p> <pre><code>echo \"Hello, Again!\" &gt;&gt; output.txt\n</code></pre>"},{"location":"ECE482FA24/ECE482LAB/ECE482L1/#here-string","title":"<code>&lt;&lt;&lt;</code> Here String","text":"<p>Here String provide input to command from string. When using grep,</p> <p><code>grep \"find this\" &lt;&lt;&lt; \"input sentence\"</code></p> <pre><code>grep \"Hello\" &lt;&lt;&lt; \"Hello, Shell!\"\ngrep \"World\" &lt;&lt;&lt; \"Hello, Shell!\"\n</code></pre> <p>First one will return <code>Hello Shell!</code> while the second one will return nothing.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L1/#1-redirect-to-standard-output","title":"<code>&gt;&amp;1</code> Redirect to Standard Output","text":"<p>Redirect to Standard Output will make a file descriptor input to a copy file descriptor 1. Generally, it is standard output.</p> <pre><code>ls non_existing_file\nls non_existing_file &gt;&amp;1\n</code></pre> <p>Both returns</p> <pre><code>ls: non_existing_file: No such file or directory\nls: non_existing_file: No such file or directory\n</code></pre> <p>However, former one returns error, while latter one returns output as standard output string.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L1/#21-order-of-redirections","title":"<code>2&gt;&amp;1&gt;</code> Order of Redirections","text":"<p>Order of redirections will redirect standard output to file.</p> <pre><code>ls non_existing_file &gt; nofile.txt\nls non_existing_file &gt; nofile.txt 2&gt;&amp;1\n</code></pre> <p>Formal one returns the following error on terminal.</p> <pre><code>ls: non_existing_file: No such file or directory\n</code></pre> <p>However, latter one will create file named as nofile.txt as a command file.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L1/#what-is-the-use-of-the-tee-command","title":"What is the use of the <code>tee</code> command.","text":"<p>The <code>tee</code> command will read from standard input and write as standard output.</p> <pre><code>echo \"Hello, Shell!\" | tee teefile.txt\necho \"Hello, Again!\" | tee -a teefile.txt\n</code></pre> <p>Former command creates output file first sentence. Latter command adds output file second sentence.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L1/#explain-the-behaviour-of-the-xargs-command","title":"Explain the behaviour of the <code>xargs</code> command","text":"<p>The <code>xargs</code> command will build and execute commands from standard input.</p> <pre><code>echo \"file1 file2 file3\" | xargs touch\necho \"file1 file2 file3\" | xargs rm\n</code></pre> <p>will create and remove file1 file2 file3.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L1/#the-pipe-operator","title":"The <code>|</code> pipe operator","text":"<p>The <code>|</code> pipe operator will take output of each command and apply it as input. For instance,</p> <pre><code>ls -l | grep \"txt\"\n</code></pre> <p>will return</p> <pre><code>-rw-r--r--@ 1 jaeheungpark  staff  47 Sep 22 15:19 nofile.txt\n-rw-r--r--@ 1 jaeheungpark  staff  28 Sep 22 15:27 output.txt\n-rw-r--r--@ 1 jaeheungpark  staff  28 Sep 22 15:28 teefile.txt\n</code></pre>"},{"location":"ECE482FA24/ECE482LAB/ECE482L1/#what-are-the-head-and-tail-commands-how-to-ive-displaya-file-as-new-lines-are-appended","title":"What are the head and tail commands? How to ?\uc40bive display??a file as new lines are appended?","text":"<p><code>Head</code> commands display first few lines of file, 10 lines in default. <code>Tail</code> commands display last few lines of file, 10 lines in default. If live display of a file is required, type <code>tail -f file.txt</code>, since <code>-f</code> represents follow.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L1/#how-to-monitor-the-system-using-ps-top-free-vmstat","title":"How to monitor the system using ps, top, free, vmstat?","text":"<p><code>ps</code> shows currently running processes.</p> <pre><code>  PID TTY           TIME CMD\n 2360 ttys000    0:00.11 /bin/zsh --login -i\n 2362 ttys000    0:00.49 /Users/jaeheungpark/.cache/gitstatus/gitstatusd-darwin-arm64 -G v1.5.4 -s -1 -u -1 -d -1 -c -1 -m -1 -v FATAL -t 22\n 3018 ttys000    0:00.02 bash\n 3189 ttys000    0:00.86 zsh\n</code></pre> <p><code>top</code> shows real time dynamic system process view including CPU usage and memory usage. Command input <code>top</code> returns</p> <pre><code>Processes: 659 total, 2 running, 657 sleeping, 3545 threads                                                                               15:57:40\nLoad Avg: 2.13, 1.97, 1.95  CPU usage: 3.19% user, 3.10% sys, 93.69% idle  SharedLibs: 765M resident, 149M data, 92M linkedit.\nMemRegions: 169888 total, 5315M resident, 502M private, 3869M shared. PhysMem: 17G used (2236M wired, 761M compressor), 359M unused.\nVM: 256T vsize, 4915M framework vsize, 0(0) swapins, 0(0) swapouts. Networks: packets: 3661368/5529M in, 2247373/2009M out.\nDisks: 1271160/19G read, 399936/13G written.\nmode [n]:\nPID    COMMAND      %CPU TIME     #TH    #WQ  #PORT MEM    PURG   CMPRS  PGRP  PPID  STATE    BOOSTS          %CPU_ME %CPU_OTHRS UID  FAULTS\n464    mobileassetd 13.5 00:20.36 7      5    201   14M-   0B     1824K  464   1     sleeping *7+[137]        0.04815 12.17135   0    7653+\n0      kernel_task  7.5  24:37.01 576/11 0    0     9040K  0B     0B     0     0     running   0[0]           0.00000 0.00000    0    39329+\n1104   clion        7.1  22:43.94 129    6    685+  1889M- 278M+  345M   1104  1     sleeping *0[1516]        0.04079 0.00000    501  1150909+\n</code></pre> <p><code>free</code> shows different kinds of memory usage including total, used, free, shared, buffer, cache, and available memories.</p> <p><code>vmstat</code> Shows virtual memory statistics including status of memory, process, paging, block input, output, traps updated per input second. For instance, <code>vmstat 1</code> will update the output every second.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L1/#what-are-the-main-differences-between-sh-bash-csh-and-zsh","title":"What are the main differences between sh, bash, csh, and zsh?","text":"<p><code>sh</code> Shell is original basic shell, with the least amount of features</p> <p><code>bash</code> Bourne Again SHell is implemented shell version including command history, job control, and array.</p> <p><code>csh</code> C shell is based on similar syntax to the programming language C.</p> <p><code>zsh</code> Z shell is configurable shell with several features from both bash and csh. Currently shell of my M3 MacBook Pro OS is using zsh shell.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L1/#what-is-the-meaning-of-0-1","title":"What is the meaning of $0, $1,?? $?, $!?","text":"<p><code>$0</code> Name of script / shell</p> <p><code>$1, $2, $3 ...</code> Arguments in order to get passed in script.</p> <p><code>$?</code> Exit status of last command. 0 means success while other numbers represent fail.</p> <p><code>$!</code> Process ID of last background command.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L1/#what-is-the-use-of-the-ps3-variable-provide-a-short-code-example","title":"What is the use of the PS3 variable? Provide a short code example.","text":"<p>PS3 variable can set prompt for select command in bash. For instance, this is possible.</p> <pre><code>PS3=\"Select option: \"\nselect option in \"Start\" \"Resume\" \"Quit\"; do\n  echo \"You selected: $option\"\n  [[ $option == \"Quit\" ]] &amp;&amp; break\ndone\n</code></pre>"},{"location":"ECE482FA24/ECE482LAB/ECE482L1/#what-is-the-purpose-of-the-iconv-command-and-why-is-it-useful","title":"What is the purpose of the <code>iconv</code> command, and why is it useful?","text":"<p>Purpose of <code>iconv</code> command is to convert text between different character encodings systems like from ISO to UTF-8. It is useful when working with files with different systems or programs that have difference from standard format.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L1/#given-a-variable-temp-what-is-the-effect-of","title":"Given a variable <code>temp</code>, what is the effect of:","text":"<ul> <li><code>${#temp}</code></li> <li><code>${temp%%word}</code></li> <li><code>${temp/pattern/string}</code>?</li> </ul> <p><code>${#temp}</code> Return string length stored in <code>temp</code> variable</p> <p><code>${temp%%word}</code> Remove longest match of pattern word</p> <p><code>${temp/pattern/string}</code> Replace first <code>pattern</code> in <code>temp</code> containing <code>string</code>.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L1/#search-online-not-in-the-man-pages-how-files-are-organised-on-a-unix-like-system","title":"Search online (not in the man pages), how files are organised on a Unix like system.","text":"<p>In particular explain what are the following directories used for:</p> <ul> <li><code>/:</code> Root directory, File System tree root.</li> <li><code>/bin</code> Binaries, store basic user commands including <code>ls</code>, <code>mv</code>, <code>cp</code>.</li> <li><code>/boot</code> Store bootloader files like kernel, initial RAM space.</li> <li><code>/etc</code> Configuration files for OS &amp; Applications</li> <li><code>/lib</code> System libraries necessary for OS booting</li> <li><code>/media</code> If media devices are connected or inserted in computer, OS will make corresponding directory here</li> <li><code>/mnt</code> Temporary mounted files.</li> <li><code>/usr/bin</code> User Binary files for User Applications</li> <li><code>/usr/share</code> Sharable text files</li> <li><code>/usr/lib</code> User Libraries required for <code>usr/bin</code></li> <li><code>/usr/src</code> Source codes for Linux Kernel</li> <li><code>/proc</code> Virtual Filesystems with process and kernel info</li> <li><code>/sys</code> Kernel interface with info view and configuration settings</li> <li><code>/srv</code> Data for Services by system like web servers</li> <li><code>/opt</code> Optional packages for subordinate directories</li> <li><code>/var</code> Variable data including system logging files</li> <li><code>/sbin</code> System binaries required for booting and system restoration</li> <li><code>/dev</code> Device files representing hardware</li> <li><code>/vmlinuz</code> Compressed Linux kernel used for booting</li> <li><code>/initrd.img</code> Initial RAM space used by kernel for booting</li> </ul> <p>Write a game where the computer selects a random number, prompts the user for a number, compares it to its number and displays ?\uc3ecarger??or ?\uc3f6maller??to the user, until the player discovers the random number initially chosen by the computer.</p> <p>Execute by command</p> <pre><code>chmod +x game.sh\n./game.sh\n</code></pre> <p>Code works well.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L10/","title":"Lab 10","text":"<p>ECE4820 FA2024 Introduction to Operating Systems</p> <p>518370990004 Jae Heung Park</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L10/#1-project-3-presentations-part-2","title":"1 Project 3: presentations (part 2)","text":"<p>Presentation</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L10/#2-a-clean-setup","title":"2 A clean setup","text":"<p>After a couple of hours working in the back of your mum and Mr. Frown you have finally completed your dice device driver. Although everything is working you have quite enjoyed the process and to have a feeling of full accomplishment you want to polish your work. For instance you want the module to be automatically loaded when the system boot ups, and you imagine that if your grandpa had friends with an account on the same computer they would enjoy playing too. To solve those questions you need to check the following points:</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L10/#where-to-copy-the-dice-module-for-it-to-be-officially-known-to-the-kernel","title":"Where to copy the dice module for it to be officially known to the kernel?","text":"<p>Kernel module copy path <code>/lib/modules/</code> or <code>/lib/modules/$(uname -r)/kernel/drivers/&lt;custom_directory&gt;</code> or subdirectory based on their purpose</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L10/#what-command-to-run-in-order-to-generate-the-modulesdep-and-map-files","title":"What command to run in order to generate the <code>modules.dep</code> and map files?","text":"<p>Use <code>depmod</code> command to generate dependency map</p> <pre><code>depmod -a\n</code></pre>"},{"location":"ECE482FA24/ECE482LAB/ECE482L10/#how-to-ensure-the-dice-module-is-loaded-at-boot-time-and-how-to-pass-it-options","title":"How to ensure the dice module is loaded at boot time, and how to pass it options?","text":"<p>Add the module to <code>/etc/modules</code> or <code>/etc/modules-load.d/&lt;filename&gt;.conf</code> for some distributions to ensure it loads at boot. To pass options, create or edit <code>/etc/modprobe.d/&lt;module_name&gt;.conf</code> with the following content:</p> <pre><code>options &lt;module_name&gt; &lt;option1&gt;=&lt;value1&gt; &lt;option2&gt;=&lt;value2&gt;\n</code></pre>"},{"location":"ECE482FA24/ECE482LAB/ECE482L10/#how-to-create-a-new-friends-group-and-add-grandpa-and-his-friends-to-it","title":"How to create a new friends group and add grandpa and his friends to it?","text":"<p>First, create a new group. Name will be friends. Then, add one of OS users to the group.</p> <pre><code>sudo groupadd friends\nsudo usermod -aG friends &lt;username&gt;\n</code></pre>"},{"location":"ECE482FA24/ECE482LAB/ECE482L10/#what-is-udev-and-how-to-define-rules-such-that-the-group-and-permissions-are-automatically-setup-at-device-creation","title":"What is udev and how to define rules such that the group and permissions are automatically setup at device creation?","text":"<p><code>udev</code> is Linux device manager. It dynamically control device nodes at <code>/dev</code> and handle events. Define rules by file generation in path <code>etc/udev/rules.d</code>, e.g., <code>10-dice.rules</code></p> <pre><code>SUBSYSTEM==\"&lt;subsystem&gt;\", KERNEL==\"&lt;device_name&gt;\", GROUP=\"friends\", MODE=\"0660\"\n</code></pre> <p>Then, reload <code>udev</code> rules to trigger those</p> <pre><code>sudo udevadm control --reload-rules\nsudo udevadm trigger\n</code></pre>"},{"location":"ECE482FA24/ECE482LAB/ECE482L10/#3-a-discreet-gambling-setup","title":"3 A discreet gambling setup","text":"<p>The challenge is now to get this module on the family computer without anybody noticing it. If someone tells your mother then both you and your grandpa will get in trouble. So you need a way to get root access without inputing a wrong password and without knowing it! As it is too risky to open the computer and take the hard disk to plug it on your own computer you have find another strategy.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L10/#31-hacking-mum-computer","title":"3.1. Hacking mum?\uc172 computer","text":"<p>After a bit of thinking you have an interesting idea: on Linux systems the executables can be found in the PATH, a colon separated list of directories. If more than one binary have the same name, then the one found first is used. As you know your mum often uses the command su to become root, it thus suffices to write a simple script called su, place it in a directory of your choice that you then prepend to the PATH variable. When she will type su it will run your script. To your mum its behaviour should feel similar to the real su, i.e. prompt for the root password and behave as if a wrong password had been input. In fact in the background it should send you an email containing the root password and clean up all your traces, that is delete the script, and reset the PATH to its original value. That way your mum will think she has made a mistake and will rerun su. That time the correct command will be called and she will gain root access. Therefore you think of the following points:</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L10/#how-adjust-the-path-ensure-its-new-version-is-loaded-but-then-forgotten","title":"How adjust the PATH, ensure its new version is loaded but then forgotten?","text":"<p>Open <code>~/.bashrc</code> or <code>./zshrc</code> and add <code>export PATH=/path/to/directory:$PATH</code>. After finish, run <code>~./bashrc</code> or <code>./zshrc</code> to apply change.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L10/#what-is-the-exact-behaviour-of-su-when-wrong-password-is-input","title":"What is the exact behaviour of <code>su</code> when wrong password is input?","text":"<p>When <code>su</code> is executed with incorrect password, <code>perror</code> will be thrown.</p> <pre><code>su: Authentication failure\n</code></pre> <p>Will be printed in terminal.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L10/#when-using-the-read-command-how-to-hide-the-user-input","title":"When using the read command how to hide the user input?","text":"<p>Use <code>-s</code> option to hide input</p> <pre><code>read -s &lt;input&gt;\necho\n</code></pre>"},{"location":"ECE482FA24/ECE482LAB/ECE482L10/#how-to-send-an-email-from-the-command-line","title":"How to send an email from the command line?","text":"<p>CLI based email send requires installation of libraries first.</p> <pre><code>sudo apt install mailutils # Linux\nbrew install mailutils # MacOS\n</code></pre> <p>This one will be possible</p> <pre><code>echo \"The root password is: $password\" | mail -s \"root password\" email@site.com\n</code></pre> <p>Once you have completed this simple script you patiently wait for the email.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L11/","title":"Lab 11","text":"<p>ECE4820 FA2024 Introduction to Operating Systems</p> <p>518370990004 Jae Heung Park</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L11/#1-project-3-presentations-part-3","title":"1 Project 3: presentations (part 3)","text":"<p>To ensure a more synchronised support during project 3, presentations are split into two parts. Topics are available on Canvas and their selection is on a first come first served basis. Please well prepare your presentation and ask questions on others??research. This should greatly help in the implementation of the new scheduling algorithm. No stress, Jim is probably playing in the ball pit!</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L11/#2-introduction","title":"2 Introduction","text":"<p>Seeing that you are half-convinced by his motivating words you dad carries on. ?\uc3fdou know what, I have the perfect solution for you: instead of working on the module, in kernel mode, let?\uc172 work in user-space? Everything will be much easier and you can work with Dadfs in the same way as with any other regular C program. You just need to use FUSE, this is a great project that acts as an interface to export a file system to the kernel. No need for functions to share buffers between the user-space and the kernel space, this is FUSE?\uc172 job, not yours. You simply type your code and treat FUSE as a dependency/library to build your program.?? At hearing that their is no risk to crash the kernel you feel relieved and want to try this ?\uc40cagical library?? As you ask your dad how to get started, he tells you that he has already prepared some materials. Your job for today is to port Dadfs to FUSE and implement file deletion. With that idea in mind he shares with you some resources. Since he wants to go soon for his nap he quickly shows you a couple of FUSE links: the FUSE documentation, and the libfuse source code. As you seat down at the desk your dad understands that you are ready to start. He then leaves the room and goes for his nap. Although the temptation is high to play video games instead of porting Dadfs to FUSE, you decide to start working on this new short project. After a few minutes you fully understand the global idea behind FUSE and how it interacts with Linux Virtual File System (VFS). You are ready to jump into Dadfs when your mum enters the room and asks you: ?\uc3f6o what?\uc172 wrong with the electricity, I thought you were supposed to work on Dadfs???As you look perplex your mother continues: ?\uc3fdes, I heard something was wrong a fuse, is it fixed, can I what TV or their is a risk of blackout???When you are done laughing your mum asks you a few questions:</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L11/#3-tasks","title":"3 Tasks","text":""},{"location":"ECE482FA24/ECE482LAB/ECE482L11/#1-what-is-a-file-system","title":"1. What is a file system?","text":"<p>In Operating System, File System (FS) is a data structure system to form and manage data inside storage devices like SSD or HDD. FS could decide storage method and accessibility. Main functions of FS include:</p> <ul> <li>File and directory management</li> <li>Storage space allocation and deallocation</li> <li>Data integrity and security</li> </ul>"},{"location":"ECE482FA24/ECE482LAB/ECE482L11/#2-how-is-the-linux-vfs-working","title":"2. How is the Linux VFS working?","text":"<p>Linux Virtual File System (VFS) is located with kernel as abstraction layer. It could provide common interface for different FS. This let interaction of OS and several file systems in standard process. VFS is composed of followings including:</p> <ul> <li><code>superblock</code> - FS instance</li> <li><code>inode</code> - File metadata</li> <li><code>dentry</code> - Directory entries for file paths</li> </ul> <p>VFS will translate all system calls including <code>open</code>, <code>read</code>, <code>write</code> to operations.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L11/#3-what-is-fuse-and-how-does-it-interact-with-the-vfs-can-you-sketch-it-quickly-to-make-it-clearer","title":"3. What is FUSE, and how does it interact with the VFS? Can you sketch it quickly to make it clearer?","text":"<p>Filesystem in Userspace (FUSE) framework let software development process to apply file systems in user space rather than kernel space. FUSE could simplify complicated system so that potential risk of kernel crash is much more unlikely. FUSE will help interaction between user space FS and kernel.</p> <p>As you patiently explain her the high level ideas without going into any technical detail, you realise that porting Dadfs to FUSE would still be a pretty tough task. You do not really want to give up, but rather want some easier training, and maybe in a few weeks or months when things calm down at work you can come back to this task. In the meantime you try to find something easier to complete with FUSE. While you are lost in your thoughts you do not even realise that you are manipulating the mouse. Only when you see a window popping up you understand that you have clicked on an old icon. And here your are, connected to Lemonion Inc.!??!</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L11/#4-explain-what-is-sshfs","title":"4. Explain what is SSHFS.","text":"<p>Secure Shell Filesystem (SSHFS) is SSH protocol based file system client. In local file system, it is able to mount remote directories. Users will be able to interact with remote files like they are in local storage by using SSHFS.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L11/#5-use-sshfs-to-mount-your-home-on-lemonion-inc-server-in-your-computer","title":"5. Use SSHFS to mount your home on Lemonion Inc. server in your computer.","text":"<p>Install <code>sshfs</code></p> <pre><code>sudo apt install sshfs\n</code></pre> <p>Create directory path to mount</p> <pre><code>mkdir ~/RemoteHome\n</code></pre> <p>Mount remote directory</p> <pre><code>sshfs student_id@sjtu.edu.cn:\n</code></pre>"},{"location":"ECE482FA24/ECE482LAB/ECE482L11/#6-what-are-the-benefits-of-using-sshfs","title":"6. What are the benefits of using SSHFS?","text":"<p>SSH encrypted data transfer ensures security. It is easily portable for all SSH installed systems. Also, remote file access by small laptop without direct access to server.</p> <p>It seems they forgot to close up your account and revoke your key??While you have nothing harmful in mind you navigate on Lemonion server and in the lemondb folder you discover the existence of a hidden folder called .del. Surprisingly it belongs to Mr. Frown and is dated from the night of the crash! Has Mr. Frown anything to do with that crash? You remember that it was officially due to a high number of transactions, but this looks highly suspicious??</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L2/","title":"Lab 02","text":"<p>ECE4820 FA2024 Introduction to Operating Systems</p> <p>518370990004 Jae Heung Park</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L2/#exercise-1-project-1-presentations-part-1","title":"Exercise 1 Project 1: presentations (part 1)","text":"<p>Our Topic was Background Processing</p> <p>My teammate is Jin Lock Choi</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L2/#exercise-2-systems-setup","title":"Exercise 2 Systems setup","text":""},{"location":"ECE482FA24/ECE482LAB/ECE482L2/#21-linux-kernel-compilation","title":"2.1 Linux kernel compilation","text":"<p>??What is a kernel?</p> <p>Kernel is key concept in Operating System located between hardware and software. It manages computer resources including CPU, VGA, Memory, and Input/Output devices.</p> <p>??What basic tools are necessary to compile the Linux kernel?</p> <p>Linux kernel is compiled by GCC, GNU Compiler Collection to build. Git and GNU make are also necessary.</p> <p>??List all the commands necessary to compile the kernel.</p> <pre><code>wget -v https://git.kernel.org/pub/scm/linux/kernel/git/tj/sched_ext.git/snapshot/sched_ext-for-6.11.tar.gz\ntar -zxvf sched_ext-for-6.11.tar.gz\ncd sched_ext-for-6.11\n\ncp /boot/config-$(uname -r) .config\nscripts/config --disable SYSTEM_TRUSTED_KEYS\nscripts/config --disable SYSTEM_REVOCATION_KEYS\nmake CC=clang menuconfig\n\nnano .config # OR simply change in editor\n\nmake CC=clang -j$(nproc)\n\nsudo make modules_install\nsudo make install\n\nsudo reboot\n</code></pre> <p>??Why is it recommended to start with the Linux config file from your distribution?</p> <p>Linux .config file is very long with about over 10,000 lines. Copying configuration file will be wiser.</p> <p>??Compile the kernel. How long did it take?</p> <p>After several failure and VMWare Fusion setup change, it took about 30 minutes to compile the downloaded kernel. This time consumption can be changed by several factors.</p> <p>??Why is code quality so critical at the kernel level?</p> <p>In OS kernel, tiny code bug or memory leak may cause catastrophic result in the entire operating system.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L2/#22-software-development","title":"2.2 Software Development","text":"<p>??Briefly explain what is CI/CD.</p> <p>CI/CD, Continuous Integration / Continuous Delivery. CI stands for continuous integration of several programmers contributing to the shared repo. CD stands for continuous delivery of programming software automizing the entire process of project build, test, and deployment. Cooperation with multiple software engineers in enterprise level should consider development process of CI/CD to operate efficiently.</p> <p>??Why is having a consistent coding style important in industry?</p> <p>Consistent coding style is important in industry for several reasons including Unified convention to quickly read and review other's code, relatively convenient maintenance of CI/CD, contributing to reduce code analysis time and debugging.</p> <p>??What is the benefit of sanitizers?</p> <p>Sanitizers could detect unexpected processes or bugs. Automized code quality and automatic debugging increases platform compatibility and bug logs. It is relatively safer in memory leaks too.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L2/#exercise-3-remote-work","title":"Exercise 3 Remote work","text":"<p>As system administrators seldom have a physical access to their servers they remotely connect using a tool called Secure SHell (SSH). It allows them to log into a remote server and launch a regular shell, while keeping all the network traffic encrypted.</p> <p>??Setup an SSH server on Linux VM. From Linux (using ssh) or Windows (using Putty) log into it. Note: the network need to be properly setup on the VM (bridge mode recommended).</p> <p>Install SSH server and run it</p> <pre><code>sudo apt update\nsudo apt install openssh-server\nsudo systemctl start ssh\nsudo systemctl enable ssh\n</code></pre> <p>Log in into your linux virtual machine</p> <p>??What is the default SSH port? Change this port for port 2222. Log into your Linux VM using this new SSH server setup.</p> <pre><code>sudo nano /etc/ssh/sshd_config\n</code></pre> <p>Change Port number</p> <pre><code>#Port 22\nPort 2222\n</code></pre> <pre><code>sudo systemctl restart ssh\nssh -p 2222 &lt;username&gt;@&lt;VM-IP-Address&gt;\n</code></pre> <p>??List and explain the role of each the file in the $HOME/.ssh directory. In $HOME/.ssh/config, create an entry for the Linux VM.</p> <p><code>$HOME/.ssh/authorized_keys</code> contains external public keys that can log in into server.</p> <p><code>$HOME/.ssh/id_rsa</code> contains private RSA key saved locally inside without external connection.</p> <p><code>$HOME/.ssh/id_rsa.pub</code> contains public RSA key shared with external servers.</p> <p><code>$HOME/.ssh/known_hosts</code> contains previously connected server host keys.</p> <p><code>$HOME/.ssh/config</code> contains configuration for local SSH.</p> <p>??Briefly explain how key-only authentication works in SSH. Generate an ed25519 key-pair on the host system and use it to log into the VM without a password.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L2/#exercise-4-basic-git","title":"Exercise 4 Basic git","text":"<p>Git is a very power version control system initially introduced to help in the development of the Linux kernel around 2005. It has since then become a widely used tool omnipresent in industry. It is therefore of a vital importance to be proficient at it in order to better prepare for your future career and create more internship opportunities.</p> <p>??Setup git on your computer, we will use it for the rest of the semester.</p> <pre><code>sudo apt install git\n</code></pre> <p>??Search the use of the following git commands:</p> <p>??<code>help</code> is display help information for git like <code>man</code> in linux</p> <p>??<code>init</code> initializes git repository in current folder, generating .git directory in current path.</p> <p>??<code>checkout</code> can switch branch or restore files. <code>git checkout branch_name</code> will change branch, and <code>git checkout -- file.cpp</code> will change file into last committed state.</p> <p>??<code>branch</code> can list, generate, or remove branches. Only <code>git branch</code> command lists all branches, <code>git branch new_branch_name</code> will make new name, and <code>git branch -d branch_name</code> will remove branch.</p> <p>??<code>push</code> will transfer local commit into remote repository.</p> <p>??<code>pull</code> will transfer remote repository data change into local branch.</p> <p>??<code>merge</code> will combine one branch into another branch. <code>git merge branch_name</code> will apply both changes of <code>branch_name</code> branch and currently working branch.</p> <p>??<code>add</code> means next commit will include added file. <code>git add .</code> will add all.</p> <p>??<code>diff</code> will list commits, branches, work trees.</p> <p>??<code>tag</code> will create reference for commit. For instance, version tag like <code>git tag v2.0</code> can be used.</p> <p>??<code>log</code> shows all commit record for current branch.</p> <p>??<code>fetch</code> will download files from remote repo. It is often used if remote repo has update.</p> <p>??<code>commit</code> will save changed status in a tree.</p> <p>??<code>clone</code> will download remote repo and create local repo by copying remote repo.</p> <p>??<code>reset</code> will get back all repo changes into certain commit.</p> <p>??Setup your git repository on Gitea.</p> <p>Follow and reproduce on your personal repository the demo from the TAs showing a common git workflow.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L2/#exercise-5-project-1-presentations-part-2","title":"Exercise 5 Project 1: presentations (part 2)","text":""},{"location":"ECE482FA24/ECE482LAB/ECE482L3/","title":"Lab 03","text":"<p>ECE4820 FA2024 Introduction to Operating Systems</p> <p>518370990004 Jae Heung Park</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L3/#1-project-1-presentations-part-2","title":"1 Project 1: presentations (part 2)","text":""},{"location":"ECE482FA24/ECE482LAB/ECE482L3/#2-source-code","title":"2 Source code","text":"<p>When joining an existing two aspects are critical. First it is very important to understand the general structure of the project while also getting familiar with the coding style of the other developers. Then when starting to code one wants to keep track of the changes, while also being able to export and import them in a simple fashion.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L3/#21-linux-kernel-walk-through","title":"2.1 Linux kernel walk-through","text":"<p>In order to be more effective when solving homework 2 exercise 2, pay attention on how the TAs use the tools presented in lab 1 in order to find their way in Linux kernel source code. Carefully listen to the explanations related to the structure of code and common C strategies you might (re)discover.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L3/#22-the-diff-and-patch-commands","title":"2.2 The <code>diff</code> and <code>patch</code> commands","text":"<p>When dealing with source code two main situations are likely to arise: (i) you want to share your changes with others, or (ii) you want to apply changed performed by someone else. Most of the time updates on source code concern few lines scattered over several files. Therefore instead of sharing all the files it is much more convenient to only specify which lines should be updated, and how. This is the role of the diff command. The patch command is used to apply the changes previously created with diff. Both diff and patch programs should already be installed in your OS.</p> <ul> <li>Read the man pages of <code>diff</code> and <code>patch</code></li> <li>Edit a file of your choice in /usr/src, e.g. add a comment to a file</li> <li>Using the diff command, create a patch corresponding to the above changes</li> <li>Retrieve your patch on your Linux system</li> <li>Apply your patch to the copy of /usr/src_orig on your Linux system</li> <li>Revert the patch</li> </ul>"},{"location":"ECE482FA24/ECE482LAB/ECE482L3/#read-the-man-pages-of-diff-and-patch","title":"Read the man pages of <code>diff</code> and <code>patch</code>","text":"<pre><code>man diff\n</code></pre> <pre><code>DIFF(1)                          User Commands                         DIFF(1)\n\nNAME\n       diff - compare files line by line\n\nSYNOPSIS\n       diff [OPTION]... FILES\n\nDESCRIPTION\n       Compare FILES line by line.\n       Mandatory  arguments  to  long  options are mandatory for short options\n       too.\n</code></pre> <p>Manual of <code>patch</code> is longer.</p> <pre><code>man patch\n</code></pre> <pre><code>PATCH(1)                    General Commands Manual                   PATCH(1)\n\nNAME\n       patch - apply a diff file to an original\n\nSYNOPSIS\n       patch [options] [originalfile [patchfile]]\n\n       but usually just\n\n       patch -pnum &lt;patchfile\n\nDESCRIPTION\n       patch takes a patch file patchfile containing a difference listing pro??\n       duced by the diff program and applies those differences to one or  more\n       original  files, producing patched versions.  Normally the patched ver??\n       sions are put in place of the originals.  Backups can be made; see  the\n       -b  or  --backup option.  The names of the files to be patched are usu??\n       ally taken from the patch file, but if there's  just  one  file  to  be\n       patched it can be specified on the command line as originalfile.\n\n       Upon startup, patch attempts to determine the type of the diff listing,\n       unless overruled by a -c (--context), -e (--ed), -n (--normal),  or  -u\n       (--unified)  option.  Context diffs (old-style, new-style, and unified)\n       and normal diffs are applied by the  patch  program  itself,  while  ed\n       diffs are simply fed to the ed(1) editor via a pipe.\n\n       patch  tries to skip any leading garbage, apply the diff, and then skip\n       any trailing garbage.  Thus you could feed an article or  message  con??\n       taining  a  diff  listing  to patch, and it should work.  If the entire\n       diff is indented by a consistent amount, if lines end in CRLF, or if  a\n       diff  is  encapsulated  one  or  more times by prepending \"- \" to lines\n       starting with \"-\" as specified by Internet RFC 934, this is taken  into\n       account.   After  removing  indenting or encapsulation, lines beginning\n       with # are ignored, as they are considered to be comments.\n\n        With context diffs, and to a lesser extent with normal diffs, patch can\n       detect  when the line numbers mentioned in the patch are incorrect, and\n       attempts to find the correct place to apply each hunk of the patch.  As\n       a first guess, it takes the line number mentioned for the hunk, plus or\n       minus any offset used in applying the previous hunk.  If  that  is  not\n       the correct place, patch scans both forwards and backwards for a set of\n       lines matching the context given in the hunk.  First patch looks for  a\n       place where all lines of the context match.  If no such place is found,\n       and it's a context diff, and the maximum fuzz factor is  set  to  1  or\n       more, then another scan takes place ignoring the first and last line of\n       context.  If that fails, and the maximum fuzz factor is  set  to  2  or\n       more,  the first two and last two lines of context are ignored, and an??\n       other scan is made.  (The default maximum fuzz factor is 2.)\n\n       Hunks with less prefix context  than  suffix  context  (after  applying\n       fuzz)  must  apply  at the start of the file if their first line number\n       is 1.  Hunks with more prefix context than suffix context (after apply??\n       ing fuzz) must apply at the end of the file.\n\n       If patch cannot find a place to install that hunk of the patch, it puts\n       the hunk out to a reject file, which normally is the name of the output\n       file  plus  a .rej suffix, or # if .rej would generate a file name that\n       is too long (if even appending the single character #  makes  the  file\n       name too long, then # replaces the file name's last character).\n\n       The  rejected hunk comes out in unified or context diff format.  If the\n       input was a normal diff, many of the contexts  are  simply  null.   The\n       line  numbers  on the hunks in the reject file may be different than in\n       the patch file: they reflect the approximate location patch thinks  the\n       failed hunks belong in the new file rather than the old one.\n\n       As  each  hunk is completed, you are told if the hunk failed, and if so\n       which line (in the new file) patch thought the hunk should go  on.   If\n       the  hunk  is installed at a different line from the line number speci??\n       fied in the diff, you are told the offset.  A single large  offset  may\n       indicate  that  a  hunk was installed in the wrong place.  You are also\n       told if a fuzz factor was used to make the match,  in  which  case  you\n       should  also be slightly suspicious.  If the --verbose option is given,\n       you are also told about hunks that match exactly.\n...\n</code></pre>"},{"location":"ECE482FA24/ECE482LAB/ECE482L3/#edit-a-file-of-your-choice-in-usrsrc-eg-add-a-comment-to-a-file","title":"Edit a file of your choice in <code>/usr/src</code>, e.g. add a comment to a file","text":"<p>First, make a backup for <code>usr/src</code></p> <pre><code>sudo cp -r /usr/src /usr/src_backup\n</code></pre> <p>Now edit file inside <code>/usr/src</code>.</p> <pre><code>jhpark@jhparkvm:/usr/src$ ls linux-headers-6.5.0-35-generic/\narch    Documentation  init      Kconfig   mm              samples   tools\nblock   drivers        io_uring  kernel    Module.symvers  scripts   ubuntu\ncerts   fs             ipc       lib       net             security  usr\ncrypto  include        Kbuild    Makefile  rust            sound     virt\n\njhpark@jhparkvm:/usr/src$ ls linux-hwe-6.5-headers-6.5.0-35/\narch    Documentation  init      Kconfig   mm       scripts   ubuntu\nblock   drivers        io_uring  kernel    net      security  usr\ncerts   fs             ipc       lib       rust     sound     virt\ncrypto  include        Kbuild    Makefile  samples  tools\n</code></pre> <p>I decided to add a comment to a Makefile.</p> <pre><code>sudo nano /usr/src/linux-headers-6.5.0-35-generic/Makefile\n# Test comment made by JH Park for ECE482\n</code></pre>"},{"location":"ECE482FA24/ECE482LAB/ECE482L3/#using-the-diff-command-create-a-patch-corresponding-to-the-above-changes","title":"Using the diff command, create a patch corresponding to the above changes","text":"<pre><code>sudo diff -u /usr/src/linux-headers-6.5.0-35-generic/Makefile /usr/src_backup/linux-headers-6.5.0-35-generic/Makefile &gt; jhpark_patch.patch\n</code></pre> <p>Patch created.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L3/#retrieve-your-patch-on-your-linux-system","title":"Retrieve your patch on your Linux system","text":"<p>Patch command updated the difference of code I added well.</p> <pre><code>cat jhpark_patch.patch\n</code></pre> <p>Patch comment updated.</p> <pre><code>--- /usr/src/linux-headers-6.5.0-35-generic/Makefile    2024-10-21 01:14:53.470376307 +0800\n+++ /usr/src_backup/linux-headers-6.5.0-35-generic/Makefile 2024-10-21 01:11:46.859876208 +0800\n@@ -1,4 +1,3 @@\n-# Test comment made by JH Park for ECE482\n # SPDX-License-Identifier: GPL-2.0\n VERSION = 6\n PATCHLEVEL = 5\n</code></pre>"},{"location":"ECE482FA24/ECE482LAB/ECE482L3/#apply-your-patch-to-the-copy-of-usrsrc_orig-on-your-linux-system","title":"Apply your patch to the copy of /usr/src_orig on your Linux system","text":"<p>I made backup branch name as <code>usr/src_backup</code> so copied again.</p> <pre><code>sudo cp -r /usr/src_backup /usr/src_orig\n</code></pre> <p>Now apply patch to newly created <code>usr/src_orig</code>.</p> <pre><code>sudo patch /usr/src_backup/linux-headers-6.5.0-35-generic/Makefile &lt; jhpark_patch.patch\n</code></pre> <p>Finally, check if change is applied.</p> <pre><code>head /usr/src/linux-headers-6.5.0-35-generic/Makefile\nhead /usr/src_orig/linux-headers-6.5.0-35-generic/Makefile\n</code></pre> <p>It is applied successfully.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L3/#revert-the-patch","title":"Revert the patch","text":"<p>Execute patch with revert option</p> <pre><code>sudo patch -R /usr/src_orig/linux-headers-6.5.0-35-generic/Makefile &lt; jhpark_patch.patch\n</code></pre>"},{"location":"ECE482FA24/ECE482LAB/ECE482L3/#23-basic-git-usage","title":"2.3 Basic <code>git</code> usage","text":"<p>The programs patch and diff are very useful however when big projects are managed by many people at the same time they are not convenient to handle. A more advanced, automatised approach is required such as to help solving collisions in a more simple way. For instance user A commits some changes on the initial version of the file foo.c. Then user B does the same. Notice that changes made by B may collide with updates from A. To prevent such issues B should have worked based on A?\uc172 version of the foo.c file.</p> <p>To overcome such kind of issues and render things smoother and easier several systems were created; at the moment the most commonly used is called git, older ones such as svn or cvs are still used in some places. In the remainder of this course you will be required to use the gitea in order to keep track of your project work.</p> <p>Go to http://learngitbranching.js.org/ and complete the following levels:</p> <ul> <li>Main ??Introduction Sequence: all;</li> <li>Main ??Ramping Up: all;</li> <li>Main ??A mixed bag: 1, 4;</li> <li>Remote ??Push &amp; Pull ??Git Remotes!: 1-4, 6;</li> </ul> <p></p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L3/#3-scripting-and-regular-expressions","title":"3 Scripting and regular expressions","text":"<p>Two programming languages often used in conjunction with Bash are <code>sed</code> and <code>awk</code>. Pipelining the output of ifconfig to awk return only the ip address of your current active network connection (the active network interface can be passed to ifconfig).</p> <p>Install network tools</p> <pre><code>sudo apt-get install net-tools\n</code></pre> <p>Ip check commands by <code>ifconfig</code> and <code>awk</code> is required.</p> <pre><code>ifconfig | awk '/inet / {print $2}'\n</code></pre> <p>Returns this ip address</p> <pre><code>172.16.43.132\n127.0.0.1\n</code></pre> <p>IP address from my Linux Ubuntu installed in VMWare fusion</p> <pre><code>127.0.0.1\n192.168.101.8\n0.0.1.1\n198.18.0.1\n192.168.100.1\n172.16.43.1\n</code></pre> <p>IP address from my Mac OS terminal.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L4/","title":"Lab 04","text":"<p>ECE4820 FA2024 Introduction to Operating Systems</p> <p>518370990004 Jae Heung Park</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L4/#exercise-1-database","title":"Exercise 1 Database","text":"<p>This is the evening, you are exhausted after a long day of work on mumsh. So you decide to poke around and learn more about database, as unfortunately you never had to opportunity to select such course during your studies.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L4/#11-database-creation","title":"1.1 Database creation","text":"<p>As a first step you need to find a database, you fire-up your web-browser. Unfortunately your internet is very slow today so you cannot get much information. But after a bit of thinking you realise that you still have a git version of the Linux kernel, and as you know everything about git you can easily generate logs from the git commits. To ensure a proper formatting you refer to git pretty format documentation page. So you open a terminal running mumsh and type a simple command line to test database generation.</p> <pre><code>mumsh $ git log --pretty=\"%H,%aN,%aI,%s\" &gt; db.csv\n</code></pre> <p>The goal being to get a basic introduction to database you only want to focus on basic queries, in particular you do not need a very complicated database and in the end only generating two csv files1 containing the following fields is enough.</p> <p>Fields for timestamp.csv:</p> <ul> <li>Hash of the commit</li> <li>Author name</li> <li>Author date, strict ISO 8601 format</li> <li>Author date, UNIX timestamp</li> </ul> <p>Fields for db.csv:</p> <ul> <li>Hash of the commit</li> <li>Author name</li> <li>Subject</li> </ul> <p>Enter command in the project 1 git repository folder to generate log of git commits. To proceed the following assignment, it is necessary to get the git repository of the Linux.</p> <pre><code>cd cd /path/to/p1\ngit log --pretty=\"%H,%aN,%aI,%s\" &gt; commits.csv\ncd /path/to/l4\n</code></pre> <ul> <li>%H: Hash of the commit</li> <li>%aN: Author name</li> <li>%aI: Author date (strict ISO 8601)</li> <li>%s: Subject</li> </ul> <p>Enter command in the project 1 git repository folder to generate log of timestamp</p> <pre><code>awk -F',' '{ print $1 \",\" $2 \",\" $4 }' commits.csv &gt; db.csv\nawk -F',' '{ cmd = \"date -d \\\"\" $3 \"\\\" +%s\"; cmd | getline unix_time; close(cmd); print $1 \",\" $2 \",\" $3 \",\" unix_time }' commits.csv &gt; timestamp.csv\n</code></pre>"},{"location":"ECE482FA24/ECE482LAB/ECE482L4/#12-database-system-installation","title":"1.2 Database system installation","text":"<p>As you want to ensure your understanding and guesses are correct you need to verify a few things online. Luckily your network seems back to normal, so you can use a proper search engine and ensure the correctness of what you found.</p> <ul> <li>What are the most common database systems?</li> <li>Briefly list the pros and cons of the three most common ones.</li> </ul> <p>There are several common database systems used in industry.</p> <p>PostgreSQL, MySQL, SQLite, MongoDB, Redis, Oracle, Microsoft SQL Server, Apache Cassandra, etc.</p> <p>Ignoring enterprise DB systems like Oracle, Microsoft SQL Server, or AWS servers, and specialized database system like Redis used for quick access or Apache Cassandra for data engineering, PostgreSQL, MySQL, and MongoDB are most commonly used in general software development. SQLite is used widely too, but it is mostly for learning level or small scale projects,</p> <p><code>MySQL</code> is RDBMS (Relational Database Management System) commonly used for Web applications.</p> <p>Pros of MySQL</p> <ul> <li>Fast performance in reading heavy workload</li> <li>Setup is relatively easy with various versions including both open source and enterprise</li> <li>High popularity, several extensions and libraries, more data to search and debug</li> </ul> <p>Cons of MySQL</p> <ul> <li>Not enough advanced functions like no full text search</li> <li>Relatively poor flexibility to build complicated relational DB</li> <li>ACID (Atomicity, Consistency, Isolation, Durability) support is not good</li> </ul> <p><code>PostgreSQL</code> is also RDBMS but used for more complex queries and extensible system.</p> <p>Pros of PostgreSQL</p> <ul> <li>Supports custom data types, functions, and operators, so great extensibility</li> <li>Supports advanced SQL features (like full-text search, CTEs, JSONB).</li> <li>ACID-compliant, ensuring data integrity.</li> <li>Open-source with a strong community.</li> </ul> <p>Cons of PostgreSQL</p> <ul> <li>Requires setup for optimal performance for complicated datasets.</li> <li>Relatively more complex to set up and manage database systems compared to other DB systems.</li> <li>If not optimized, it is slower than some NoSQL databases for heavy operations.</li> </ul> <p><code>MongoDB</code> is NoSQL (Non-RDB), or Document Database since it does not save data in table form.</p> <p>Pros of MongoDB</p> <ul> <li>Manage unstructured data efficiently</li> <li>Horizontal scaling, or sharding, let easy access in server system</li> <li>Supports JSON similar documents</li> <li>Efficient for Agile development with quickly changing database schema</li> </ul> <p>Cons of MongoDB</p> <ul> <li>No ACID consideration in default, nowadays better but still poor compared to RDBMS</li> <li>Compared to SQL, Query is relatively not efficient</li> <li>Inefficient data structure require more memory and storage than RDB</li> </ul>"},{"location":"ECE482FA24/ECE482LAB/ECE482L4/#after-completing-your-reading-you-decide-to-install-sqlite-on-your-linux-system","title":"After completing your reading you decide to install SQLite on your Linux system.","text":"<p>The next step is now to import your git database into two tables.</p> <ul> <li>Create an empty SQLite database.</li> <li>Use the SQLite shell to prepare two empty tables for each of your .csv file.</li> <li>Import each .csv file in its corresponding SQLite table.</li> </ul> <p>In macOS, install SQLite by <code>brew</code>. Use other command for Linux.</p> <pre><code>brew intall sqlite3 # macOS\nsudo apt update &amp;&amp; sudo apt install sqlite3 # Linux or WSL\n</code></pre> <p>Then, create new database</p> <pre><code>sqlite3 l4.db\n</code></pre> <p>Based on the csv files generated in previous exercise, create two database tables.</p> <pre><code>CREATE TABLE db\n(\n    hash TEXT NOT NULL PRIMARY KEY,\n    name TEXT NOT NULL,\n    comment TEXT NOT NULL\n);\n\nCREATE TABLE timestamp\n(\n    hash TEXT NOT NULL,\n    name TEXT NOT NULL,\n    date TEXT,\n    stamp INT\n);\n\n.QUIT\n</code></pre> <p>Now, import <code>db.csv</code> and <code>timestamp.csv</code> for each SQLite table.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L4/#13-database-queries","title":"1.3 Database queries","text":"<p>At this stage you want to run basic queries to verify that the database has been imported correctly. Therefore, you spend the rest of the evening playing around the database and running queries.</p> <ul> <li>Who are the top five contributors to the Linux kernel since the beginning?</li> <li>Who are the top five contributors to the Linux kernel for each year over the past five years?</li> <li>What is the most common ?\uc401ommit subject??</li> <li>On which day is the number of commits the highest?</li> <li>Determine the average time between two commits for the five main contributors.</li> </ul> <p>First, generate SQLite database and import generated csv files</p> <pre><code>sqlite3 lab4.db\n</code></pre> <p>Create database schema</p> <pre><code>CREATE TABLE db (\n    hash TEXT NOT NULL PRIMARY KEY,\n    name TEXT NOT NULL,\n    comment TEXT NOT NULL\n);\n\nCREATE TABLE timestamp (\n    hash TEXT NOT NULL PRIMARY KEY,\n    name TEXT NOT NULL,\n    date TEXT,\n    stamp INT\n);\n\n.separator \"|\"\n.import db.psv db\n.import timestamp.psv timestamp\n</code></pre> <p>Now ready to run SQL Queries.</p> <p>Who are the top five contributors to the Linux kernel since the beginning?</p> <pre><code>SELECT name, count(*)\nFROM timestamp\nGROUP BY name\nORDER BY count(*) DESC\nLIMIT 5;\n</code></pre> <p>Returns</p> <pre><code>Linus Torvalds|30702\nDavid S. Miller|13180\nTakashi Iwai|7726\nMark Brown|7670\nArnd Bergmann|7520\n</code></pre> <p>Who are the top five contributors to the Linux kernel for each year over the past five years?</p> <pre><code>SELECT name, COUNT(name) AS count\nFROM timestamp\nWHERE strftime('%Y', datetime(stamp, 'unixepoch')) = '2020'\nGROUP BY name\nORDER BY count DESC\nLIMIT 5;\n</code></pre> <p>Since data is not available after 2020, query ran from 2016 to 2020</p> <p>Year 2020</p> <pre><code>Linus Torvalds|1886\nDavid S. Miller|924\nChristoph Hellwig|806\nMauro Carvalho Chehab|770\nChris Wilson|644\n</code></pre> <p>Year 2019</p> <pre><code>Linus Torvalds|2386\nDavid S. Miller|1206\nChris Wilson|1173\nYueHaibing|930\nChristoph Hellwig|911\n</code></pre> <p>Year 2018</p> <pre><code>Linus Torvalds|2168\nDavid S. Miller|1405\nArnd Bergmann|922\nChristoph Hellwig|818\nColin Ian King|798\n</code></pre> <p>Year 2017</p> <pre><code>Linus Torvalds|2303\nDavid S. Miller|1420\nArnd Bergmann|1123\nChris Wilson|1028\nArvind Yadav|827\n</code></pre> <p>Year 2016</p> <pre><code>Linus Torvalds|2273\nArnd Bergmann|1185\nDavid S. Miller|1150\nChris Wilson|992\nMauro Carvalho Chehab|975\n</code></pre> <p>What is the most common ?\uc401ommit subject??</p> <pre><code>SELECT comment, COUNT(name) AS count\nFROM db\nGROUP BY comment\nORDER BY count DESC LIMIT 1;\n</code></pre> <p>Most coommon commit subject was</p> <pre><code>Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net|670\n</code></pre> <p>On which day is the number of commits the highest?</p> <pre><code>SELECT  date(date) AS day, COUNT(name) AS count\nFROM timestamp\nGROUP BY day\nORDER BY count DESC\nLIMIT 3;\n</code></pre> <p>The day with highest commits is 2008 January 30th with 1031 commits</p> <pre><code>2008-01-30|1031\n2006-12-07|683\n2007-05-08|649\n</code></pre> <p>Determine the average time between two commits for the five main contributors.</p> <p>This query structure is quite challenging with more complex logic. Make <code>time_diffs</code> value, <code>LAG(stamp)</code> function retrieve data from previous commit. For compromised calculation due to no previous data, prevent collision by <code>WHERE time_diff IS NOT NULL</code>.</p> <pre><code>WITH time_diffs AS (\n    SELECT\n        name,\n        (stamp - LAG(stamp) OVER (PARTITION BY name ORDER BY stamp)) AS time_diff\n    FROM timestamp\n)\nSELECT name,\n       AVG(time_diff) AS avg_time_between_commits\nFROM time_diffs\nWHERE time_diff IS NOT NULL\nGROUP BY name\nORDER BY COUNT(name) DESC\nLIMIT 5;\n</code></pre> <p>This returns following, in seconds unit.</p> <pre><code>Linus Torvalds|15880.6766554835     #  4.4 Hours\nDavid S. Miller|36956.1432582138    # 10.3 Hours\nTakashi Iwai|63301.1109385113       # 17.5 Hours\nMark Brown|59933.2400573738         # 16.7 Hours\nArnd Bergmann|63807.0030589174      # 17.6 Hours\n</code></pre>"},{"location":"ECE482FA24/ECE482LAB/ECE482L4/#exercise-2-debugging","title":"Exercise 2 Debugging","text":"<p>You are pretty happy and enjoying the database tasks when your mum pops in your room. She looks pretty upset that you are still not asleep as she thinks you were playing video games?? When you explain her to that you have terrible bugs in your shell and needed a bit of change, she asked you whether you had used GDB. As you replied ?\uc3dean I eat it???she realises you probably do not know much about it. She kindly tells you to have a quick try at it on your current mumsh version to preview it. This should become very handy if you ever have to work on a large scale project.</p> <ol> <li>How to enable built-in debugging in <code>gcc</code>?</li> <li>What is the meaning of GDB?</li> <li>Compile the master branch of you mumsh with debugging enabled.</li> </ol>"},{"location":"ECE482FA24/ECE482LAB/ECE482L4/#201-how-to-enable-built-in-debugging-in-gcc","title":"2.0.1 How to enable built-in debugging in <code>gcc</code>?","text":"<pre><code>gcc -g -o main main.c util.c\ngdb ./main\n</code></pre>"},{"location":"ECE482FA24/ECE482LAB/ECE482L4/#202-what-is-the-meaning-of-gdb","title":"2.0.2 What is the meaning of GDB?","text":"<p>GDB stands for GNU Debugger.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L4/#203-compile-the-master-branch-of-you-mumsh-with-debugging-enabled","title":"2.0.3 Compile the master branch of you mumsh with debugging enabled.","text":"<pre><code>clang-18 -std=gnu17 -O2 -Wall -Wextra -Werror -pedantic -Wno-unused-result -Wconversion -Wvla main.c utils.c mumsh.c init.c -o mumsh\ngdb ./mumsh\n</code></pre>"},{"location":"ECE482FA24/ECE482LAB/ECE482L4/#21-basic-gdb-usage","title":"2.1 Basic GDB usage","text":"<ol> <li>Find the homepage of the GDB project.</li> <li>What languages are supported by</li> </ol>"},{"location":"ECE482FA24/ECE482LAB/ECE482L4/#211-find-the-homepage-of-the-gdb-project","title":"2.1.1 Find the homepage of the GDB project.","text":"<p>GDB: The GNU Project Debugger</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L4/#212-what-languages-are-supported-by-gdb","title":"2.1.2 What languages are supported by GDB?","text":"<ul> <li>Ada</li> <li>Assembly</li> <li>C</li> <li>C++</li> <li>D</li> <li>Fortran</li> <li>Go</li> <li>Objective-C</li> <li>OpenCL</li> <li>Modula-2</li> <li>Pascal</li> <li>Rust</li> </ul> <p>These programming languages are supported by GDB.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L5/","title":"Lab 05","text":"<p>ECE4820 FA2024 Introduction to Operating Systems</p> <p>518370990004 Jae Heung Park</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L5/#1-project-2-presentations-part-1","title":"1 Project 2: presentations (part 1)","text":"<p>To ensure a more synchronised support during project 2, presentations are split into two parts. Topics are available on Canvas and their selection is on a first come first served basis. Please well prepare your presentation and ask questions on others??research. This should greatly help in the development of your Database system. Be careful, Mr. Frown might be listening!</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L5/#2-layer-programming","title":"2 Layer programming","text":"<p>When writing code one of the most important goal is flexibility. In particular it should be possible to alter part of the program without having to rewrite everything. For instance in the case of a music player the part of the code in charge of opening a file, decoding it, and sending it to the sound card should be totally independent from the Graphical User Interface (GUI). If this is not the case, changing the toolkit used to build the GUI will impact the core functionalities of the program, leading to a complete rewriting of the software. On the other hand if the various components are developed with layers in mind, the GUI will be implemented as top layer such that altering it will not impact the lower layers in charge of the player?\uc172 core functionalities.</p> <p>Basic principles in layer programming:</p> <ul> <li>A function may not call a function from any higher layer;</li> <li>A function can only issue calls to functions from a same or a lower layer.</li> </ul> <p>We now refer to exercise 2 from homework 3 as an example on how to write code using layers.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L5/#the-program-can-be-divided-into-three-layers-what-are-they","title":"The program can be divided into three layers, what are they?","text":"<p>Since it is layer of function, it is supposed to be structural rather than function based division composed of read, sort, write.</p> <p>Core Data Structure Layer includes linked list structure including generation, node memory allocation, free, list insertion, and other functions.</p> <p>Application Function Logic Layer will include acquisition of data type, sorting type, value search, etc. Sorting list will be categorized as close to data structure though.</p> <p>User Interface Layer handles Input Output redirection of the code, parsing input file and arguments and generating output text file. These are the most external layer, so related codes will be in <code>main.c</code>.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L5/#programming-part","title":"Programming part","text":"<ul> <li>Create the appropriate corresponding header files.</li> <li>If necessary rewrite functions such that no call is emitted from lower level functions to upper level   functions.</li> <li>The initial program implements a command line interface, write a ?\uc3eeenu interface??which (i) welcomes the user, (ii) prompts him for some task to perform, and (iii) runs it. When a task is   completed the user should (i) be informed if it was successful and then (ii) be displayed the menu.   From the menu he should be able to exit the program.</li> <li>Write two main functions, one which will ?\uc402ispatch??the work to another function which will run   the command line user interface and a second one which will ?\uc402ispatch??the work to the Menu user   interface.</li> </ul> <p>Codes in <code>ex2</code> folder.</p> <p>Core data structure including node and list are inside <code>list.c</code> file. Application function including read sort write are inside <code>util.c</code> file. User interface layer is <code>main.c</code> file that could be implemented further.</p> <pre><code>clang-18 -std=gnu17 -O2 -Wall -Wextra -Werror -pedantic -Wno-unused-result -Wconversion -Wvla main.c list.c util.c -o ex2\n./ex2\n</code></pre> <p>Compiled successfully.</p> <p>The initial program implements a command line interface, write a ?\uc3eeenu interface??which (i) welcomes the user, (ii) prompts him for some task to perform, and (iii) runs it. When a task is completed the user should (i) be informed if it was successful and then (ii) be displayed the menu. From the menu he should be able to exit the program.</p> <p>Write two main functions,</p> <p>one which will ?\uc402ispatch??the work to another function which will run the command line user interface and a second one which will ?\uc402ispatch??the work to the Menu user interface.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L5/#3-libraries","title":"3 Libraries","text":"<p>In order to understand libraries we first recall a few basics on compilation.</p> <ul> <li>What are the four stages performed when compiling a file?</li> <li>Briefly describe each of them.</li> </ul> <p>Four stages</p> <ol> <li><code>Preprocess</code> handles macros and directives including <code>#include</code>, <code>#define</code>, and <code>#ifdef</code>.</li> <li><code>Compile</code> macro handle code is compiled and translated to assembly code file like <code>.s</code> file.</li> <li><code>Assembly</code> code generated will be converted to machine code like object file like <code>.o</code> or <code>obj</code> file.</li> <li><code>Link</code> will combine every object files created from assembly step into executable file like ELF file for UNIX system.</li> </ol> <p>A library is a collection of functions, data types, constants, etc. which are put together. When compiling, the machine code corresponding to those elements is generated. Two types of libraries exist: static and dynamic. Explain the difference between the two. Generating a static library is a simple process: collect several functions and pack them into an ar archive.</p> <ul> <li>Search more details on how to proceed.</li> <li>Create two static libraries, one for each of the two lowest layers in the previous program.</li> <li>Compile the command line version of the program using these two static libraries.</li> </ul> <p>A <code>static</code> library that typically start with <code>.a</code> on UNIX and <code>.lib</code> on Windows OS contains code directly link and compile code to execute during linking stage of file compile. These static libraries are embedded into computer system, so there is no reason to use external libraries, but more static library in Os means larger system file size, since library code will be duplicated per program using them.</p> <p>A <code>dynamic</code> library that typically start with <code>.so</code> on UNIX or <code>.dll</code> in Windows OS contains code that are loaded in linking stage of runtime instead of compile time. Since they have dynamic libraries, several programs could share same dynamic libraries without duplication. This reduces memory usage and disk space, but instead existence of dynamic libraries should be guaranteed.</p> <p>Generating shared, or dynamic, libraries is a slightly more complex process. Since the library is to be shared among various programs none of them can rely on a predefined location where to find the functions in the memory. Therefore, as the library has to store its information at different memory addresses it is compiled into a Position-Independent Code (PIC). This is achieved by running gcc with the flag -fpic. Then in order to effectively create the dynamic library, gcc has to be re-run with the flag -shared.</p> <ul> <li>Generate two dynamic libraries, one for each of the two lowest layers in the previous program.</li> <li>Compile the whole program</li> <li>Compile the Menu version of the program using these two dynamic libraries.</li> </ul> <p>Two lowest layers</p> <p>A few extra remarks:</p> <ul> <li>What is the difference between a library and the API.</li> <li>Implement the API below for the two libraries.</li> <li>Test on JOJ using &gt; git commit -m\"joj.l5\" .</li> </ul> <p>A <code>Library</code> is all codes compiled for program execution including function, datatype, etc. They are reusable for several programs, so resources will be reduced compared to embedded code.</p> <p>An <code>API</code> stands for Application Programming Interface. It can select methods and rules of functions and processes to be called. The API will act as some form of code interface for programmers.</p> <pre><code>clang-18 -std=gnu17 -O2 -Wall -Wextra -Werror -pedantic -Wno-unused-result -Wconversion -Wvla lab5_dlist.c -o ex3\n./ex3\ngit add .\ngit commit --allow-empty -m \"test(l5): joj\"\ngit push\n</code></pre>"},{"location":"ECE482FA24/ECE482LAB/ECE482L6/","title":"Lab 06","text":"<p>ECE4820 FA2024 Introduction to Operating Systems</p> <p>518370990004 Jae Heung Park</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L6/#project-2-presentations-part-2","title":"Project 2: presentations (part 2)","text":"<p>Presentation Part 2</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L6/#plugin-based-software-development","title":"Plugin based software development","text":"<p>While layer programming is very important and useful to keep the code clean and well organised, the introduction of a plugin structure can greatly enhance and ease the software development process. From a simplified informal point of view a plugin can be seen as a small piece of software that can be loaded to extend or bring in new features to a host application. For this to work, the host software must expose a plugin API. Then plugins can be develop independently from each others or the main application, i.e. the core software does not need them to compile and run properly. Plugins can hence be implemented following the plugin API, be compiled as shared libraries, and loaded at startup or even at run-time by the host software.</p> <p>For instance if developing a music player one might want to introduce plugins to play various file types such as mp3, ogg, and flac. In such a case one will want to have a generic play_file() function which would redirect the job to an appropriate function, for example play_mp3(), or play_ogg() depending on the file type. Of course if a file type is not supported, e.g. play_flac() does not exist, the program should not crash but simply report that this file type is not supported. In particular this shows the necessity for each plugin to register itself and present some meta-information about itself to the main program.</p> <p>One also notices that some functions can be defined as mandatory and others as optional. For instance a flac music player plugin which does not have a play_flac() function should not be loaded, since this function is mandatory to play a flac file. However some other functions such as read_id3_flac(), which reads the id3 tag of a flac file, is not mandatory to play a file, so one can easily think of making it optional. Hence this function should being missing should not prevent the plugin to load. In a slightly more formal way the concept of plugin architecture splits into four sub-concepts:</p> <p>Discovering: mechanisms allowing the host application to discover all available plugins; Usually plugins are found in a specific folders, e.g. /usr/lib/application_name/plugins/, or $HOME/.local/share/ application_name/plugins;</p> <p>Registering: mechanisms allowing the host application to potentially accept and register the discovered plugins; At this stage a plugin announces its features, version, and any other information necessary to the well functioning of the application;</p> <p>Note: in practice discovering and registration and often performed at the same time. Hooking: sometimes called mount points or extension points, applications hooks can be seen as the core of the plugin manager; They allow the plugin to ?\uc3ffttach??itself to the application; Hence the core application can get control over the plugin;</p> <p>Exposing: the core application should also expose an API to plugins such that they can call some of its functions; Evidently, not all functions from the core application should be accessible, cf. layer programming; The set of such functions can be seen as the part of the plugin manager API that is exposed to the plugins;</p> <p>Note: it is possible, and even common, to have a plugin architectures allowing to write plugins in a different language than the core application. For instance if the core application is written in C, plugins do not necessarily require to be developed in C, other languages such as Python or Lua can be used. Of course this requires more work on the plugin architecture design; This is not covered in this lab.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L6/#plugin-architecture-design","title":"Plugin Architecture Design","text":"<p>File input output process plugin should be divided into three large components.</p> <ol> <li><code>open_fi le()</code> will open file and verify its format.</li> <li><code>process_file()</code> will read file data according to its type.</li> <li><code>close_file()</code> will close file and clean up resources.</li> </ol>"},{"location":"ECE482FA24/ECE482LAB/ECE482L6/#main-application-refactor","title":"Main Application Refactor","text":"<ol> <li>Plugin loads all available plugins from folder</li> <li>Plugin will register supported file types for application</li> <li>Plugin will replace current file opening code to function based on extension or identifier.</li> </ol>"},{"location":"ECE482FA24/ECE482LAB/ECE482L6/#opening-processing-text-files","title":"Opening &amp; Processing Text Files","text":"<p>Create text file plugin that adhere to FilePlugin interface. This plugin can manage text files by processing each line. Sample code draft structure in <code>ex2.h</code></p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L6/#3-designing-a-plugin-architecture","title":"3 Designing a plugin architecture","text":"<p>We now want to add a plugin infrastructure to exercise 2 of homework 3, based on the API defined in lab 5. In the initial exercise a text file only contains one type of data, e.g. increasing integers. Lets say that we now want our file to be in csv format, with each column containing a different type of data. For instance a file could look like.</p> <pre><code>rand_int,rand_double,inc_char*\nabc=123,bfc=43.5786,aa=cat\nasda=54,sdfs=654.1,poi=dog\npoqq=3,qa=0.12313,qkm=fish\n</code></pre> <p>Based on the rewritten implementation using the layer programming API:</p> <ul> <li>Design a plugin architecture allowing to open various file-types.</li> <li>Refactor the code of the main application such that opening a text file becomes part of a plugin.</li> <li>Adjust the code such that text files can opened and processed.</li> <li>Write the skeleton of a plugin to open and process csv files.</li> </ul> <p>Skeleton code written in <code>ex3.h</code></p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L7/","title":"Lab 07","text":"<p>ECE4820 FA2024 Introduction to Operating Systems</p> <p>518370990004 Jae Heung Park</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L7/#1-project-2-presentations-part-3","title":"1 Project 2: presentations (part 3)","text":""},{"location":"ECE482FA24/ECE482LAB/ECE482L7/#2-introduction","title":"2 Introduction","text":"<p>Finally, the weekend is here. Things start to be a bit tense at work with Mr. Frown who is always on your back. It feels that things have worsened over the past few days, but you have no idea what could be the problem. In this context a bit of time out with your friend Bob will definitely be much refreshing. When you arrive at The Geeks??Tavern on Friday night, Bob is already seating at the counter sipping a beer. His mood is the total opposite of yours, while you feel disheartened and dejected, Bob seems to be floating in happiness. As soon as he notices you, he walks to you and warmly hugs you. Before you can say anything he announces: ?\uc3fdou know what? I found the perfect job!?? As you silently listens to how great and open his new company is, you cannot stop thinking of your own situation with Mr. Frown. Why on earth did Bob find the perfect job and you are stuck at Lemonion Inc.? You had better grades than him, so why him, not you? Bob is your friend but sharing his joy is not that simple??As he notices your unusual attitude he inquires about your own situation. An uncontrollable flow of words comes out of our mouth, explaining how mean Mr. Frown is and how unrewarding your job is. Bob tries his best to comfort and encourage you, you can even feel some flattery in his words. While you are thankful for his kindness and empathy, you still would like to have a job like his. Unfortunately his line of work is slightly different from what you are used to and more directly related to Operating Systems. He however promises to let you know as soon as he hear of an opening in his perfect company, CoolZone IT solutions. Reinvigorated by Bob?\uc172 words and encouragements, this is with a light heart that you join your parents for Saturday lunch. You just want to relax and enjoy their company. As the discussion shifts to your work at Lemonion Inc. you quickly summarise the current situation and emphasise your desire to do your utmost to keep your job, despite Mr. Frown?\uc172 abuses. As your parents look concerned you tell them that Bob might be able to help you find a better job, but you first need to refresh your memory on Operating Systems. The only good side is that although you have been here for already a couple of hours they have not yet asked you when you will buy a flat and get married??Just as this idea draws a smile on your face, your dad appears in the kitchen and orders you to stop drying up the dishes: he has something to show you. A few years back he started a personal project to learn a bit more about filesystems. He designed a very basic and simple inode-based filesystem for the Linux Operating System, and he suggests that you work on it. Your dad seems very excited by the possibility to work with you and help you getting ready for a prospective position at CoolZone IT solutions.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L7/#3-fixing-dadfs","title":"3 Fixing Dadfs","text":"<p>As you arrive in front of the computer your dad connects to his git server and pull a repository called dadfs. He tells you to start by reading the README file and follow the instructions to compile the code. Unfortunately the code appears to be too old to compile with a new kernel. While you feel disappointed, your father just says ?\uc3e5reat!?? As you gaze at him wondering why the module not compiling is a good news he goes into a great length of explanation on why this is a perfect exercise. You have rarely seen him so excited, even your mum comes wondering what is happening! From what you understand this is a perfect exercise to understand the structure of the code, how the kernel works, what a module is, how to write backward compatible code, etc. It feels like the benefits are endless. So without any further ado you grab the keyboard and start working, although this feels awkward having both your parents in your back commenting your decisions as if you were still in grade 1. To guide you in your work you dad asks you a few initial questions:</p> <p>1. What is a kernel module, and how does it differ from a regular library?</p> <p>The <code>Kernel module</code> code files let Linux kernel to be loaded so that linux kernel can use more functions without system reboot. Kernel could directly handle OS and hardware, including FS(File Systems), networks, or driers. On the other hand, <code>Regular Libraries</code> collect all precompiled functions and routines linked to user space. Libraries are not loaded in kernel space, but in user space. Thus, libraries are not able to access OS or hardware.</p> <p>2. How to compile a kernel module? Before going for his nap your father reminds you of the importance of backward compatibility: ?\uc3e3ven if you code compiles with a new kernel, it should still compile on an old one, so do not delete all my work!?? In a last encouragement before he leaves he blinks his right eye and smile at you before disappearing in the corridor. As you are left along with the code you decide to investigate it further and look at all the details of this first Linux kernel source code. After a quick search on internet it appears that the kernel API has changed since the initial code was written.</p> <p>Step 0 Install Kernel Headers, if not installed</p> <pre><code>sudo apt-get install linux-headers-$(uname -r)\n</code></pre> <p>Step 1 Write MakeFile. Example is below</p> <pre><code>obj-m := dadfs.o\nKDIR := /lib/modules/$(shell uname -r)/build\nPWD := $(shell pwd)\n\nall:\n    $(MAKE) -C $(KDIR) M=$(PWD) modules\n\nclean:\n    $(MAKE) -C $(KDIR) M=$(PWD) clean\n</code></pre> <p>Step 2 Compile module by <code>make</code> command</p> <pre><code>make\n</code></pre> <p>Step 3 Insert and Load module</p> <pre><code>sudo insmod dadfs.ko\n</code></pre> <p>Step 4 Remove the Module</p> <pre><code>sudo rmmod dadfs\n</code></pre> <p>*3. How are mutex defined and used? How good is this approach? As he insists on the last question it clearly appears that he expects an honest response, not just ?\uc3f0f course dad your code is perfect, nobody can do better than you.??</p> <p>Mutexes, or mutual exclusives, are used to protect shared data structures during the multi thread environment. There are serveral steps.</p> <p>Step 0 : Define Mutex</p> <p>Step 1 : Initialize Mutex</p> <p>Step 2 : Lock to protect important section</p> <p>Step 3 : Unlock if important section change is made</p> <pre><code>mutex_init(&amp;my_mutex);\nmutex_lock(&amp;my_mutex);\nmutex_unlock(&amp;my_mutex);\n</code></pre> <p>Mutex are really simple and efficient to manage inside thread context. However, they are able to potentially cause deadlock, specifically when simultaneously locked by twisted order or recursively locked. All threads will be in lock, so that entire mutex is dead.</p> <p>4. Based on the source code, how is information shared between the kernel and user spaces?</p> <p>Information share between kernel and user space is based on memory mapping, using <code>mmap</code> function. Function <code>mmap</code> could map kernel memory or files into user space memory. User space application is possible through kernel buffers with no system call repetition. Also, for specific file systems including <code>procfs</code> that create entries in <code>/proc</code> or <code>sysfs</code> to export kernel objects and attributed to the user spaces.</p> <p>5. Following dad?\uc172 advice ensure the part of the code the poses problem is only processed when working with older kernels. At this stage nothing needs to be done for newer ones. Ensure the module properly compiles on a newer kernel, although it cannot be of any use at this stage.</p> <p>Macro if statements commonly used like <code>#ifdef</code> can be used to ensure backward compatibility. Kernel version can be handled by libraries inside headers like <code>&lt;linux/version.h&gt;</code>.</p> <pre><code>#include &lt;linux/version.h&gt;\n\n#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(3, 12, 0)\nstatic const struct file_operations dadfs_fops = {\n    .read = old_read_function,\n    .write = old_write_function,\n};\n#else\nstatic const struct file_operations dadfs_fops = {\n    .read = new_read_function,\n    .write = new_write_function,\n};\n#endif\n</code></pre>"},{"location":"ECE482FA24/ECE482LAB/ECE482L8/","title":"Lab 08","text":"<p>ECE4820 FA2024 Introduction to Operating Systems</p> <p>518370990004 Jae Heung Park</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L8/#1-introduction","title":"1 Introduction","text":"<p>Reading</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L8/#2-looking-at-the-linux-kernel","title":"2 Looking at the Linux kernel","text":"<p>First you notice references to concepts and topics you have already seen but never dared to look at in details. The all seem to be related to coding quality, which you already know is of a critical importance when working at the kernel level.</p> <p>What are kmsan, kasan, kfence folders?</p> <p>KMSAN (Kernel Memory Sanitizer)</p> <ul> <li>Linux uninitialized kernel memory error detection</li> <li>Maintain shadow memory that track kernel memory initialization status</li> <li>Debug by uninitialized variable detection</li> </ul> <p>KASAN (Kernel Address Sanitizer)</p> <ul> <li>Out of Bounds and Use after free error detector</li> <li>Also use shadow memory that track whether memory access is valid</li> <li>Provide debug info and help to find problematic idea</li> </ul> <p>KFENCE (Kernel Fence)</p> <ul> <li>Lightweight detector for production</li> <li>Minimal performance, appropriate for live environments</li> </ul> <p>What is shadow memory and how does it relate to sanitizers?</p> <p>Shadow memory is portion of memory reserved to store metadata by tracking whether region is valid or not at the actual memory (primary memory) inside OS kernel</p> <p>Sanitizers use shadow memory to mark invalid or not initialized memory, track memory access, or find common error including use-after-free, out-of-bounds, etc.</p> <p>What are sanitizers and why are they essential when coding in the kernel level?</p> <p>Sanitizers dynamically detect bugs like memory errors, invalid accesses, etc. KMSAN, KASAN, KFENCE above are all sanitizers.</p> <p>Sanitizers can detect memory error, so it is essential in low level programming memory management. If memory is corrupted, then OS will not only waste resource but also have several security resources. Moreover, kernel interaction to hardware might be compromised, even result in system crash. Since debugging memory without sanitizer is extremely challenging.</p> <p>What is <code>kmemleak.c</code> file about? Explain who should ?\uc415se??it and under what circumstances</p> <p>File <code>kmemleak.c</code> is about memory leak detection. It will track all dynamically allocated memories to detect memory leakage in a real time.</p> <p>During programming for kernel, it is necessary to debug memory. Thus, it will be really useful in kernel level module modification that require a lot of allocating and freeing memories.</p> <p>You also notice two interesting files:</p> <p><code>nommu.c</code>: when would this file be used? List some drawbacks of having CPU without any MMU.</p> <p>File <code>nommu.c</code> is (NO Memory Management Unit). This is useful in circumstances with limited resources like embedded systems.</p> <p>CPU Drawbacks without MMU will have these problems</p> <ul> <li>No Virtual Memory, only physical memory could be used.</li> <li>No Memory Protection, isolated process will make system corruption and crashes more vulnerable</li> <li>Memory fragmentation issue and limited ability for handling several processes simultaneously</li> <li>Harder debugging, as no VM and memory management is more sophisticated</li> </ul> <p><code>compaction.c</code>: what is this file used for? Why is ?\uc40cemory compaction??important?</p> <p>File <code>compaction.c</code> reduce fragmentation by moving freed memory blocks to restore memory spaces.</p> <p>This compaction is important when memory allocation for large amount of data is completed. Efficient memory allocation is really important for specific processes or devices that must have contiguous memory like DMA buffers. Optimized performance will significantly reduce fallback strategies, maintaining high system performance.</p> <p>As you keep looking at the files in the mm directory of the Linux source code as name stands out: oom_kill.c. This sounds scary! What could be killed. You open the files and discover that it features long interesting comments.</p> <p>What is the OOM killer? In particular what does OOM mean?</p> <p>OOM (Out of Memory) is status when system run out of both physical memory and even reached to limit of SSD swap memory, so that no space has left to allocate resources for new processes.</p> <p>OOM Killer is OS kernel mechanism that will free memory by process termination especially when system memory is low. It will avoid necessary processes and kill useless processes by distinguishing them by heuristic algorithm.</p> <p>Based on the source code and comments, explain what could be a reason for a deadlock in the Linux kernel?</p> <p>Hint. There is no need to read the whole source code, simply run a search on a well chosen keyword.</p> <p>Source code of<code>oom_kill.c</code></p> <pre><code>grep -i \"deadlock\" oom_kill.c\n</code></pre> <pre><code>        panic(\"System is deadlocked on memory\\n\");\n</code></pre> <pre><code>grep -i \"mutex\" oom_kill.c\n</code></pre> <pre><code>DEFINE_MUTEX(oom_lock);\nDEFINE_MUTEX(oom_adj_mutex);\n    if (mutex_lock_killable(&amp;oom_lock))\n    mutex_unlock(&amp;oom_lock);\n</code></pre> <pre><code>grep -i \"wait\" oom_kill.c\n</code></pre> <pre><code>static DECLARE_WAIT_QUEUE_HEAD(oom_victims_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(oom_reaper_wait);\n                wait_event_freezable(oom_reaper_wait, oom_reaper_list != NULL);\n        wake_up(&amp;oom_reaper_wait);\n * before the exit path is able to wake the futex waiters.\n        wake_up_all(&amp;oom_victims_wait);\n * @timeout: maximum timeout to wait for oom victims in jiffies\n * Will block and wait until all OOM victims are killed or the given\n    ret = wait_event_interruptible_timeout(oom_victims_wait,\n</code></pre> <pre><code>grep -i \"lock\" oom_kill.c\n</code></pre> <pre><code> * oom_killer_disable() relies on this lock to stabilize oom_killer_disabled\nDEFINE_MUTEX(oom_lock);\nrcu_read_lock();\nrcu_read_unlock();\n* task_lock() held.\nstruct task_struct *find_lock_task_mm(struct task_struct *p)\nrcu_read_lock();\ntask_lock(t);\ntask_unlock(t);\nrcu_read_unlock();\np = find_lock_task_mm(p);\ntask_unlock(p);\ntask_unlock(p);\nrcu_read_lock();\nrcu_read_unlock();\ntask = find_lock_task_mm(p);\ntask_unlock(task);\nrcu_read_lock();\nrcu_read_unlock();\nstatic DEFINE_SPINLOCK(oom_reaper_lock);\n* we do not want to block exit_mmap by keeping mm ref\nif (mmu_notifier_invalidate_range_start_nonblock(&amp;range)) {\nif (!mmap_read_trylock(mm)) {\n* under mmap_lock for reading because it serializes against the\n* mmap_write_lock();mmap_write_unlock() cycle in exit_mmap().\ngoto out_unlock;\nout_unlock:\nmmap_read_unlock(mm);\n/* Retry the mmap_read_trylock(mm) a few times */\ndebug_show_all_locks();\n* somebody can't call mmap_write_unlock(mm).\nspin_lock_irq(&amp;oom_reaper_lock);\nspin_unlock_irq(&amp;oom_reaper_lock);\nspin_lock_irqsave(&amp;oom_reaper_lock, flags);\nspin_unlock_irqrestore(&amp;oom_reaper_lock, flags);\n* Has to be called with oom_lock held and never after\n* under task_lock or operate on the current).\n* any memory and livelock. freezing_slow_path will tell the freezer\n* Will block and wait until all OOM victims are killed or the given\nif (mutex_lock_killable(&amp;oom_lock))\nmutex_unlock(&amp;oom_lock);\n* Caller has to make sure that task-&gt;mm is stable (hold task_lock or\n* on that for now. We can consider find_lock_task_mm in future.\nrcu_read_lock();\nrcu_read_unlock();\np = find_lock_task_mm(victim);\n/* Get a reference to safely compare mm after task_unlock(victim) */\ntask_unlock(victim);\n* depletion of all memory.  This prevents mm-&gt;mmap_lock livelock when an\nrcu_read_lock();\nrcu_read_unlock();\ntask_lock(victim);\ntask_unlock(victim);\ntask_unlock(victim);\nstatic BLOCKING_NOTIFIER_HEAD(oom_notify_list);\nint register_oom_notifier(struct notifier_block *nb)\nreturn blocking_notifier_chain_register(&amp;oom_notify_list, nb);\nint unregister_oom_notifier(struct notifier_block *nb)\nreturn blocking_notifier_chain_unregister(&amp;oom_notify_list, nb);\nblocking_notifier_call_chain(&amp;oom_notify_list, 0, &amp;freed);\npanic(\"System is deadlocked on memory\\n\");\n* any locks held but let the oom killer triggered from the allocation context care\np = find_lock_task_mm(task);\ntask_unlock(p);\nif (mmap_read_lock_killable(mm)) {\n* Check MMF_OOM_SKIP again under mmap_read_lock protection to ensure\nmmap_read_unlock(mm);\n</code></pre> <p>In <code>oom_lock</code> mutex is used to serialize access to the OOM Killer mechanism. It also defines several locks and wait queues for OOM victims and the OOM reaper. Various locks used are</p> <ul> <li>Mutexes (oom_lock, oom_adj_mutex)</li> <li>Spinlocks (oom_reaper_lock)</li> <li>RCU locks (rcu_read_lock)</li> </ul> <p>If locks are in inconsistent order, deadlock risk exists.</p> <p>As you keep exploring the mm directory you notice a few swap related filenames. Without opening them you start thinking of the swap and a few questions come to your mind. You know that the kernel and user spaces memory are separated but what about the swap? You decide to run a quick online search to understand</p> <p>The ?\uc412ough??layout of kernel and user space memories;</p> <p>Kernel Space Memory</p> <ul> <li>Reserved for core functions of OS kernel code, memory stack, heap, and kernel level data .</li> <li>Accessible only in ring 0, privileged mode, to ensure stability.</li> </ul> <p>User Space Memory</p> <ul> <li>Used by user-level processes and applications</li> <li>Includes process data, stack, and heap.</li> <li>Runs in ring 3, unprivileged mode, that could isolate user processes from kernel.</li> </ul> <p>Whether or not kernel memory can be swapped and why;</p> <p>If kernel memory swap occurs, then OS kernel can be severely compromised in speed and stability. Kernel memory swap must be prohibited, and only user level process memory should be swapped.</p> <p>At this stage it is pretty clear that directly working in the kernel for MM is to complicated. Unfortunately with the pressure Mr. Frown puts on you, it is very hard for you to find enough time to properly investigate the benefits of MGLRU as you initially intended. Therefore you decide to keep searching online for some task that would prove that Mum Generally Loves to be Really Unfair! And again you are back with this MGLRU! Interestingly you suddenly land on this kernel documentation page. It shows how to enable and disable MGLRU from the user-space! What if you could work with MM from the user-space?</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L8/#21-looking-at-the-linux-kernel","title":"2.1 Looking at the Linux kernel","text":"<p>While searching information about MM in user-space you notice many recent research articles related to something called eBPF. As this seems to be a brand new topic this is likely a very idea to look into it: maybe being knowledgeable on it could earn you a better job without Mr. Frown! This really looks worth the effort, so you decide to read some documentation and follow a short presentation on the topic.</p> <p>eBPF (Extended Berkeley Packet Filter)</p> <p>The eBPF, (Extended Berkeley Packet Filter, guarantees secure execution of user programs at kernel level. This technology is commonly applied in to observe performance, computer security, and network status. These programs are possible to be injected inside kernel, so that all memory events inside are detected and viewed without changing source code of kernel.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L8/#22-a-page-fault-handler-using-ebpf","title":"2.2 A page-fault handler using eBPF","text":"<p>At the end of the presentation you realise that you have everything you need! The eBPF approach can work magic for you: no need to dig any further into Linux MM with long and complex code. You can simply run memory pressure tests with and without MGLRU enabled. For that you just need to monitor page-faults using an eBPF program. This sounds like a nice starting point to learn more about this intriguing technology which bridges the gap between monolithic and micro kernels, by safely ?\uc407njecting?? and ?\uc412unning??user-defined code into kernel space!</p> <p>First, install <code>bpf</code>, its trace tool, and <code>stress-ng</code>.</p> <pre><code>sudo apt-get install bpfcc-tools linux-headers-$(uname -r)\nsudo apt-get install bpftrace\nsudo apt-get install stress-ng\n</code></pre> <p>Use <code>brew</code> for macOS.</p> <pre><code>brew install bcc\nbrew install bpftrace\nbrew install stress-ng\n</code></pre> <p>Second, write down short eBPF script.</p> <pre><code>#include &lt;linux/mm_types.h&gt;\n\nint handle_page_fault(struct pt_regs *ctx, struct mm_struct *mm) {\n    bpf_trace_printk(\"Page fault in process: %d\\n\", mm-&gt;owner-&gt;pid);\n    return 0;\n}\n</code></pre> <p>Now, execution will require Kernel event eBPF attachment and Memory pressure test running.</p> <pre><code>sudo bpftrace -e 'tracepoint:exceptions:page_fault_user { printf(\"Page fault in process: %d\\n\", pid); }'\n./page_fault_loader page_fault.c\nstress-ng --vm 1 --vm-bytes 90% --timeout 60s\n</code></pre> <p>Finally, compare results.</p> <p>Sources</p> <ul> <li>eBPF Tracing: Tutorial and Examples</li> <li>stress-ng: A Tool to Load and Stress a Computer System</li> </ul>"},{"location":"ECE482FA24/ECE482LAB/ECE482L9/","title":"Lab 09","text":"<p>ECE4820 FA2024 Introduction to Operating Systems</p> <p>518370990004 Jae Heung Park</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L9/#1-project-3-presentations-part-1","title":"1 Project 3: presentations (part 1)","text":"<p>Presentation</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L9/#2-introduction","title":"2 Introduction","text":"<p>Reading</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L9/#3-a-dice-module","title":"3 A dice module","text":"<p>You remember that for what you want to implement, a character device should at least match the <code>open</code>, <code>close</code>, <code>read</code>, and <code>write</code> system calls. You will also have to decide on a major and a minor for your dice device. By definition the major must correspond to the driver associated to the device so it cannot ?\uc404reely??choose it. However, the minor is more flexible and you can pass it to the driver. You therefore decide to use it to create more than one type of dice device: each type would feature a different minor corresponding to a different type of dice. The displayed result of a roll would then depend on the minor. That being set, you now want to specify more precisely how to implement your devices, but for that you need grandpa?\uc172 help. What kind of game does he want to play? How many players there would be? Based on his answers it appears that you need to implement the following options:</p> <ul> <li>Change the number of dice by a <code>write</code> on the device;</li> <li>Display the result of a roll by a <code>read</code> on the device;</li> <li>Use the minor to specify the type of dice when creating the device;</li> <li>Depending on the type of dice display a different output;</li> <li>Use a module option to set the number of sides for a generic type of dice;</li> </ul> <p>Based on his answers you quickly get a sketch of what you will do, and show it to him to ensure you match all his expectations. You will have three main types of dice:</p> <ul> <li>(i) regular,</li> <li>(ii) backgammon, and</li> <li>(iii) generic</li> </ul> <p>featuring an arbitrary number of sides. For this latter dice the side number should be specified as a module option.</p> <pre><code>$ #regular dice\n$ echo 2 &gt; /dev/dice0\n$ cat /dev/dice0\n------- -------\n| o o | | o o |\n| o o | | o |\n| o o | | o o |\n'-----' '-----'\n</code></pre> <pre><code>$ #backgammon die\n$ echo 1 &gt; /dev/dice1\n$ cat /dev/dice1\n16\n</code></pre> <pre><code>$ #generic dice, gen_sides=20\n$ # gen_sides: module option\n$ echo 3 &gt; /dev/dice2\n$ cat /dev/dice2\n12 19 8\n</code></pre> <p>As grandpa is perfectly happy with your idea you decide to carry on with it.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L9/#4-tasks","title":"4 Tasks","text":"<p>First you want to make sure you are fully familiar with the kernel API for creating character devices. So you ask yourself the following questions.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L9/#what-needs-to-be-returned-by-read-and-write-file-operations-for-a-character-device","title":"What needs to be returned by read and write file operations for a character device?","text":"<p>Operation <code>read</code> should return the number of bytes read from device to provide data to user buffer. If no more data exist to be read, return 0, meaning EOF (End Of File). Errors should return negative value like <code>-EINVAL</code>.</p> <p>Operation <code>write</code> should return the number of bytes that are written to device. It should process user provided data and return negative value in error case. Common error is <code>-EFAULT</code>, a failure to access user memory.</p>"},{"location":"ECE482FA24/ECE482LAB/ECE482L9/#how-are-exactly-those-major-and-minor-numbers-working-you-vaguely-remember-that-you-can-display-them-using-ls-l-dev","title":"How are exactly those major and minor numbers working? You vaguely remember that you can display them using ls -l /dev.","text":"<p>Major Number identify device associated drivers. OS kernel will use these major numbers to locate appropriate driver required when device file is accessed.</p> <p>Minor Number specifically identifies particular device managed by drivers. Single driver could operate several devices and those subordinate drivers will be minor number.</p> <p>Display major numbers and minor numbers in Linux OS by following command.</p> <pre><code>ls -l /dev\n</code></pre>"},{"location":"ECE482FA24/ECE482LAB/ECE482L9/#knowing-the-major-number-and-minor-numbers-of-a-device-how-to-add-a-character-device-to-dev","title":"Knowing the major number and minor numbers of a device, how to add a character device to /dev?","text":"<p>Add character device to <code>/dev</code> by using <code>mknod</code> command.</p> <pre><code>mknod /dev/&lt;device_name&gt; c &lt;major_num&gt; &lt;minor_num&gt;\nmknod /dev/dice0 c 250 0\n</code></pre>"},{"location":"ECE482FA24/ECE482LAB/ECE482L9/#where-are-the-following-terms-located-in-linux-source-code","title":"Where are the following terms located in linux source code?","text":"Term Location Description <code>module_init</code> <code>linux/init.h</code> Macro for defining the initialization function of a kernel module. <code>module_exit</code> <code>linux/init.h</code> Macro for defining the cleanup function of a kernel module. <code>printk</code> <code>linux/kernel.h</code> Used for logging kernel messages. <code>container_of</code> <code>linux/kernel.h</code> Retrieves the containing structure from a pointer to a member. <code>dev_t</code> <code>linux/types.h</code> Represents device numbers (combines major and minor numbers). <code>MAJOR</code> <code>linux/kdev_t.h</code> Extracts the major number from <code>dev_t</code>. <code>MINOR</code> <code>linux/kdev_t.h</code> Extracts the minor number from <code>dev_t</code>. <code>MKDEV</code> <code>linux/kdev_t.h</code> Combines major and minor numbers into a <code>dev_t</code>. <code>alloc_chrdev_region</code> <code>linux/fs.h</code> Allocates device numbers dynamically. <code>module_param</code> <code>linux/moduleparam.h</code> Defines module parameters. <code>cdev_init</code> <code>linux/cdev.h</code> Initializes a character device structure. <code>cdev_add</code> <code>linux/cdev.h</code> Registers a character device with the kernel. <code>cdev_del</code> <code>linux/cdev.h</code> Removes a character device from the kernel. <code>THIS_MODULE</code> <code>linux/module.h</code> Macro referring to the current kernel module."},{"location":"ECE482FA24/ECE482LAB/ECE482L9/#how-to-generate-random-numbers-when-working-inside-the-linux-kernel-you-think-that-a-while-back-you-read-something-about-getting-the-current-time","title":"How to generate random numbers when working inside the Linux kernel? You think that a while back you read something about getting the current time.","text":"<p>Linux kernel has random number generator functions in <code>linux/random.h</code> including</p> <ul> <li><code>get_random_int()</code></li> <li><code>get_random_bytes(void *buf, int nbytes)</code></li> </ul>"},{"location":"ECE482FA24/ECE482LAB/ECE482L9/#how-to-define-and-specify-module-options","title":"How to define and specify module options?","text":"<p>Linux kernel has module parameter macro <code>module_param</code> function in <code>linux/moduleparam.h</code>.</p> <pre><code>static int gen_sides = 20;\nmodule_param(gen_sides, int, 0444);\nMODULE_PARM_DESC(gen_sides, \"Total number of generic dice sides\");\n</code></pre> <p>Pass module options at load time</p> <pre><code>insmod dice.ko gen_sides=12\n</code></pre> <p>Where <code>0444</code> specify permission (Read only for all), while <code>MODULE_PARM_DESC</code> is text description</p> <p>As you can answer all those questions it feels that you are almost ready to get started, so you open your favorite tool to code and write a very basic module which on a cat simply prints ?\uc3dblmost there grandpa!??</p> <p>A few useful references:</p> <ul> <li>https://github.com/starpos/scull</li> <li>https://www.oreilly.com/library/view/linux-device-drivers/0596005903/ch03.html</li> <li>https://elixir.bootlin.com/linux/latest/source</li> </ul>"},{"location":"ECE482FA24/ECE482LAB/ECE482L9/#compile-and-test-log-in-linux","title":"Compile and test log in Linux","text":"<p>Supports three types of dice</p> <ul> <li>Regular Dice: <code>/dev/dice0</code></li> <li>Backgammon Dice: <code>/dev/dice1</code></li> <li>Generic Dice: <code>/dev/dice2</code></li> </ul> <p>Implementation</p> <ul> <li><code>write</code> to set dice number to roll.</li> <li><code>read</code> to display dice rolls.</li> </ul> <p>Set dice number to roll (<code>write</code>), <code>?</code> is number</p> <pre><code>echo &lt;number&gt; &gt; /dev/dice?\n</code></pre> <p>Read dice number to roll (<code>read</code>), <code>?</code> is number</p> <pre><code>cat /dev/dice?\n</code></pre> <p>Compile by <code>make</code> command and clean by <code>make clean</code></p> <pre><code>make\nmake clean\n</code></pre> <p>Check generated dice</p> <pre><code>ls -l /dev/dice*\n</code></pre> <p>Check file contents</p> <pre><code>sudo cat /dev/dice0\n</code></pre> <p>Returns following</p> <pre><code>1 3\n</code></pre> <p>Check logs</p> <pre><code>sudo dmseg | tail\n</code></pre> <p>Logs contents</p> <pre><code>sudo dmesg | tail\n[    7.878369] audit: type=1107 audit(1733345694.330:59): pid=819 uid=102 auid=4294967295 ses=4294967295 subj=unconfined msg='apparmor=\"DENIED\" operation=\"dbus_method_call\"  bus=\"system\" path=\"/org/freedesktop/PolicyKit1/Authority\" interface=\"org.freedesktop.PolicyKit1.Authority\" member=\"CheckAuthorization\" mask=\"send\" name=\":1.3\" pid=1598 label=\"snap.snap-store.ubuntu-software\" peer_pid=832 peer_label=\"unconfined\"\n                exe=\"/usr/bin/dbus-daemon\" sauid=102 hostname=? addr=? terminal=?'\n[    7.880613] audit: type=1107 audit(1733345694.332:60): pid=819 uid=102 auid=4294967295 ses=4294967295 subj=unconfined msg='apparmor=\"DENIED\" operation=\"dbus_method_call\"  bus=\"system\" path=\"/org/freedesktop/PolicyKit1/Authority\" interface=\"org.freedesktop.DBus.Properties\" member=\"GetAll\" mask=\"send\" name=\":1.3\" pid=1598 label=\"snap.snap-store.ubuntu-software\" peer_pid=832 peer_label=\"unconfined\"\n                exe=\"/usr/bin/dbus-daemon\" sauid=102 hostname=? addr=? terminal=?'\n[    7.880708] audit: type=1107 audit(1733345694.332:61): pid=819 uid=102 auid=4294967295 ses=4294967295 subj=unconfined msg='apparmor=\"DENIED\" operation=\"dbus_method_call\"  bus=\"system\" path=\"/org/freedesktop/PolicyKit1/Authority\" interface=\"org.freedesktop.PolicyKit1.Authority\" member=\"CheckAuthorization\" mask=\"send\" name=\":1.3\" pid=1598 label=\"snap.snap-store.ubuntu-software\" peer_pid=832 peer_label=\"unconfined\"\n                exe=\"/usr/bin/dbus-daemon\" sauid=102 hostname=? addr=? terminal=?'\n[    8.039953] audit: type=1400 audit(1733345694.491:62): apparmor=\"DENIED\" operation=\"open\" class=\"file\" profile=\"snap.snap-store.ubuntu-software\" name=\"/etc/appstream.conf\" pid=1598 comm=\"snap-store\" requested_mask=\"r\" denied_mask=\"r\" fsuid=1000 ouid=0\n[ 8096.679822] audit: type=1326 audit(1733352979.809:63): auid=1000 uid=1000 gid=1000 ses=2 subj=snap.snap-store.ubuntu-software pid=1598 comm=\"pool-org.gnome.\" exe=\"/snap/snap-store/1217/usr/bin/snap-store\" sig=0 arch=c00000b7 syscall=55 compat=0 ip=0xf8108010910c code=0x50000\n[10648.110448] dicedevice: loading out-of-tree module taints kernel.\n[10648.110513] dicedevice: module verification failed: signature and/or required key missing - tainting kernel\n</code></pre> <p>Verify device noce</p> <pre><code>ls -l /dev/dice*\n</code></pre> <p>Test reading from device</p> <pre><code>sudo cat /dev/dice0\nsudo cat /dev/dice1\nsudo cat /dev/dice2\n</code></pre> <p> This is success result image.</p>"},{"location":"ECE482FA24/ECE482P2/Design/","title":"System Design","text":"<p>Software schema overview and description </p>"},{"location":"ECE482FA24/ECE482P2/Design/#navigation","title":"Navigation","text":"<ul> <li>Home</li> <li>Project Roadmap</li> <li>System Design</li> <li>Performance Improvements</li> <li>Multi-threading Challenges</li> <li>Developer Guide</li> </ul>"},{"location":"ECE482FA24/ECE482P2/Design/#system-overview","title":"System Overview","text":"<p>In our system, we employ a shared locking strategy for managing concurrent access to resources. Read locks, often implemented in shared locks, allow multiple threads to access the same resource concurrently for reading purposes. Write locks, on the other hand, do not permit concurrent access but can operate concurrently on different segments of data. Thus, as long as the operations do not modify the same segment, write locks can also effectively function as shared locks. The only one exception to this shared lock usage is during a dump operation, which requires exclusive access.</p> <p>To do a \"multi-shared-mutex\", we've developed a class called \"AdvancedLock\". This class combines two standard shared locks, allowing the efficient management of lock states during complex operations.</p> <p>An issue in multi-threading is the race condition, which arises when multiple threads attempt to modify shared data simultaneously. We address this challenge by the \"Advanced Mutex\". Thus threads either gain full required access to the resource or are put on hold, thereby preventing race conditions and ensuring data integrity and consistency.</p>"},{"location":"ECE482FA24/ECE482P2/Design/#architecture","title":"Architecture","text":"<p><code>./src</code> Contains the source code for an old version of lemnonDB. The code was recovered from crash site. As far as we know the original developer used CMake as their building system.</p> <ul> <li><code>./bin</code> Contains the lastest binary that survived the crash.</li> <li><code>./db</code> Contains sample database files.</li> <li><code>./sample</code> Sample inputs and outputs</li> <li><code>./build</code>: Build LemonDB by compile and run code inside folder  </li> <li><code>./src/query</code>: Query-related logic </li> <li><code>./src/query/execute</code>: Execution layer, managing threading and parallelism.</li> <li><code>./src/query/management</code>: Queries for managing the system state (e.g., table operations).</li> <li><code>./src/utils</code>: Utility functions and error handling.</li> </ul>"},{"location":"ECE482FA24/ECE482P2/Design/#main-components","title":"Main Components","text":""},{"location":"ECE482FA24/ECE482P2/Design/#parse-query","title":"Parse Query","text":"<p>Purpose: Parse the user input, validate syntax, and create query objects. </p> <ol> <li>Tokenize input.</li> <li>Validate syntax.</li> <li>Use QueryBuilder chain to create and return a query object</li> </ol> <pre><code>Function ParseQuery(input)\n    If no QueryBuilder exists:\n        Throw Error\n    Tokenize input\n    If tokens are empty:\n        Throw Error\n    Clear QueryBuilder state\n    Return QueryBuilder.extractQuery(tokens)\n</code></pre>"},{"location":"ECE482FA24/ECE482P2/Design/#execute-query","title":"Execute Query","text":"<ul> <li>Lock necessary resources.</li> <li>Execute query based on its type:</li> <li>Read-only: Process safely in parallel.</li> <li>Write-only: Process with required locks.</li> <li>Unlock resources and return results. </li> </ul> <pre><code>Function ExecuteQuery(queryObject)\n    Lock resources\n    If query is read-only:\n        Do read operation\n    Else if query is write-only:\n        Do write operation\n    Unlock resources\n    Return results\n</code></pre>"},{"location":"ECE482FA24/ECE482P2/Design/#thread-life-cycle","title":"Thread Life Cycle","text":"<ol> <li>Task assignment.</li> <li>Thread execution.</li> <li>Thread termination or reuse.</li> </ol> <pre><code>Function ThreadLifeCycle()\n    While thread is active:\n        Wait for task\n        Execute task\n        Mark thread as available\n</code></pre>"},{"location":"ECE482FA24/ECE482P2/Design/#data-flow","title":"Data Flow","text":"<ol> <li>Parse SQL Queries. </li> <li>Assign Unique IDs.</li> <li>Distribute Queries to Threads.</li> </ol> <pre><code>Function DataFlow()\n    Parse queries\n    Assign unique IDs\n    Distribute to threads\n    Collect and return results\n</code></pre> <p>Tree Structure for system </p> <pre><code>.\n?\uc48b??\u0080 CHANGELOG.md\n?\uc48b??\u0080 Develop.md\n?\uc48b??\u0080 INSTALL.md\n?\uc48b??\u0080 README.md\n?\uc48b??\u0080 build\n??  ?\uc48b??\u0080 CMakeCache.txt\n??  ?\uc48b??\u0080 CMakeFiles\n??  ??  ?\uc48b??\u0080 3.30.5\n??  ??  ??  ?\uc48b??\u0080 CMakeCCompiler.cmake\n??  ??  ??  ?\uc48b??\u0080 CMakeCXXCompiler.cmake\n??  ??  ??  ?\uc48b??\u0080 CMakeDetermineCompilerABI_C.bin\n??  ??  ??  ?\uc48b??\u0080 CMakeDetermineCompilerABI_CXX.bin\n??  ??  ??  ?\uc48b??\u0080 CMakeSystem.cmake\n??  ??  ??  ?\uc48b??\u0080 CompilerIdC\n??  ??  ??  ??  ?\uc48b??\u0080 CMakeCCompilerId.c\n??  ??  ??  ??  ?\uc48b??\u0080 a.out\n??  ??  ??  ??  ?\ubdb4??\u0080 tmp\n??  ??  ??  ?\ubdb4??\u0080 CompilerIdCXX\n??  ??  ??      ?\uc48b??\u0080 CMakeCXXCompilerId.cpp\n??  ??  ??      ?\uc48b??\u0080 a.out\n??  ??  ??      ?\ubdb4??\u0080 tmp\n??  ??  ?\uc48b??\u0080 CMakeConfigureLog.yaml\n??  ??  ?\uc48b??\u0080 CMakeDirectoryInformation.cmake\n??  ??  ?\uc48b??\u0080 Makefile.cmake\n??  ??  ?\uc48b??\u0080 Makefile2\n??  ??  ?\uc48b??\u0080 TargetDirectories.txt\n??  ??  ?\uc48b??\u0080 cmake.check_cache\n??  ??  ?\uc48b??\u0080 lemondb.dir\n??  ??  ??  ?\uc48b??\u0080 DependInfo.cmake\n??  ??  ??  ?\uc48b??\u0080 build.make\n??  ??  ??  ?\uc48b??\u0080 cmake_clean.cmake\n??  ??  ??  ?\uc48b??\u0080 compiler_depend.internal\n??  ??  ??  ?\uc48b??\u0080 compiler_depend.make\n??  ??  ??  ?\uc48b??\u0080 compiler_depend.ts\n??  ??  ??  ?\uc48b??\u0080 db\n??  ??  ??  ??  ?\uc48b??\u0080 Database.cpp.o\n??  ??  ??  ??  ?\uc48b??\u0080 Database.cpp.o.d\n??  ??  ??  ??  ?\uc48b??\u0080 Table.cpp.o\n??  ??  ??  ??  ?\ubdb4??\u0080 Table.cpp.o.d\n??  ??  ??  ?\uc48b??\u0080 depend.make\n??  ??  ??  ?\uc48b??\u0080 flags.make\n??  ??  ??  ?\uc48b??\u0080 link.txt\n??  ??  ??  ?\uc48b??\u0080 main.cpp.o\n??  ??  ??  ?\uc48b??\u0080 main.cpp.o.d\n??  ??  ??  ?\uc48b??\u0080 progress.make\n??  ??  ??  ?\ubdb4??\u0080 query\n??  ??  ??      ?\uc48b??\u0080 Query.cpp.o\n??  ??  ??      ?\uc48b??\u0080 Query.cpp.o.d\n??  ??  ??      ?\uc48b??\u0080 QueryBuilders.cpp.o\n??  ??  ??      ?\uc48b??\u0080 QueryBuilders.cpp.o.d\n??  ??  ??      ?\uc48b??\u0080 QueryParser.cpp.o\n??  ??  ??      ?\uc48b??\u0080 QueryParser.cpp.o.d\n??  ??  ??      ?\uc48b??\u0080 QueryResult.cpp.o\n??  ??  ??      ?\uc48b??\u0080 QueryResult.cpp.o.d\n??  ??  ??      ?\uc48b??\u0080 data\n??  ??  ??      ??  ?\uc48b??\u0080 AddQuery.cpp.o\n??  ??  ??      ??  ?\uc48b??\u0080 AddQuery.cpp.o.d\n??  ??  ??      ??  ?\uc48b??\u0080 CountQuery.cpp.o\n??  ??  ??      ??  ?\uc48b??\u0080 CountQuery.cpp.o.d\n??  ??  ??      ??  ?\uc48b??\u0080 DeleteQuery.cpp.o\n??  ??  ??      ??  ?\uc48b??\u0080 DeleteQuery.cpp.o.d\n??  ??  ??      ??  ?\uc48b??\u0080 DuplicateQuery.cpp.o\n??  ??  ??      ??  ?\uc48b??\u0080 DuplicateQuery.cpp.o.d\n??  ??  ??      ??  ?\uc48b??\u0080 InsertQuery.cpp.o\n??  ??  ??      ??  ?\uc48b??\u0080 InsertQuery.cpp.o.d\n??  ??  ??      ??  ?\uc48b??\u0080 MaxQuery.cpp.o\n??  ??  ??      ??  ?\uc48b??\u0080 MaxQuery.cpp.o.d\n??  ??  ??      ??  ?\uc48b??\u0080 MinQuery.cpp.o\n??  ??  ??      ??  ?\uc48b??\u0080 MinQuery.cpp.o.d\n??  ??  ??      ??  ?\uc48b??\u0080 SelectQuery.cpp.o\n??  ??  ??      ??  ?\uc48b??\u0080 SelectQuery.cpp.o.d\n??  ??  ??      ??  ?\uc48b??\u0080 SubQuery.cpp.o\n??  ??  ??      ??  ?\uc48b??\u0080 SubQuery.cpp.o.d\n??  ??  ??      ??  ?\uc48b??\u0080 SumQuery.cpp.o\n??  ??  ??      ??  ?\uc48b??\u0080 SumQuery.cpp.o.d\n??  ??  ??      ??  ?\uc48b??\u0080 SwapQuery.cpp.o\n??  ??  ??      ??  ?\uc48b??\u0080 SwapQuery.cpp.o.d\n??  ??  ??      ??  ?\uc48b??\u0080 UpdateQuery.cpp.o\n??  ??  ??      ??  ?\ubdb4??\u0080 UpdateQuery.cpp.o.d\n??  ??  ??      ?\uc48b??\u0080 execute\n??  ??  ??      ??  ?\uc48b??\u0080 QueryExecuter.cpp.o\n??  ??  ??      ??  ?\uc48b??\u0080 QueryExecuter.cpp.o.d\n??  ??  ??      ??  ?\uc48b??\u0080 QueryExecuterHelper.cpp.o\n??  ??  ??      ??  ?\uc48b??\u0080 QueryExecuterHelper.cpp.o.d\n??  ??  ??      ??  ?\uc48b??\u0080 QueryThreadPool.cpp.o\n??  ??  ??      ??  ?\ubdb4??\u0080 QueryThreadPool.cpp.o.d\n??  ??  ??      ?\ubdb4??\u0080 management\n??  ??  ??          ?\uc48b??\u0080 CopyTableQuery.cpp.o\n??  ??  ??          ?\uc48b??\u0080 CopyTableQuery.cpp.o.d\n??  ??  ??          ?\uc48b??\u0080 DropTableQuery.cpp.o\n??  ??  ??          ?\uc48b??\u0080 DropTableQuery.cpp.o.d\n??  ??  ??          ?\uc48b??\u0080 DumpTableQuery.cpp.o\n??  ??  ??          ?\uc48b??\u0080 DumpTableQuery.cpp.o.d\n??  ??  ??          ?\uc48b??\u0080 ListTableQuery.cpp.o\n??  ??  ??          ?\uc48b??\u0080 ListTableQuery.cpp.o.d\n??  ??  ??          ?\uc48b??\u0080 LoadTableQuery.cpp.o\n??  ??  ??          ?\uc48b??\u0080 LoadTableQuery.cpp.o.d\n??  ??  ??          ?\uc48b??\u0080 PrintTableQuery.cpp.o\n??  ??  ??          ?\uc48b??\u0080 PrintTableQuery.cpp.o.d\n??  ??  ??          ?\uc48b??\u0080 QuitQuery.cpp.o\n??  ??  ??          ?\uc48b??\u0080 QuitQuery.cpp.o.d\n??  ??  ??          ?\uc48b??\u0080 TruncateTableQuery.cpp.o\n??  ??  ??          ?\ubdb4??\u0080 TruncateTableQuery.cpp.o.d\n??  ??  ?\uc48b??\u0080 pkgRedirects\n??  ??  ?\ubdb4??\u0080 progress.marks\n??  ?\uc48b??\u0080 Makefile\n??  ?\uc48b??\u0080 cmake_install.cmake\n??  ?\uc48b??\u0080 lemondb\n??  ?\uc48b??\u0080 sample\n??  ??  ?\uc48b??\u0080 ...\n??  ??  ?\ubdb4??\u0080 test.query\n??  ?\uc48b??\u0080 sample_stdout\n??  ??  ?\uc48b??\u0080 ...\n??  ??  ?\ubdb4??\u0080 test.out\n??  ?\ubdb4??\u0080 stdout\n??      ?\ubdb4??\u0080 test.out\n?\uc48b??\u0080 db\n??  ?\uc48b??\u0080 fTable0.tbl\n??  ?\uc48b??\u0080 ... \n??  ?\uc48b??\u0080 mTable49.tbl\n??  ?\uc48b??\u0080 t1.tbl\n??  ?\uc48b??\u0080 t2.tbl\n??  ?\ubdb4??\u0080 tlarge.tbl\n?\uc48b??\u0080 src\n??  ?\uc48b??\u0080 CMakeLists.txt\n??  ?\uc48b??\u0080 db\n??  ??  ?\uc48b??\u0080 AdvancedLock.h\n??  ??  ?\uc48b??\u0080 Database.cpp\n??  ??  ?\uc48b??\u0080 Database.h\n??  ??  ?\uc48b??\u0080 Table.cpp\n??  ??  ?\ubdb4??\u0080 Table.h\n??  ?\uc48b??\u0080 main.cpp\n??  ?\uc48b??\u0080 query\n??  ??  ?\uc48b??\u0080 Query.cpp\n??  ??  ?\uc48b??\u0080 Query.h\n??  ??  ?\uc48b??\u0080 QueryBuilders.cpp\n??  ??  ?\uc48b??\u0080 QueryBuilders.h\n??  ??  ?\uc48b??\u0080 QueryParser.cpp\n??  ??  ?\uc48b??\u0080 QueryParser.h\n??  ??  ?\uc48b??\u0080 QueryResult.cpp\n??  ??  ?\uc48b??\u0080 QueryResult.h\n??  ??  ?\uc48b??\u0080 data\n??  ??  ??  ?\uc48b??\u0080 AddQuery.cpp\n??  ??  ??  ?\uc48b??\u0080 AddQuery.h\n??  ??  ??  ?\uc48b??\u0080 CountQuery.cpp\n??  ??  ??  ?\uc48b??\u0080 CountQuery.h\n??  ??  ??  ?\uc48b??\u0080 DeleteQuery.cpp\n??  ??  ??  ?\uc48b??\u0080 DeleteQuery.h\n??  ??  ??  ?\uc48b??\u0080 DuplicateQuery.cpp\n??  ??  ??  ?\uc48b??\u0080 DuplicateQuery.h\n??  ??  ??  ?\uc48b??\u0080 InsertQuery.cpp\n??  ??  ??  ?\uc48b??\u0080 InsertQuery.h\n??  ??  ??  ?\uc48b??\u0080 MaxQuery.cpp\n??  ??  ??  ?\uc48b??\u0080 MaxQuery.h\n??  ??  ??  ?\uc48b??\u0080 MinQuery.cpp\n??  ??  ??  ?\uc48b??\u0080 MinQuery.h\n??  ??  ??  ?\uc48b??\u0080 SelectQuery.cpp\n??  ??  ??  ?\uc48b??\u0080 SelectQuery.h\n??  ??  ??  ?\uc48b??\u0080 SubQuery.cpp\n??  ??  ??  ?\uc48b??\u0080 SubQuery.h\n??  ??  ??  ?\uc48b??\u0080 SumQuery.cpp\n??  ??  ??  ?\uc48b??\u0080 SumQuery.h\n??  ??  ??  ?\uc48b??\u0080 SwapQuery.cpp\n??  ??  ??  ?\uc48b??\u0080 SwapQuery.h\n??  ??  ??  ?\uc48b??\u0080 UpdateQuery.cpp\n??  ??  ??  ?\ubdb4??\u0080 UpdateQuery.h\n??  ??  ?\uc48b??\u0080 execute\n??  ??  ??  ?\uc48b??\u0080 QueryExecuter.cpp\n??  ??  ??  ?\uc48b??\u0080 QueryExecuter.h\n??  ??  ??  ?\uc48b??\u0080 QueryExecuterHelper.cpp\n??  ??  ??  ?\uc48b??\u0080 QueryExecuterHelper.h\n??  ??  ??  ?\uc48b??\u0080 QueryThreadPool.cpp\n??  ??  ??  ?\ubdb4??\u0080 QueryThreadPool.h\n??  ??  ?\ubdb4??\u0080 management\n??  ??      ?\uc48b??\u0080 CopyTableQuery.cpp\n??  ??      ?\uc48b??\u0080 CopyTableQuery.h\n??  ??      ?\uc48b??\u0080 DropTableQuery.cpp\n??  ??      ?\uc48b??\u0080 DropTableQuery.h\n??  ??      ?\uc48b??\u0080 DumpTableQuery.cpp\n??  ??      ?\uc48b??\u0080 DumpTableQuery.h\n??  ??      ?\uc48b??\u0080 ListTableQuery.cpp\n??  ??      ?\uc48b??\u0080 ListTableQuery.h\n??  ??      ?\uc48b??\u0080 LoadTableQuery.cpp\n??  ??      ?\uc48b??\u0080 LoadTableQuery.h\n??  ??      ?\uc48b??\u0080 PrintTableQuery.cpp\n??  ??      ?\uc48b??\u0080 PrintTableQuery.h\n??  ??      ?\uc48b??\u0080 QuitQuery.cpp\n??  ??      ?\uc48b??\u0080 QuitQuery.h\n??  ??      ?\uc48b??\u0080 TruncateTableQuery.cpp\n??  ??      ?\ubdb4??\u0080 TruncateTableQuery.h\n??  ?\ubdb4??\u0080 utils\n??      ?\uc48b??\u0080 formatter.h\n??      ?\ubdb4??\u0080 uexception.h\n?\ubdb4??\u0080 test\n    ?\uc48b??\u0080 run.sh\n    ?\uc48b??\u0080 run_wr.sh\n    ?\uc48b??\u0080 testAdd.query\n    ?\uc48b??\u0080 testMax.query\n    ?\uc48b??\u0080 testMin.query\n    ?\uc48b??\u0080 testSum.query\n    ?\ubdb4??\u0080 testSwap.query\n</code></pre>"},{"location":"ECE482FA24/ECE482P2/Design/#navigation_1","title":"Navigation","text":"<ul> <li>Home</li> <li>Project Roadmap</li> <li>System Design</li> <li>Performance Improvements</li> <li>Multi-threading Challenges</li> <li>Developer Guide</li> </ul>"},{"location":"ECE482FA24/ECE482P2/DeveloperGuide/","title":"Developer Setup","text":"<p>Full setup and test guide from beginning to end </p>"},{"location":"ECE482FA24/ECE482P2/DeveloperGuide/#navigation","title":"Navigation","text":"<ul> <li>Home</li> <li>Project Roadmap</li> <li>System Design</li> <li>Performance Improvements</li> <li>Multi-threading Challenges</li> <li>Developer Guide</li> </ul>"},{"location":"ECE482FA24/ECE482P2/DeveloperGuide/#prerequisites","title":"Prerequisites","text":"<ol> <li>C++ compiler: Clang &gt;= 6.0</li> <li>CMake &gt;= 2.7</li> </ol>"},{"location":"ECE482FA24/ECE482P2/DeveloperGuide/#download-program-files","title":"Download Program Files","text":"<p>First, clone the git repository or download the file.</p> <pre><code>git clone ssh://git@focs.ji.sjtu.edu.cn:2222/ece482-24fa/p2team-02.git \ncd p2team-02 \n</code></pre> <p>Download required files and locate them from SJTU school server. </p> <p>Required files are <code>db</code>, <code>sample</code>, <code>sample_stdout</code>. </p> <p>Value <code>ID</code> is student ID like 512212345678. </p> <pre><code>scp -r ID@111.186.59.59:/opt/lemondb/db ./ \nscp -r ID@111.186.59.59:/opt/lemondb/sample ./\nscp -r ID@111.186.59.59:/opt/lemondb/sample_stdout ./\n</code></pre> <p>After download, move downloaded folder files into corresponding locations inside project </p> <pre><code>cp -r ~/Downloads/db ~/path/to/p2team-02 \ncp -r ~/Downloads/sample ~/path/to/p2team-02/build\ncp -r ~/Downloads/sample_stdout ~/path/to/p2team-02/build \ncp -r ~/Downloads/stdout ~/path/to/p2team-02/build \n</code></pre>"},{"location":"ECE482FA24/ECE482P2/DeveloperGuide/#compile","title":"Compile","text":"<p>For the first compile, make directory <code>build</code>. Compile and run code at the <code>build</code> folder. </p> <pre><code>mkdir build &amp;&amp; cd build\ncmake -DCMAKE_C_COMPILER=/usr/bin/clang -DCMAKE_CXX_COMPILER=/usr/bin/clang++ -DCMAKE_BUILD_TYPE=Release ../src\ncmake --build . -- -j8\ncd ..\n</code></pre> <p>If compile success, you will have a lemondb binary file at <code>./build/lemondb</code>. </p> <p>Note: You can use <code>CMAKE_BUILD_TYPE</code> to switch between debug and release.</p> <p>Recompile inside <code>build</code> folder. </p> <pre><code>cmake -DCMAKE_C_COMPILER=/usr/bin/clang -DCMAKE_CXX_COMPILER=/usr/bin/clang++ -DCMAKE_BUILD_TYPE=Release ../src\ncmake --build . -- -j8\n</code></pre>"},{"location":"ECE482FA24/ECE482P2/DeveloperGuide/#test-by-running-code-measuring-input-and-output-locally","title":"Test by running code, measuring input and output locally","text":"<pre><code>cd build\nmkdir stdout  \ntime ./lemondb --listen ./sample/test.query &gt; stdout/test.out\n</code></pre>"},{"location":"ECE482FA24/ECE482P2/DeveloperGuide/#segmentation-error-debugging-test","title":"Segmentation Error Debugging Test","text":"<pre><code>cd ./build \nlldb ./lemondb\nrun --listen ./sample/test.query\nbt\n</code></pre>"},{"location":"ECE482FA24/ECE482P2/DeveloperGuide/#difference-check","title":"Difference Check","text":"<pre><code>diff -n ./sample_stdout/test.out ./stdout/test.out\n</code></pre> <p>This terminal command will show difference between standard output and test output </p>"},{"location":"ECE482FA24/ECE482P2/DeveloperGuide/#navigation_1","title":"Navigation","text":"<ul> <li>Home</li> <li>Project Roadmap</li> <li>System Design</li> <li>Performance Improvements</li> <li>Multi-threading Challenges</li> <li>Developer Guide</li> </ul>"},{"location":"ECE482FA24/ECE482P2/Home/","title":"Project 2 LemonDB Multi Threading Database","text":"<p>2024FA ECE4820 Introduction to Operating Systems</p>"},{"location":"ECE482FA24/ECE482P2/Home/#navigation","title":"Navigation","text":"<ul> <li>Home</li> <li>Project Roadmap</li> <li>System Design</li> <li>Performance Improvements</li> <li>Multi-threading Challenges</li> <li>Developer Guide</li> </ul>"},{"location":"ECE482FA24/ECE482P2/Home/#overview","title":"Overview","text":"<p>LemonDB is a multi-threaded database system project. It assigns each processes queries in parallel for faster execution.</p> <p>Project 2, named as LemonDB in this fictional home-brewed project of Lemonion.inc, is a team based assignment to program database from source code of previous system. Based on the concepts taught in the class, our team programmed the most efficient and optimized version of multi-threading database by considering parallel multi threading. By the time project is completed, the new implementation will be able to handle parallel query execution by concurrency, allowing heavy workload of multiple query execution in short period of time by optimized scheduling.</p> <p>Also, during the software development, team members will try to follow the principles for the agile development, clean documentation for better maintainability in the future, and software testing and benchmarking compared to the original system. Tasks will be divided and distributed as evenly as possible, but more competent member will contribute more to the project.</p>"},{"location":"ECE482FA24/ECE482P2/Home/#team-members-roles-and-contributions","title":"Team Members, Roles and contributions","text":"<p>Jae Heung Park</p> <ul> <li>Implementation of <code>MAX</code> <code>MIN</code> <code>SWAP</code> functions in single thread.</li> <li>Implementation of read  only <code>MAX</code> <code>MIN</code> <code>SUM</code> <code>SELECT</code> <code>COUNT</code> queries in multi thread.</li> <li>Documentation of <code>README</code> file and Wiki for project release.</li> <li>Compiling and debugging codes to run test cases in local environment.</li> <li>Detecting segmentation error and finding problematic queries.</li> <li>Discovering no implementation of <code>COPYTABLE</code> <code>TRUNCATE</code> and fix those.</li> <li>Supportive contribution to the project with effort</li> </ul> <p>He Wentao</p> <ul> <li>Project basic setup from given source code and functions.</li> <li>Compiling and debugging codes to run test cases in local environment.</li> <li>Code testing from server to check optimization and performance.</li> <li>Single thread functions implementation <code>ADD</code> <code>SUB</code> <code>COUNT</code> <code>DELETE</code></li> <li>Algorithm design implementation for multi threading</li> <li>Changing entire query functions to apply optimization algorithm</li> <li>Implementation of write queries in multi thread.</li> <li>High contribution to the project with great skills and effort</li> </ul> <p>Wang Rui</p> <ul> <li>Project template update, comment, and developer guide documentation</li> <li>Single thread functions implementation <code>SUM</code> <code>DELETE</code> <code>DUPLICATE</code></li> <li>Implementation of read  only <code>MAX</code> <code>MIN</code> <code>SUM</code> <code>SELECT</code> <code>COUNT</code> queries in multi thread.</li> <li>Algorithm design research and implementation for multi threading</li> <li>Implementation of write queries in multi thread.</li> <li>Compiling and debugging codes to run test cases in local environment.</li> <li>High contribution to the project with great skills and effort</li> </ul>"},{"location":"ECE482FA24/ECE482P2/Home/#navigation_1","title":"Navigation","text":"<ul> <li>Home</li> <li>Project Roadmap</li> <li>System Design</li> <li>Performance Improvements</li> <li>Multi-threading Challenges</li> <li>Developer Guide</li> </ul>"},{"location":"ECE482FA24/ECE482P2/MultiThreading/","title":"Multi-threading Challenges","text":"<p>Support concurrent query execution using multi-threading.  </p>"},{"location":"ECE482FA24/ECE482P2/MultiThreading/#navigation","title":"Navigation","text":"<ul> <li>Home</li> <li>Project Roadmap</li> <li>System Design</li> <li>Performance Improvements</li> <li>Multi-threading Challenges</li> <li>Developer Guide</li> </ul>"},{"location":"ECE482FA24/ECE482P2/MultiThreading/#features","title":"Features","text":""},{"location":"ECE482FA24/ECE482P2/MultiThreading/#1-multi-threaded-execution","title":"1. Multi-Threaded Execution:","text":"<ul> <li>Parallel execution of queries using a thread pool.</li> <li>Thread-safe resource management with fine-grained locks.</li> </ul>"},{"location":"ECE482FA24/ECE482P2/MultiThreading/#2-query-types","title":"2. Query Types:","text":"<ul> <li>Read-Only: SELECT, COUNT, MAX, MIN, SUM</li> <li>Write-Only: INSERT, DELETE, UPDATE, LOAD, COPY_TABLE</li> </ul>"},{"location":"ECE482FA24/ECE482P2/MultiThreading/#3-concurrency-control","title":"3. Concurrency Control:","text":"<ul> <li>Shared locks for read operations.</li> <li>Exclusive locks for write operations.</li> <li>Deadlock prevention through ordered locking.</li> </ul>"},{"location":"ECE482FA24/ECE482P2/MultiThreading/#challenges","title":"Challenges","text":""},{"location":"ECE482FA24/ECE482P2/MultiThreading/#deadlocks","title":"Deadlocks","text":"<ul> <li>Issue: Circular dependencies between locks might trigger threads to wait indefinitely  </li> <li>Solution: Break \"hold and wait\" by retrying when locks cannot be acquired </li> </ul>"},{"location":"ECE482FA24/ECE482P2/MultiThreading/#race-conditions","title":"Race Conditions","text":"<ul> <li>Issue: Concurrent access to shared resources causes inconsistent states </li> <li>Used atomic operations and counters </li> <li>Enforce ordered locking to prevent cyclic dependencies</li> </ul>"},{"location":"ECE482FA24/ECE482P2/MultiThreading/#thread-safety","title":"Thread Safety","text":"<ul> <li>Use <code>std::mutex</code> for exclusive locks </li> <li>Use <code>std::shared_mutex</code> for shared locks.</li> <li>Use <code>std::condition_variable</code> for coordinate threads.</li> </ul>"},{"location":"ECE482FA24/ECE482P2/MultiThreading/#original-approach-locking-each-function","title":"Original Approach: Locking Each Function","text":"<p>During the first 2 weeks, our approach for multi threading system lock was individual lock. Each query-related function (e.g., <code>SELECT</code>, <code>SWAP</code>, <code>MAX</code>) had its own lock  to protect the critical sections within that function. Locking within a function was the easiest method to implement.  Also, as each function handled its own locking,  detailed control over resource protection was possible. It also allowed minimal interference between unrelated operations. </p> <p>However, this method was not good approach to handle speed optimization.  There were large number of independent locks, making the system harder to manage and debug.  Moreover, higher risk of deadlocks when functions accessed shared resources followed.  Since original design's goal was simplicity and isolation, so that no function could accidentally handle shared resources without proper protection.  Thus, the operation speed was unacceptable, and new design was required. </p>"},{"location":"ECE482FA24/ECE482P2/MultiThreading/#current-approach-locks-per-table","title":"Current Approach: Locks Per Table","text":"<p>In the current design, locks are applied per table instead of per function.  Based on the query type: Each table has a shared or exclusive lock. </p> <ul> <li>Shared Locks (<code>std::shared_mutex</code>) allow multiple threads to perform read operations concurrently.</li> <li>Exclusive Locks  (<code>std::mutex</code>) block all other operations while a write operation is executed.</li> </ul> <p>Compared to the original design without enough consideration, table lock has several advantages. </p> <ul> <li>Read queries (<code>SELECT</code>, <code>COUNT</code>, etc.) can proceed in parallel without blocking each other.</li> <li>Write queries (<code>INSERT</code>, <code>DELETE</code>, etc.) need exclusive locks, ensuring data consistency.</li> <li>Ordered lock ensures threads lock in same order, preventing circular dependencies, meaning deadlock.</li> <li>Locks are managed at the table level rather than function level, reducing total lock/unlock operations. </li> <li>Allows unrelated queries on different tables to proceed simultaneously. </li> </ul>"},{"location":"ECE482FA24/ECE482P2/MultiThreading/#comparison-between-two-methods","title":"Comparison between two methods","text":"Metric Lock Per Function Per-Table Lock Concurrency Low (locks on functions block threads) High (multiple threads can read concurrently) Deadlock Risk High (independent locks cause cyclic dependencies) Low (ordered locking and fewer locks) Overhead High (many lock/unlock calls) Lower (fewer, coarser locks) Scalability Poor (limited by function locks) Better (independent locks per table) Complexity Simple (isolated locking) Moderate (lock coordination required) <p>It was able to accomplish following by implementation of lock per table </p> <ul> <li>Resource Optimization: Concurrent read queries on the same table</li> <li>Higher Throughput: Write queries block only specific table in work, avoid bottlenecks</li> <li>Reduced Lock Contention: Per-table locks is reduced compared to per-function locks </li> <li>Simplified Debugging: Lock-per-table approach centralizes lock to table-specific resources</li> <li>Future Scalability: Supports scaling to larger systems with more tables and threads</li> </ul>"},{"location":"ECE482FA24/ECE482P2/MultiThreading/#navigation_1","title":"Navigation","text":"<ul> <li>Home</li> <li>Project Roadmap</li> <li>System Design</li> <li>Performance Improvements</li> <li>Multi-threading Challenges</li> <li>Developer Guide</li> </ul>"},{"location":"ECE482FA24/ECE482P2/Performance/","title":"Performance Improvements","text":"<p>This section documents the performance improvements of our LemonDB systems in school server. </p>"},{"location":"ECE482FA24/ECE482P2/Performance/#navigation","title":"Navigation","text":"<ul> <li>Home</li> <li>Project Roadmap</li> <li>System Design</li> <li>Performance Improvements</li> <li>Multi-threading Challenges</li> <li>Developer Guide</li> </ul>"},{"location":"ECE482FA24/ECE482P2/Performance/#performance-analysis-overview","title":"Performance Analysis Overview","text":"<p>How multi-threading, query optimization, and efficient resource allocation improved overall system throughput and responsiveness will be recorded.</p> <p>Key observations from the timing log: - Baseline Performance: The original system's performance metrics were extracted to serve as a benchmark. - Improved Metrics:     - Execution times have been significantly reduced across all query types.     - Parallel query handling demonstrates efficient core utilization with minimal overhead.     - The system scales effectively with the number of cores, as verified on the 64-core test server.</p>"},{"location":"ECE482FA24/ECE482P2/Performance/#log-insights","title":"Log Insights","text":""},{"location":"ECE482FA24/ECE482P2/Performance/#timing-highlights","title":"Timing Highlights","text":"<p>Below are the key timing statistics derived from the log:</p> Query Type sample lemondb Time (ms) our lemondb Time (ms) Improvement (%) many_insert_delete 18021 5446.0 230.9 many_read 18899 5386 250.1 few_insert_delete 15708 5538 183.6 few_read 23977 7145 235.6 single_insert_delete 29316 23434 25.1 single_read 38493 28934 33.0"},{"location":"ECE482FA24/ECE482P2/Performance/#optimization-techniques","title":"Optimization Techniques","text":"<ol> <li>Multi-threading:<ul> <li>Implemented parallel query execution.</li> <li>Dynamically allocated threads using the <code>--threads</code> argument.</li> </ul> </li> <li>Resource Management:<ul> <li>Improved memory allocation and reallocation strategies.</li> <li>Minimized contention and avoided deadlocks.</li> </ul> </li> <li>Query Parsing Enhancements:<ul> <li>Optimized ID assignment for continuous integer sequences.</li> </ul> </li> <li>Core Utilization:<ul> <li>Auto-detection of available cores for <code>--threads=0</code>.</li> </ul> </li> </ol>"},{"location":"ECE482FA24/ECE482P2/Performance/#next-steps","title":"Next Steps","text":"<ul> <li>Continue profiling to identify edge cases that may impact performance.</li> <li>Explore advanced optimizations (e.g., thread pooling, asynchronous I/O).</li> <li>Document any additional improvements in subsequent updates.</li> </ul>"},{"location":"ECE482FA24/ECE482P2/Performance/#navigation_1","title":"Navigation","text":"<ul> <li>Home</li> <li>Project Roadmap</li> <li>System Design</li> <li>Performance Improvements</li> <li>Multi-threading Challenges</li> <li>Developer Guide</li> </ul>"},{"location":"ECE482FA24/ECE482P2/RoadMap/","title":"Road Map","text":"<p>From beginning to end of the project, timeline and log </p>"},{"location":"ECE482FA24/ECE482P2/RoadMap/#navigation","title":"Navigation","text":"<ul> <li>Home</li> <li>Project Roadmap</li> <li>System Design</li> <li>Performance Improvements</li> <li>Multi-threading Challenges</li> <li>Developer Guide</li> </ul>"},{"location":"ECE482FA24/ECE482P2/RoadMap/#milestone-1-single-threaded-version-of-the-database-program","title":"Milestone 1 : Single threaded version of the database program","text":"<p>Input from the standard input, all required instructions working;</p> <p>Single Query  Read Functions Checklist</p> <ul> <li>[x] <code>SELECT</code> Select and display records from a table based on conditions</li> <li>[x] <code>SUM</code> Aggregate the sum of fields in records</li> <li>[x] <code>COUNT</code> Count the number of records based on conditions</li> <li>[x] <code>MIN</code> Find the minimum values in specified fields based on conditions</li> <li>[x] <code>MAX</code> Find the maximum values in specified fields based on conditions</li> <li>[x] <code>QUIT</code> Exit the database program</li> </ul> <p>Single Query Write Functions Checklist</p> <ul> <li>[x] <code>ADD</code> Add specified fields and store the result in a destination field</li> <li>[x] <code>SUB</code> Subtract fields and store the result in a destination field</li> <li>[x] <code>DUMP</code> Dump an existing table to a file</li> <li>[x] <code>DROP</code> Delete an existing table to nothing</li> <li>[x] <code>DELETE</code> Delete records from a table based on conditions</li> <li>[x] <code>INSERT</code> Insert a new record into a table</li> <li>[x] <code>UPDATE</code> Update records in a table based on conditions</li> <li>[x] <code>SWAP</code> Swap values between fields based on conditions</li> <li>[x] <code>DUPLICATE</code> Duplicate records based on conditions</li> <li>[x] <code>LOAD</code> Load a new table from a file</li> <li>[ ] <code>COPYTABLE</code> Copy a table to create new table with same contents and different name</li> <li>[ ] <code>TRUNCATE</code> Clear all data from a table</li> </ul> <p>Accidentally, <code>COPYTABLE</code> and <code>TRUNCATE</code> were not implemented in beginning, so these two functions are discovered and implemented during milestone 2 testing. During testing, there were some segmentation error issues required for debugging.</p>"},{"location":"ECE482FA24/ECE482P2/RoadMap/#milestone-2-multi-threaded-version-of-the-database-program","title":"Milestone 2 : Multi-threaded version of the database program,","text":"<p>Input from the standard input, three-quarter of the instructions implemented;</p> <p>For the following, efficient algorithm design for handling multiple parallel query execution was key concept. There was need to decide Data structure (Bitmap, Balanced Tree, Hash Table, etc...)</p> <p>1. Multi-Threading Implementation: - [x] Introduced C++ threading libraries including <code>&lt;thread&gt;</code>, <code>&lt;mutex&gt;</code>, <code>&lt;condition_variable&gt;</code>. - [x] Ensured thread synchronization using mutexes and condition variables. - [x] Implemented a basic thread pool to manage query execution.</p> <p>2. Optimization of Read-Only Queries: - [x] Ensured thread-safe execution for queries like <code>SELECT</code>, <code>SUM</code>, <code>COUNT</code>, <code>MIN</code>, <code>MAX</code>. - [x] Benchmarked performance improvements over the single-threaded implementation.</p> <p>3. Partial Write Functionality: - [x] Implemented three-quarters of write-based instructions including <code>INSERT</code>, <code>DELETE</code>, and <code>UPDATE</code>. - [x] Implemented missing functions <code>COPYTABLE</code> and <code>TRUNCATE</code></p> <p>4. Testing and Debugging: - [x] Conducted multi threaded stress tests to identify race conditions and deadlocks. - [x] Debugged segmentation fault issues encountered during concurrent execution.</p>"},{"location":"ECE482FA24/ECE482P2/RoadMap/#milestone-3-final-submission-fully-working-database-program","title":"Milestone 3 : Final submission, fully working database program","text":"<p>Supporting multi-threading, all required instruction, and command line arguments;</p> <p>1. Finalize Write-Only Queries: - [x] Completed implementation of all write-based queries, including <code>ADD</code>, <code>SUB</code>, <code>DUPLICATE</code>, and <code>SWAP</code>.</p> <p>2. Add Command-Line Arguments: - [x] Implemented <code>--threads=&lt;int&gt;</code>: Allows users to specify the number of threads or auto-detect available CPU cores when set to 0. - [x] Implemented <code>--listen &lt;filename&gt;</code>: Enables file-based query input.</p> <p>3. Performance Optimization: - [x] Profiled the system for bottlenecks and improved thread scheduling. - [x] Conducted final performance benchmarks to ensure superior efficiency compared to the single-threaded version.</p> <p>4. Comprehensive Testing: - [x] Validated correctness using the provided test suite and custom test scripts. - [x] Ran stress tests on the school server to ensure stability under heavy workloads.</p> <p>5. Documentation: - [x] Provided detailed explanations of:   - System Design: Architectural overview of LemonDB.   - Threading Model: Thread pool design, synchronization strategies, and concurrency handling.   - Optimizations: Performance improvements and challenges resolved.   - Testing Results: Summary of test outcomes and benchmarks.</p> <p>Final programming and documentation continued until the deadline date.</p>"},{"location":"ECE482FA24/ECE482P2/RoadMap/#changelogs-meeting-records","title":"Changelogs &amp; Meeting records","text":""},{"location":"ECE482FA24/ECE482P2/RoadMap/#meeting-1-20241023","title":"Meeting 1: 2024.10.23","text":"<p>Discussion: Our team met each other and briefly discussed the whole project schema. Our short term goal was following, to finish basic setup as soon as possible. - Fix source code compilation - Write comment for part of source code - Start writing milestone 1 - Initiate the Agile Development steps on gitea</p>"},{"location":"ECE482FA24/ECE482P2/RoadMap/#remarkable-change-logs","title":"Remarkable Change Logs","text":"<ul> <li>AddQuery/SubQuery: Added implementation for handling addition/subtraction operations.</li> <li>CountQuery: Added implementation for counting entries.</li> <li>DeleteQuery: Added implementation for deleting records.</li> <li>DuplicateQuery: Added implementation for duplicating records.</li> <li>InsertQuery: Added implementation for inserting new rows.</li> <li>MaxQuery/MinQuery: Added implementation or finding maxima/minima.</li> <li>SelectQuery: Added implementation for accessing data in a table.</li> <li>SumQuery: Added implementation for summing records.</li> <li>SwapQuery: Added implementation for swapping values</li> <li> <p>UpdateQuery: Added implementation for updating data in a table</p> </li> <li> <p>Table Management:</p> </li> <li>CopyTableQuery: Added implementation for copy a table.</li> <li>DropTableQuery: Added implementation for deleting an existing table.</li> <li>DumpTableQuery: Added implementation for dumping exisiting table to file.</li> <li>TruncateTableQuery: Added implementation for clear an existing table.</li> </ul>"},{"location":"ECE482FA24/ECE482P2/RoadMap/#meeting-2-20241030","title":"Meeting 2: 2024.10.30","text":"<p>Discussion: First step is to remove useless files from original LemonDB source code. Our team accomplished goals in previous meeting and target to do. - Write comment for part of source code - Start writing milestone 1</p> <p>Now, implement all query execution functions for single thread.</p>"},{"location":"ECE482FA24/ECE482P2/RoadMap/#remarkable-change-logs_1","title":"Remarkable Change Logs","text":"<ul> <li>QueryExecuter, QueryExecuterHelper, QueryThreadPool: Introduced thread pool management. Changed the logic of query execution from single-thread to multithread, used a thread pool to manage the thread.</li> </ul>"},{"location":"ECE482FA24/ECE482P2/RoadMap/#meeting-3-20241110","title":"Meeting 3: 2024.11.10","text":"<p>Discussion: - Milestone 1 single-threaded functions were mostly completed but required passing all test cases to mark true completion. - Focus shifted to designing an efficient algorithm for handling parallel query execution. Key considerations included:   - Selection of data structures (Bitmap, Balanced Tree, Hash Table, etc.) for concurrent data access.   - Synchronizing shared resources to prevent race conditions and ensure thread safety.</p>"},{"location":"ECE482FA24/ECE482P2/RoadMap/#remarkable-change-logs_2","title":"Remarkable Change Logs","text":"<ul> <li>System Optimization:</li> <li>Improved resource handling for better memory and time efficiency during query execution.</li> <li>Improved mutex handling for better thread safety.</li> <li>Refined algorithms for query operations to reduce overhead and improve response times.</li> </ul>"},{"location":"ECE482FA24/ECE482P2/RoadMap/#meeting-4-20241117","title":"Meeting 4: 2024.11.17","text":"<p>Discussion: - Successfully implemented thread pool for efficient multi-threaded query execution. - Identified the need to create custom test scripts for testing the program on the school server. - Evaluated and improved thread locking mechanisms to resolve performance bottlenecks.</p>"},{"location":"ECE482FA24/ECE482P2/RoadMap/#navigation_1","title":"Navigation","text":"<ul> <li>Home</li> <li>Project Roadmap</li> <li>System Design</li> <li>Performance Improvements</li> <li>Multi-threading Challenges</li> <li>Developer Guide</li> </ul>"},{"location":"ECE482FA24/ECE482P3/Design/","title":"System Design","text":"<p>Software design schema structure overview and description</p>"},{"location":"ECE482FA24/ECE482P3/Design/#navigation","title":"Navigation","text":"<ul> <li>Home</li> <li>Project Roadmap</li> <li>Risk Assessment</li> <li>Performance Analysis</li> <li>Developer Guide</li> </ul>"},{"location":"ECE482FA24/ECE482P3/Design/#software-architecture-overview","title":"Software Architecture Overview","text":"<p>The project implements a lottery scheduling algorithm in kernel space using eBPF.  This section provides an overview of the system's key components, workflow, and design considerations.  The architecture leverages modern kernel technologies to achieve a balance of performance and extensibility.</p>"},{"location":"ECE482FA24/ECE482P3/Design/#system-workflow","title":"System Workflow","text":"<ul> <li>Run <code>src/start.sh</code> to start the project. </li> <li>Queue and manage processes by shared dispatch queues (DSQ) </li> <li>Allocate and schedule tickets by custom scheduler </li> <li>Use kernel probes and eBPF tracing tools to monitor task scheduling and performance in real time.  </li> </ul>"},{"location":"ECE482FA24/ECE482P3/Design/#lottery-scheduling-algorithm","title":"Lottery Scheduling Algorithm","text":"<ol> <li>Assign tickets to each process based on priority.</li> <li>Build a ticket pool with entries proportional to ticket counts.</li> <li>Select a random ticket to choose the next process to run.</li> <li>Allocate a time slice to the chosen process.</li> <li>Re queue or terminate the process based on its state. </li> </ol>"},{"location":"ECE482FA24/ECE482P3/Design/#key-components","title":"Key Components","text":""},{"location":"ECE482FA24/ECE482P3/Design/#bootloader","title":"Bootloader","text":"<p>A bootloader is a small program that loads the operating system (OS) into memory when a computer or device is powered on or reset. It acts as the initial step in the booting process, ensuring that the necessary system files are loaded for the OS to function properly.</p>"},{"location":"ECE482FA24/ECE482P3/Design/#ebpf-extended-berkeley-packet-filter","title":"eBPF (Extended Berkeley Packet Filter)","text":"<p>eBPF is an advanced kernel technology that allows users to run secure and high-performance programmable code within the operating system kernel. Originally, eBPF was designed for network packet filtering. However, it continuously evolved to support use cases in monitoring, security, networking, and performance optimization. eBPF programs are verified and loaded into the kernel, enabling functionality extension without modifying the kernel source code, all while maintaining low overhead and high security.</p>"},{"location":"ECE482FA24/ECE482P3/Design/#ebpf-events-monitoring","title":"eBPF Events monitoring","text":"<p>Following <code>bpftrace</code> command can be used to monitor scheduling events in real time</p> <pre><code>sudo bpftrace -e 'kprobe:schedule { printf(\"Scheduled Process : %s\\\\n\", comm); }'\n</code></pre> <p><code>kprobe:schedule</code> attach kernel probe to <code>schedule</code> function in kernel.</p> <p>This single line can leverage eBPF to monitor events.  </p>"},{"location":"ECE482FA24/ECE482P3/Developer/","title":"Developer Guide","text":"<p>Installation and Testing Guideline </p>"},{"location":"ECE482FA24/ECE482P3/Developer/#navigation","title":"Navigation","text":"<ul> <li>Home</li> <li>Project Roadmap</li> <li>Risk Assessment</li> <li>Performance Analysis</li> <li>Developer Guide</li> </ul>"},{"location":"ECE482FA24/ECE482P3/Developer/#implement-in-user-space","title":"Implement in user space","text":"<p>First of all, we implemented the idea of lottery scheduling in user space as our first demonstration. Processes are assigned tickets based on their nice values. The process with more tickets has a higher chance of being selected.</p>"},{"location":"ECE482FA24/ECE482P3/Developer/#one-line-ebpf","title":"One-Line eBPF","text":"<p>Focus on basic use cases like system monitoring calls or capture process scheduling events. </p> <pre><code>sudo bpftrace -e 'kprobe:schedule { printf(\"Scheduled Process: %s\\\\n\", comm); }'\n</code></pre>"},{"location":"ECE482FA24/ECE482P3/Developer/#prerequisites","title":"Prerequisites","text":"<ul> <li>Linux Operating System </li> <li><code>GCC</code> (GNU Compiler Collection) </li> <li><code>make</code> for build automation</li> <li><code>git</code> for version control</li> <li>Optional: <code>valgrind</code> for memory debugging</li> </ul>"},{"location":"ECE482FA24/ECE482P3/Developer/#environment-setup","title":"Environment Setup","text":"<p>Clone Repository  <pre><code>$ git clone ssh://git@focs.ji.sjtu.edu.cn:2222/ece482-24fa/p3team-02.git  \n$ cd p3team-02\n</code></pre> Build Project  <pre><code>$ cd src\n$ make vmlinux.h \n$ make NAME=simple_scheduler obj\n</code></pre> Start scheduler demo  <pre><code>$ ./start.sh\n$ sudo cat /sys/kernel/debug/tracing/trace_pipe\n</code></pre> Stop scheduler demo  <pre><code>$ ./stop.sh\n</code></pre> Clean compiled files  <pre><code>$ make NAME=simple_scheduler clean\n$ make \n</code></pre> Then, recompile is successful. </p> <pre><code>make vmlinux.h \nmake NAME=simple_scheduler obj\n\nsudo ./start.sh\n\nsudo cat /sys/kernel/debug/tracing/trace_pipe\n\nsudo ./stop.sh\n\nmake NAME=simple_scheduler clean\n</code></pre> <p>This will be final. </p>"},{"location":"ECE482FA24/ECE482P3/Developer/#debug-and-test","title":"Debug and Test","text":"<p>Use <code>trace_pipe</code> for process monitoring  <pre><code>sudo cat /sys/kernel/debug/tracing/trace_pipe\n</code></pre> Use debugging tools like <code>valgrind</code> for memory safety.  <pre><code>valgrind ./start.sh\n</code></pre></p>"},{"location":"ECE482FA24/ECE482P3/Home/","title":"Project 3 Lottery Scheduling","text":"<p>2024FA ECE4820 Introduction to Operating Systems</p>"},{"location":"ECE482FA24/ECE482P3/Home/#navigation","title":"Navigation","text":"<ul> <li>Home</li> <li>Project Roadmap</li> <li>Risk Assessment</li> <li>Performance Analysis</li> <li>Developer Guide</li> </ul>"},{"location":"ECE482FA24/ECE482P3/Home/#team-members-roles-and-contributions","title":"Team Members, Roles and contributions","text":"<p>Jae Heung Park</p> <ul> <li>Documentation of <code>README</code> file and Wiki for project release.</li> <li>Supportive contribution to the project with effort</li> </ul> <p>He Wentao</p> <ul> <li>Project basic setup from given source code and functions.</li> <li>Compiling and debugging codes to run test cases in local environment.</li> <li>Project structure design and plan</li> </ul> <p>Wang Rui</p> <ul> <li>Project basic setup from given source code and functions.</li> <li>Compiling and debugging codes to run test cases in local environment.</li> <li>Project structure design and plan</li> </ul>"},{"location":"ECE482FA24/ECE482P3/Home/#overview-of-ebpf-implementation","title":"Overview of eBPF implementation","text":"<p>For now, since we have get the idea of how to implement the lottery scheduler in user space.  The next thing to do is to implement it in kernel space with eBPF.  We referred to the websites and resources provided in wiki, especially in the <code>sched-ext</code> repo. By reading through some sample codes in this repo and refer to what we have learned in the lab,  we noticed that we need to implement <code>enqueue</code>, <code>dispatch</code> and <code>init</code> these three functions.</p>"},{"location":"ECE482FA24/ECE482P3/Home/#key-functions","title":"Key Functions","text":"<ul> <li><code>enqueue</code>: Adds tasks to dispatch queue.</li> <li><code>dispatch</code>: Selects tasks for execution based on ticket values.</li> <li><code>init</code>: Initializes the scheduler and shared dispatch queues.</li> </ul> <pre><code>struct sched_ext_ops sched_ops = {\n    .enqueue = (void *)sched_enqueue,\n    .dispatch = (void *)sched_dispatch,\n    .init = (void *)sched_init,\n    .flags = SCX_OPS_ENQ_LAST | SCX_OPS_KEEP_BUILTIN_IDLE,\n    .name = \"p3_scheduler\"};\n</code></pre>"},{"location":"ECE482FA24/ECE482P3/Home/#ticket-management","title":"Ticket Management","text":"<p>The first problem we met with was how to store all the ticket information.  Since we cannot modify a structure called <code>task_struct</code>,  so we use a map with hash to store all the ticket information:</p> <pre><code>struct\n{\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __type(key, __u32); // task UID\n    __type(value, __u64);\n    __uint(max_entries, 1024);\n} task_tickets_map SEC(\".maps\");\n</code></pre>"},{"location":"ECE482FA24/ECE482P3/Home/#shared-dispatch-queues","title":"Shared Dispatch Queues","text":"<p>Next, we initialized two shared Dispatch Queue (DSQ). A shared dispatch queue used to coordinate the scheduling of different tasks.  It typically acts as a buffer for tasks or an intermediary for task scheduling, allowing interaction between different schedulers or task producers and consumers.</p> <pre><code>s32 BPF_STRUCT_OPS_SLEEPABLE(sched_init)\n{\n    bpf_printk(\"Scheduler initialized with DSQ ID: %d\\n\", SHARED_DSQ_ID);\n    int create_1 = scx_bpf_create_dsq(SHARED_DSQ_ID, -1);\n    int create_2 = scx_bpf_create_dsq(WINNER_DSQ_ID, -1);\n    return create_1 &amp;&amp; create_2;\n}\n</code></pre> <p>As you can see, it's very simple to implement.</p> <p>When enqueue tasks, we noticed that there is a variable called <code>enq_flags</code>  and we think that it's used for signal the priority of different tasks.  So we use it to help decide the number of tickets.  Basically, we first generate a random number between 1 and 100 as the ticket number,  then for high priority, we add 100 more; and for low priority, we minus 100.  As you can see, the ticket number signals the priority.</p> <p>When choosing which task to run, we get a random number, than find the corresponding task.</p> <p>At last, we want to talk about something about discussion.  First of all, we noticed that <code>bpf_task_from_pid</code> has different performance on different version of kernel.  For example, it works fine on version 6.12 on ubuntu while it meets some problem on version 6.12 on arch.  To avoid problems, we have to use multiple maps to store information like slice, task ID.  But we eventually managed to make it work.</p> <p>Another thing we want to discuss is about the ticket method.  For now, we tried to implement <code>nice</code> with <code>enq_flags</code> variable to decide the ticket number.  But we only had time to implement a rough one, it can be more precise.</p> <p>Moreover, we noticed that our scheduler fails after running for a while.  The performance is like the whole computer stucks and then our program was kicked out by the kernel.</p>"},{"location":"ECE482FA24/ECE482P3/Performance/","title":"System Design","text":"<p>Software design schema structure overview and description</p>"},{"location":"ECE482FA24/ECE482P3/Performance/#navigation","title":"Navigation","text":"<ul> <li>Home</li> <li>Project Roadmap</li> <li>Risk Assessment</li> <li>Performance Analysis</li> <li>Developer Guide</li> </ul>"},{"location":"ECE482FA24/ECE482P3/Performance/#lottery-scheduling","title":"Lottery Scheduling","text":"<p>Lottery Scheduling is a probabilistic scheduling algorithm used in multi-tasking operating systems, particularly for CPU resource allocation. The core idea is to assign a number of \"lottery tickets\" to each process, and the process that wins the lottery (i.e., the one with the randomly drawn ticket) is granted CPU time. This approach ensures fair distribution of CPU time, with the option to adjust the number of tickets to prioritize certain processes.</p> <ol> <li>Ticket Allocation: Each process is assigned a certain number of tickets based on its weight or priority. The more tickets one process have, the higher chance to be scheduled.</li> <li>Randomness: CPU allocation is determined by a random lottery draw, ensuring fairness in scheduling.</li> <li>Priority Adjustment: The number of tickets can be adjusted to change the process's priority. More tickets mean higher priority.</li> <li>Use Case: Ideal for scenarios where fair resource distribution and flexible priority adjustment are needed.</li> </ol>"},{"location":"ECE482FA24/ECE482P3/Risk/","title":"Project 3 Lottery Scheduling Risk Assessment","text":"<p>2024FA ECE4820J Introduction to Operating Systems</p>"},{"location":"ECE482FA24/ECE482P3/Risk/#navigation","title":"Navigation","text":"<ul> <li>Home</li> <li>Project Roadmap</li> <li>Risk Assessment</li> <li>Performance Analysis</li> <li>Developer Guide</li> </ul>"},{"location":"ECE482FA24/ECE482P3/Risk/#risk-categories","title":"Risk Categories","text":""},{"location":"ECE482FA24/ECE482P3/Risk/#1-technical-risks","title":"1. Technical Risks","text":"<ul> <li> <p>Complexity of Algorithm: Difficulty in implementing a fair and efficient lottery scheduling algorithm. Mitigation: Break down tasks and perform early unit tests.</p> </li> <li> <p>Performance under Load: The algorithm may degrade as the number of processes increases. Mitigation: Test with varying loads and optimize ticket distribution.</p> </li> </ul>"},{"location":"ECE482FA24/ECE482P3/Risk/#2-operational-risks","title":"2. Operational Risks","text":"<ul> <li> <p>Time Constraints: Limited time may delay progress. Mitigation: Use a structured timeline and monitor progress regularly.</p> </li> <li> <p>Testing Complexity: Difficulty in creating comprehensive test cases for a probabilistic algorithm. Mitigation: Develop a broad set of test cases and automate tests.</p> </li> </ul>"},{"location":"ECE482FA24/ECE482P3/Risk/#3-human-resource-risks","title":"3. Human Resource Risks","text":"<ul> <li>Lack of Expertise: Team members may be unfamiliar with eBPF or kernel programming. Mitigation: Allocate time for training and practice.</li> </ul>"},{"location":"ECE482FA24/ECE482P3/Risk/#4-external-risks","title":"4. External Risks","text":"<ul> <li>System Compatibility: Compatibility issues with the testing environment. Mitigation: Ensure portability and test on multiple platforms, like ubuntu, arch, etc.</li> </ul>"},{"location":"ECE482FA24/ECE482P3/RoadMap/","title":"Project 3 Lottery Scheduling RoadMap","text":"<p>2024FA ECE4820 Introduction to Operating Systems</p>"},{"location":"ECE482FA24/ECE482P3/RoadMap/#navigation","title":"Navigation","text":"<ul> <li>Home</li> <li>Project Roadmap</li> <li>Risk Assessment</li> <li>Performance Analysis</li> <li>Developer Guide</li> </ul>"},{"location":"ECE482FA24/ECE482P3/RoadMap/#documentation-plan","title":"Documentation Plan","text":"<ol> <li>Lottery Scheduling overview, key principles</li> <li>Code structure design choices and explanations</li> <li>Testing tools and methodologies in function, performance, edge cases</li> <li>Test result summary and performance analysis of throughput and latency</li> </ol>"},{"location":"ECE482FA24/ECE482P3/RoadMap/#development-strategies","title":"Development Strategies","text":""},{"location":"ECE482FA24/ECE482P3/RoadMap/#task-list","title":"Task List","text":"<ol> <li>Lottery Scheduling - 6 hours</li> <li>Solve Simple Investigation Questions - 1 hours</li> <li>Test Program for Lottery - 15 hours</li> </ol>"},{"location":"ECE482FA24/ECE482P3/RoadMap/#1-lottery-scheduling","title":"1. Lottery Scheduling","text":"<ul> <li>Action Plan:</li> <li>Study the basic principles of lottery scheduling and its implementation.</li> <li>Write the initial scheduling algorithm code and test its performance under various loads.</li> <li> <p>Debug and optimize the code to ensure stability and efficiency in a multitasking environment.</p> </li> <li> <p>Difficulty Evaluation:   High. Our major task</p> </li> <li> <p>Time Estimation:   Estimated to take 6 hours:  </p> </li> <li>Research and design: 1 hours  </li> <li>Code implementation: 3 hours  </li> <li>Debugging and optimization: 2 hours</li> </ul>"},{"location":"ECE482FA24/ECE482P3/RoadMap/#2-test-program-for-lottery","title":"2. Test Program for Lottery","text":"<ul> <li>Action Plan:</li> <li>Write test cases to cover different scheduling scenarios.</li> <li>Run the tests and record the results to verify the correctness of the lottery scheduling algorithm.</li> <li> <p>Conduct performance testing to ensure the algorithm performs well under different loads.</p> </li> <li> <p>Difficulty Evaluation:   Medium. Would be very fast if our original design is good enough.</p> </li> <li> <p>Time Estimation:   Estimated to take 2 hours:  </p> </li> <li>Write test cases: 0.5 hours  </li> <li>Execute tests and record results: 1.5 hours  </li> <li>Debugging and fixing issues: it depends</li> </ul>"},{"location":"ECE482FA24/ECE482P3/RoadMap/#total-time-estimation","title":"Total Time Estimation:","text":"<ul> <li>Lottery Scheduling: 6 hours  </li> <li>Solve Simple Investigation Questions: [ ] hours  </li> <li>Test Program for Lottery: 2 hours  </li> </ul> <p>Total: [] hours</p>"}]}