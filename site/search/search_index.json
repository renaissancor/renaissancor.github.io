{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"AR250402/","title":"AR250402","text":""},{"location":"AR250402/#copy-operator-and","title":"Copy Operator and","text":"<pre><code>class CNew\n{\nprivate:\n    int m_i; \n    short m_s; \n\npublic: \n    void SetInt(int _a)\n    {\n        m_i = a; \n    }\n    // Default Assignment operator \n    void operator=(const CNew&amp; _Other){\n        m_i = _Other.m_i; \n        m_s = _Other.m_s; \n\n        return *this; \n    }\npublic: \n    // \uae30\ubcf8 Default Copy operator \ubb34\ub825\ud654 \n    CNew(const CNew &amp; _Other) = delete; // \ub9c9\uc544 \ubc84\ub9ac\uae30 \n    CNew(const CNew &amp; _Other)\n    :m_i(_Other.m_i), m_s(_Other.m_s)\n    {}\n}\n</code></pre> <p>Basic Generator </p> <p>CNew Inst1; // \uae30\ubcf8 \uc0dd\uc131\uc790  CNew Inst1(); // \uc774\ub807\uac8c \uc0dd\uc131 \uc2dc \ud568\uc218 \uc120\uc5b8\uc73c\ub85c \ucef4\ud30c\uc77c\ub7ec\uac00 \uc624\ud574  Inst1.SetInt(10); </p> <p>Copy Generator </p> <p>\ubcf5\uc0ac \uc0dd\uc131\uc790 \uae30\ubcf8 \uc0dd\uc131\uc790 \uc548 \ub9cc\ub4e4\ub2e4\uac00 \ubcf5\uc0ac \uc0dd\uc131\uc790 \uc9c1\uc811 \ub9cc\ub4e4 \uacbd\uc6b0  \uae30\ubcf8 \uc0dd\uc131\uc790 \uad6c\ud604\uc744 \uc78a\uc5b4\ubc84\ub9bc  \ubcf5\uc0ac \uc0dd\uc131\uc790\ub9cc \ub9cc\ub4e4\uba74 \uae30\ubcf8 \uc0dd\uc131\uc790 </p> <p>CNew Inst2(Inst1); </p> <p>Originally no need to make copy operator  But if copy function is implemented  The compiler originally based copy </p> <p>\uc5b4\ub5a0\ud55c \uacbd\uc6b0\uc5d0\ub3c4 \uc0dd\uc131\uc790\uac00 \uad6c\ud604\ub41c \uac8c \uc788\uc73c\uba74 \uae30\ubcf8 \uc0dd\uc131\uc790\uac00 \ucef4\ud30c\uc77c\ub7ec\uc5d0 \uc758\ud574 \uc790\ub3d9 \uc0dd\uc131\ub418\uc9c0 \uc54a\uc74c</p> <p>\ubcf5\uc0ac \uc0dd\uc131\uc790 \uc0dd\uc131 \uc2dc \uae30\ubcf8 \uc0dd\uc131\uc790  \uc989 \ud0c0 \uc0dd\uc131\uc790\ub97c\ub97c \ub9cc\ub4e4 \uc2dc \uae30\ubcf8 \uc0dd\uc131\uc790\ub3c4 \uac19\uc774 \ub9cc\ub4e4\uc5b4\uc57c\ud568 </p> <p>\ub300\uc785 \uc5f0\uc0b0\uc790  CNew Inst3;  Inst3 = Inst1; </p>"},{"location":"Homeworks/h1/","title":"Index","text":""},{"location":"Homeworks/h1/#assignment-i","title":"Assignment I","text":"<p>ECE4821 FA2024 Introduction to Operating Systems</p> <p>518370990004 Jae Heung Park</p>"},{"location":"Homeworks/h1/#exercise-1-review","title":"Exercise 1 Review","text":"<p>Explain the difference between the stack and the heap.</p> <p>Computer can allocate memory in two possible ways: Stack and Heap allocation. </p> Feature Stack Heap Memory Allocation Static, handled automatically Dynamic, handled manually Memory Management Managed by the system Managed by the programmer Data Structure FILO (First In Last Out) Tree Structure Access Speed Relatively Faster Relatively Slower Lifetime Tied to function call (short-lived) Flexible, persists until freed Size Limit Limited, generally 1-8 MB Larger, limited by available memory Error Types Stack Overflow Memory Leakage Example <code>int x = 10;</code> (Local Variable) <code>int* x = malloc(sizeof(int));</code> <p>Since the order of programming in C/C++ is defined, putting all variables in linear order will not cause problem.  Thus, in static memory allocation, static variables can be handled by Stack in order of function call.  However, dynamic memory allocation means variables can be created or removed directly.  So, linear data structure is not available to manage order of variables, so heap data structure is more likely.  </p>"},{"location":"Homeworks/h1/#exercise-2-personal-research","title":"Exercise 2 Personal research","text":""},{"location":"Homeworks/h1/#21-briefly-explain-what-operations-are-performed-when-a-computer-is-powered-on","title":"2.1 Briefly explain what operations are performed when a computer is powered on.","text":"<p>When the computer is powered on, 4 steps are followed. </p> <ol> <li>POST (Power On Self Test) will test computer hardware before OS is loaded. </li> <li>BIOS (Basic Input/Output System) initialize and control basic hardware components including monitor, keyboard, HDD.</li> <li>Bootloader is located from Motherboard attached storage by BIOS </li> <li>OS kernel is loaded by bootloader so that OS can control bootloader now. </li> </ol> <p>What is the role of the BIOS and how does it interact with the OS?</p> <ol> <li>Initialize hardware components and check their functionality before OS loading. </li> <li>Boot processing will locate and load bootloader from storage. </li> <li>When bootloader launches OS, BIOS still runs on background to support features that might be useful to OS. </li> </ol>"},{"location":"Homeworks/h1/#22-in-a-few-words-explain-what-are-hybrid-and-exo-kernels","title":"2.2 In a few words explain what are hybrid and exo kernels.","text":"<p>Monolithic Kernel is simple kernel form, so that both user and kernel are in same address.  Since user and kernel use same space, process speed is faster, architecture is simple  and flexible. However, entire volume of OS and kernel will be in large scale, making  OS unstable and insecure.  Linux, UNIX are common examples. </p> <p>Microkernel divides user space and kernel space. Thus, it is more secure and stable.  Also, it will use relatively less amount of volume.  However, since user and kernel will be divided, architecture is complicated and  integration of kernel and user have several inconveniences.  Also, several functions available on monolithic kernel might be limited. Minix is example. </p> <p>Hybrid Kernel is a combination of two kernel architecture above with smaller kernel volume.  It has more various functions than microkernel, but still has less functions than monolithic kernel.  Also, architecture design will be even more complicated than monolithic kernel.  Microsoft Windows is example. </p> <p>Exo Kernel is currently in research by UC Berkeley rather than utilized in industries.  It is developed concept based on monolithic kernel, with better speed and security.  However, architecture will be more sophisticated, with potentially inefficient use  of computer resources. </p>"},{"location":"Homeworks/h1/#exercise-3-course-application","title":"Exercise 3 Course Application","text":""},{"location":"Homeworks/h1/#31-which-of-the-following-instructions-should-only-be-allowed-in-kernel-mode-explain","title":"3.1 Which of the following instructions should only be allowed in kernel mode? Explain.","text":"<ul> <li>a) Disable all interrupts </li> <li>b) Read the time-of-day clock </li> <li>c) Set the time-of-day clock </li> <li>d) Change the memory map</li> </ul> <p>(b) is allowed in both user mode and kernel mode.  (a), (c), (d) are allowed only in kernel mode. </p> <p>Disabling all interruption in OS pipeline must be handled by kernel, since it will be  entire reset of the process pipeline. User should not have full comprehension and  access of the entire OS. </p> <p>Read the time of the day can be done in user level, especially considering the different  time zone shared globally by several users. Basic time might be setup into UTC 0, and  additional time zone calculation can be done for each user mode. </p> <p>However, set the time of the day must be in kernel level. Time is very closely  related to the entire process of the Operating System and its logs. Thus, user level  time clock setup should be prohibited. </p> <p>Memory map is also directly related to the operating system. Data structure of stack  and heap to store each kind of memory should be handled under entire kernel.  Thus, user level memory map access might compromise the running process of entire OS. </p>"},{"location":"Homeworks/h1/#32-consider-a-system-that-has-two-cpus-and-each-cpu-is-composed-of-two-threads","title":"3.2 Consider a system that has two CPUs and each CPU is composed of two threads.","text":"<p>Suppose three programs, P0, P1, and P2, are started with run times of 5, 10 and 20 ms, respectively.  How long will it take to complete the execution of these programs?  Assume that all three programs are 100% CPU bound, do not block during execution,  and do not change CPUs once assigned. </p> <p>There are 2 CPUs, and 2 threads per 1 CPU, thus 4 threads exist. One thread can handle  one process simultaneously, so all three programs P0, P1, and P2 are able to start  simultaneously without waiting for thread scarcity. </p> <p>Execution time for each program will be P0 5ms, P1 10ms, P2 25ms.  If each thread take each task simultaneously,  P2 end time <code>25ms</code> will be complete time.  Suppose core can take each task simultaneously.  If program execution is optimized, P0 and P2 will  be assigned together, so that P1 will start after  P0 ends, resulting in same <code>25ms</code>. However, if  programs execution list is in FIFO queue order, then  it will take <code>30ms</code> since core handling.  In worst case, if all projects require 2 cores,  then time consumption will be <code>40ms</code>. </p>"},{"location":"Homeworks/h1/#exercise-4-command-lines-on-a-unix-system","title":"Exercise 4 Command lines on a Unix system","text":"<p>On Linux use the command line to: 1. Create a new user; 2. List all the currently running processes; 3. Display the characteristics of the CPU and the available memory; 4. Redirect random output read from a system device, into two different files; 5. Concatenate the two previous files; 6. Read the content of the resulting file as hexadecimal values (in other words find a command to    read a file as hexadecimal values); 7. Go at the root of the kernel source you downloaded in l2 and use a single command to find all    the files in with the word mutex in their name and containing the whole word nest_lock;</p> <p>Note: follow the \u201cprogramming exercises\u201d guidelines and save the list of commands in a shell file (.sh).</p> <p>Shell commandlines in <code>e4.sh</code> file.</p>"},{"location":"Homeworks/h1/#exercise-5-simple-problem","title":"Exercise 5 Simple problem","text":"<p>One reason GUIs were initially slow to be adopted was the cost of the hardware needed to support them. How much video RAM is needed to support a 25 lines by 80 rows character monochrome text screen? How much for a 1024 x 768 pixel 24-bit color bitmap? Assuming the cost of this RAM in the 1980es was $5/KB what was the price of those two solutions? How much is it now?</p> <p>Monochrome text character is ASCII, 2^8=256 bits, 1 byte per each character.  The calculation will be 25 X 80 = 2000 Bytes = 2 KB </p> <p>One pixel is composed of 3 RGB values, each value from 0 to 255.  It is 1 byte per each color, so 3 bytes per each pixel.  Total memory required per each screen will be  3 X 1024 X 768 = 2359296 Bytes / 1024 = 2304 KB / 1024 = 2.25 MB </p> <p>In 1980, dealing 1024 X 768 RGB pixels represented  2304 KB X 5 $ = 11520 USD. Ignoring inflation for 40 years,  this is enough to buy the 275 latest SK Hynix DDR5 16GB RAM,  currently 42 USD per each in Amazon, for 2024 October. </p> <p>However, currently abandoned computers in school with 2GB RAM  will be far more than enough to handle 3MB memory. </p>"},{"location":"Homeworks/h2/","title":"Index","text":""},{"location":"Homeworks/h2/#assignment-ii","title":"Assignment II","text":"<p>ECE4820 FA2024 Introduction to Operating Systems 518370990004 Jae Heung Park</p>"},{"location":"Homeworks/h2/#exercise-1","title":"Exercise 1","text":"<p>A few years ago when computers featured less RAM it is was common to increase it in order to enhance CPU performance. In order to better understand the link between the two we now create a simple model for multiprogramming. We assume all the processes to be similar and spending the same fraction p of their time waiting for Input/Output (I/O) to complete.</p>"},{"location":"Homeworks/h2/#1-what-is-the-probability-for-n-processes-to-be-waiting-at-the-same-time-then-express-the-cpu-utilisation-as-a-function-of-n","title":"1. What is the probability for n processes to be waiting at the same time, then express the CPU utilisation as a function of n?","text":"<p>Probability $p^n$</p> <p>CPU Utilization $U(n)=1-p^n$ where $n$ is number of process. </p>"},{"location":"Homeworks/h2/#2-sketch-the-curve-representing-the-cpu-utilisation-as-a-function-of-the-number-of-processes-for-the-following-values-of-p-25-60-and-90","title":"2. Sketch the curve representing the CPU utilisation as a function of the number of processes for the following values of p: 25%, 60% and 90%.","text":"<p>Suppose CPU Utilization $U$ function for $n$ number of process $U(n)$. </p> <p></p>"},{"location":"Homeworks/h2/#3-a-certain-old-computer-has-256-mb-of-ram-once-loaded-a-light-operating-system-uses-96-mb-of-ram","title":"3. A certain old computer has 256 MB of RAM, once loaded a light operating system uses 96 MB of RAM.","text":"<p>Several programs are launched each of them using 48 MB.</p> <p>a) How many processes can be store simultaneously in memory?</p> <p>Given 256 MB RAM, OS uses 96 MB, 160 MB left and  each process takes 48 MB.  Suppose 4 processors share 160 MB, then it is 40 MB per each,  which is less than 48 MB required for process to run.  If 3 processors share 160MB, then its capacity is 53.3 per each,  enough to handle each process.  Thus, <code>3</code> processes can be store simultaneously in memory. </p> <p>b) Assuming an average of 90% I/O waiting time what is the CPU utilisation?</p> <p>Since $p=0.9$ and $n=3$,  $U(n)=1-p^n=1-(0.9)^{3}=1-0.729=0.271$  Thus, CPU utilization <code>U=27.1%</code></p> <p>c) What is the effect of adding 256 MB, 512 MB and 1024 MB of RAM. Argue on which amount would be the most beneficial and would be worth the investment.</p> <p>$256 + 256 \\rightarrow (512 - 96) / 48 = 416 / 48 = 8.67 \\rightarrow U(8)=1\u22120.90^{8}=1\u22120.430=0.570$</p> <p>$256 + 512 \\rightarrow (768 - 96) / 48 = 672 / 48 = 14 \\rightarrow U(8)=1\u22120.90^{14}=1\u22120.206=0.794$ </p> <p>$256 + 1024 \\rightarrow (1280 - 96) / 48 = 1184 / 48 = 24.67 \\rightarrow U(8)=1\u22120.90^{24}=1\u22120.121=0.879$ </p>"},{"location":"Homeworks/h2/#ex-2-understanding-system-calls","title":"Ex. 2 \u2014 Understanding system calls","text":""},{"location":"Homeworks/h2/#1-briefly-introduce-strace-and-ltrace-explain-they-could-be-helpful-along-the-semester","title":"1. Briefly introduce strace and ltrace. Explain they could be helpful along the semester.","text":"<p>Both <code>strace</code> and <code>ltrace</code> are trace debugging tools. </p> <p><code>strace</code> traces based on system calls by following interaction between Linux kernel and program.  </p> <p><code>ltrace</code> traces library calls instead of system call.  This shows logs of library dependent function calls.</p>"},{"location":"Homeworks/h2/#2-what-are-the-manpages-sections-for-system-calls-and-library-calls","title":"2. What are the manpages sections for system calls and library calls?","text":"<p>In convention, system calls are in section 2 and library calls are in section 3. </p> <p>Use command like  <code>man 2 &lt;system_call_name&gt;</code> for system calls and  <code>man 3 &lt;library_function_name&gt;</code> for library functions. </p>"},{"location":"Homeworks/h2/#3-system-calls","title":"3. System calls.","text":"<p>a) What are the main types of system calls?</p> <ol> <li>Process management: creation, termination, control <code>exit(0)</code>, <code>fork()</code>, <code>exec()</code> </li> <li>File management: open close read write <code>open()</code>, <code>close()</code>, <code>read()</code>, <code>write()</code> </li> <li>Device management: IO operation, peripheral interaction <code>ioctl()</code> </li> <li>Information maintenance: system level info setup and retrieval <code>getpid()</code>, <code>getuid()</code>, <code>setuid()</code> </li> <li>Inter Process Communication IPC: send message <code>pipe()</code>, <code>msgsnd()</code> </li> </ol> <p>b) Run strace on the ls command and classify all the listed system calls.</p> <pre><code>strace ls \n</code></pre> <p>output file on <code>strace_ls.txt</code></p> <ul> <li>Process protocol <code>execve(\"/usr/bin/ls\", [\"ls\"], 0xfffff3920cf0 /* 53 vars */) = 0</code></li> <li>Memory management <code>brk, mmap, munmap</code> </li> <li>File management <code>openat(AT_FDCWD, \"...\"), read(...), close(...)</code></li> <li>Device management <code>ioctl(...)</code></li> <li>Information maintenance <code>statfs(...), getrandom(...)</code></li> <li>Communication <code>prlimit64(...)</code></li> <li>Exit <code>exit_group(0)</code></li> </ul> <p>c) Select a line of your choice in strace output and explain its meaning.</p> <pre><code>openat(AT_FDCWD, \".\", O_RDONLY|O_NONBLOCK|O_CLOEXEC|O_DIRECTORY) = 3\n</code></pre> <ul> <li><code>openat()</code>: Open file relative to a directory file descriptor. </li> <li><code>AT_FDCWD</code> means directory is current working directory.</li> <li><code>/lib/aarch64-linux-gnu/libselinux.so.1</code> File opened in SELinux shared library.</li> <li><code>O_RDONLY|O_CLOEXEC</code>: File is opened in read-only mode <code>O_RDONLY</code>, and <code>O_CLOEXEC</code> means file descriptor will be automatically closed if process performs <code>exec()</code> system call.</li> <li><code>3</code>: This is the file descriptor returned by the system call. </li> </ul> <p>d) How to attach strace to a running process? Describe a scenario where this could be handy</p> <pre><code>strace -p &lt;pid&gt;\n</code></pre> <p><code>&lt;pid&gt;</code> should be ID of running process.</p>"},{"location":"Homeworks/h2/#ex-3-a-simple-system-call","title":"Ex. 3 \u2014 A simple system call","text":""},{"location":"Homeworks/h2/#1-kernel-printing","title":"1. Kernel printing.","text":"<p>a) What is the counterpart of printf() when working inside the Linux kernel?</p> <p>The <code>printk</code> is the counterpart of <code>printf</code> inside Linux kernel log. It is visible in <code>dmesg</code>. </p> <p>b) Write the body a simple \u201ckernel function\u201d displaying \u201cMum is proud of you!\u201d</p> <pre><code>void mum_is_proud(void) {\n    printk(KERN_INFO \"Mum is proud of you!\\n\");\n}\n</code></pre> <p><code>KERN_INFO</code> is one level of log, meaning it is not information. </p>"},{"location":"Homeworks/h2/#2-headers-and-function-name","title":"2. Headers and function name.","text":"<p>a) What header files should be included when adding a new system call? </p> <pre><code>#include &lt;linux/kernel.h&gt;    // kernel-related functions including printk().\n#include &lt;linux/syscalls.h&gt;  // system call macros like SYSCALL_DEFINE.\n</code></pre> <p>b) How are the macros <code>SYSCALL_DEFINE0</code> and <code>SYSCALL_DEFINEx</code> working?</p> <p><code>SYSCALL_DEFINE0(name)</code> defines system call with zero arguments. It internally uses the <code>asmlinkage</code> keyword, ensuring function called follows convention for system calls.</p> <p><code>SYSCALL_DEFINEx</code> defines system call with x number of arguments where xrange from 0 to 6. </p> <p>c) Use the SYSCALL_DEFINE0 to define the new system call encouragement. Name your file encouragement.c and save it in a folder encouragement at the root of the kernel source code</p> <pre><code>#include &lt;linux/kernel.h&gt;\n#include &lt;linux/syscalls.h&gt;\n\nSYSCALL_DEFINE0(encouragement) {\n    printk(KERN_INFO \"Mum is proud of you!\\n\");\n    return 0;\n}\n</code></pre> <p>Save at root of the kernel source code. </p> <pre><code>cd ~/sched_ext-for-6.11/ \nmkdir encouragement \ncd encouragement \necho '#include &lt;linux/kernel.h&gt;\n#include &lt;linux/syscalls.h&gt;\n\nSYSCALL_DEFINE0(encouragement) {\n    printk(KERN_INFO \"Mum is proud of you!\\n\");\n    return 0;\n}' &gt; encouragement.c\n</code></pre>"},{"location":"Homeworks/h2/#3-makefile-and-kbuild","title":"3. Makefile and Kbuild.","text":"<p>a) Jump to the end of Kbuild file and following the same patterns as on the last few lines, add your encouragement directory there.</p> <pre><code>nano Kbuild \n</code></pre> <pre><code>obj-$(CONFIG_SAMPLES)   += samples/\nobj-$(CONFIG_NET)       += net/\nobj-y                   += virt/\nobj-y                   += $(ARCH_DRIVERS)\nobj-y                   += encouragement/\n</code></pre> <p>b) Check the Makefiles for the directories listed at the end of Kbuild file and create a Makefile for your encouragement directory.</p> <pre><code>touch Makefile \n</code></pre> <pre><code># Makefile of J H Park  \n\nobj-y := encouragement.o \n</code></pre>"},{"location":"Homeworks/h2/#4-system-call-registration","title":"4. System call registration.","text":"<p>a) Add your new system call to <code>syscalls.h</code>.</p> <p>Hint: there are more than one such file, make sure to edit the correct one!</p> <p>Correct position at <code>/include/linux/syscalls.h</code> in my M3 Mac will be ARM64.  However, <code>cat arch/aarch64/include/asm/syscalls.h</code> does not exist. Only <code>cat arch/arm/include/asm/syscall.h</code> exist. </p> <pre><code>uname -m\naarch64\ncat arch/arm64/include/asm/syscall\nsyscall.h          syscall_wrapper.h  \ncat arch/arm/include/asm/syscalls.h \n</code></pre> <p>Instead of editing <code>arch/arm64/include/asm/syscall.h</code> </p> <p>I edited <code>arch/arm64/include/asm/syscall.h</code></p> <pre><code> # nano arch/arm64/include/asm/syscall.h \nnano include/linux/syscalls.h\n\nasmlinkage long sys_encouragement(void);\n</code></pre> <p>b) Add your new system call to <code>syscall_64.tbl</code>.  Hint: what architecture is your Linux running on?</p> <p>M3 Mac should set system call value in different position. </p> <pre><code>nano arch/arm64/kernel/syscall.c \n\n#include &lt;linux/kernel.h&gt; // Included \n#include &lt;linux/syscalls.h&gt; // Included \n\nSYSCALL_DEFINE0(encouragement) {\n    printk(KERN_INFO \"Mum is proud of you!\\n\");\n    return 0;\n}\n</code></pre>"},{"location":"Homeworks/h2/#5-recompile-the-kernel-and-reboot-do-not-forget-to-update-the-bootloader","title":"5. Recompile the kernel and reboot (do not forget to update the bootloader).","text":"<p>Recompile </p> <pre><code>make -j$(nproc)\n</code></pre> <p>If modules are not installed install </p> <pre><code>make modules_install\nmake install\nreboot\n</code></pre>"},{"location":"Homeworks/h2/#6-write-a-simple-user-space-program-to-demonstrate-the-well-functioning-of-your-system-call","title":"6. Write a simple user space program to demonstrate the well functioning of your system call.","text":"<p>This is program. </p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/syscall.h&gt;\n\nint main() {\n    long result = syscall(438);  \n    printf(\"Syscall returned: %ld\\n\", result);\n    return 0;\n}\n</code></pre> <p>If kernel reaches storage issue </p> <pre><code>df -h\nmake clean\nmake mrproper\ndf -h\n</code></pre>"},{"location":"Homeworks/h3/","title":"Index","text":""},{"location":"Homeworks/h3/#assignment-iii","title":"Assignment III","text":"<p>ECE4820 FA2024 Introduction to Operating Systems 518370990004 Jae Heung Park</p>"},{"location":"Homeworks/h3/#exercise-1-general-questions","title":"Exercise 1 - General questions","text":""},{"location":"Homeworks/h3/#exercise-11-if-a-multithreaded-process-forks-a-problem-occurs-if-the-child-gets-copies-of-all-the-parents-threads","title":"Exercise 1.1 If a multithreaded process forks, a problem occurs if the child gets copies of all the parent's threads.","text":"<p>Suppose that one of the original threads was waiting for keyboard input. Now two threads are waiting for keyboard input, one in each process. Does this problem ever occur in single-threaded processes? </p> <p>NO. In single thread, <code>fork()</code> call of process id will receive child process as  copy of single thread. Only one process can wait for input. Thus,  it is not likely for single thread CPU to have this kind of duplicated input  acquisition.</p>"},{"location":"Homeworks/h3/#exercise-12-many-unix-system-calls-have-no-win32-api-equivalents","title":"Exercise 1.2 Many UNIX system calls have no Win32 API equivalents.","text":"<p>For each such call, what are the consequences when porting a program from a UNIX system to a Windows system? </p> <p>Some OS concepts in UNIX exist in WIN32 too, but their commands are different, such as process generation command <code>fork()</code> is either in Windows threads or  <code>CreateProcess()</code> function. So, UNIX command is mostly incompatible.  Thus, consequences when porting a program from a UNIX system to a Windows system  will be unlikely to work due to incompatible calls.  </p>"},{"location":"Homeworks/h3/#exercise-2-c-programming-the-code-of-this-exercise-will-be-reused-in-future-labs","title":"Exercise 2 - C programming - The code of this exercise will be reused in future labs","text":"<p>The goal of this exercise is to improve the programming skills and get more familiar with pointers and function pointers. </p> <ol> <li>Implement a linked list structure containing two pointers of type char and void. It should be possible to at least add elements to the list.</li> <li>Knowing that the void pointer in the structure could contain some char*, int, or double, write a search function for this linked list.</li> <li>The linked list will store elements read from an ASCII file where each line is in the format <code>somestring=somedata</code>. The type of the data is defined in the filename; for instance a file containing unsorted integers will be named rand_int.txt. Implement the necessary functions to read and write such files.</li> <li>Use a function pointers to compare and sort the elements from the structure with respect to the data field. Implement the following sorting orders: increasing, decreasing, and random. The filename is <code>sortingtype_dataype.txt</code>, where <code>sortingtype</code> is rand, inc, or dec.s</li> <li>Write a function to test the implementation.</li> </ol> <p>Sample output, test on JOJ using <code>git commit -m \"joj.h3</code> </p> <pre><code>git add .\ngit commit --allow-empty -m \"test(h3): joj\"\ngit push\nclang-18 -std=gnu17 -O2 -Wall -Wextra -Werror -pedantic -Wno-unused-result -Wconversion -Wvla main.c -o h3\n./h3 rand_int.txt inc \n</code></pre> <p>File name structure <code>[Sort Type]_[Data Type].txt</code></p>"},{"location":"Homeworks/h3/#ex-3-research-on-posix","title":"Ex. 3 - Research on POSIX","text":"<p>Write a few paragraphs about the POSIX standards. What are they, why do they exist, what kind of things are included in the norms.</p> <p>POSIX (Portable Operating System Interface) is IEEE standard designed for  OS compatibility. It defines API and Interface of OS to be conventional  primarily targeting UNIX based systems. Not only Linux and MacOS but also  even Microsoft Windows can offer some POSIX compatibility based on  Windows Subsystem for Linux (WSL). </p> <p>During the warring states of OS, a lot of OS emerged and competed against  each other. Almost all of them had different form of commands, functions,  system calls, and utilities without any compatibility. This made programmers  to make different codes of system call for each OS, making it extremely  inefficient. POSIX standard application in OS industry promised way much  portable software for all software programs in different OS. </p> <p>POSIX standard has several key concepts. </p> <ol> <li>System Calls for process creation<code>fork()</code>, execution<code>exec()</code>, and termination <code>exit()</code>, <code>kill()</code>. </li> <li>File IO (input output) stream operations <code>read()</code>, <code>write()</code>, permissions, directory functions <code>opendir()</code>, <code>readdir()</code>. </li> <li>Multi Threading APIs like POSIX Threads or Pthreads </li> <li>IPC (Inter Process Communication) and Process Management lik <code>pipe()</code> </li> <li>Network Standards including socket based communication </li> <li>Command Line Interface basic functions like <code>ls</code>, <code>cd</code>, <code>grep</code>, <code>awk</code>, <code>sed</code>, etc...</li> <li>Shell Script standards </li> </ol> <p>POSIX allow compatible software for different OS, so code portability is way much better,  and programmers don't need to make software for each different Operating Systems.</p>"},{"location":"Homeworks/h4/","title":"Index","text":""},{"location":"Homeworks/h4/#assignment-4","title":"Assignment 4","text":"<p>ECE4820 FA2024 Introduction to Operating Systems 518370990004 Jae Heung Park</p>"},{"location":"Homeworks/h4/#exercise-1-simple-questions","title":"Exercise 1 Simple questions","text":""},{"location":"Homeworks/h4/#1","title":"1.","text":"<p>Consider a system in which threads are implemented entirely in user space, with the run-time system getting a clock interrupt once a second. Suppose that a clock interrupt occurs while some thread is executing in the run-time system. What problem might occur? Can you suggest a way to solve it? </p> <p>Thread control data corruption is likely if system runtime is during thread update including thread status,  program counter, or stack pointer. Clock interruption might compromise thread data structure. Also, interruption handling malfunction might also happen. Implementation of interrupt masking in  runtime system can solve this issue, since it will basically prohibit interruption temporarily  during thread process that would compromise system is not finished. Once these operations are complete, the interrupts can be enabled again.  This approach will ensure no interruption during thread processes that might damage if stopped without finish.</p>"},{"location":"Homeworks/h4/#2","title":"2.","text":"<p>Suppose that an operating system does not have anything like the select system call (man select for more details on the command) to see in advance if it is safe to read from a file, pipe, or device, but it does allow alarm clocks to be set that interrupt blocked system calls. Is it possible to implement a threads package in user space under these conditions? Discuss.</p> <p>It is possible to implement a threads package in user space under conditions without any commands  similar to <code>select</code> system call. It is important to remember that blocked threads are not blocking entire process.  Kernel manages all processes, but they are not controlling each thread.  It will be impossible to check whether file or pipe are ready to be used during Input / Output, without <code>select()</code> function.  However, <code>alarm clock</code> can be used to get worktime in the following order. </p> <ol> <li>Thread request to read from file or pipe </li> <li>Runtime system call <code>read()</code> </li> <li>If call blocks, alarm clock like <code>alarm()</code> or <code>settimer()</code> interrupt blocked system call </li> <li>Receive alarm interrupt, runtime system save blocked thread status </li> <li>Blocked thread switch to another thread</li> <li>Original thread retry IO operation</li> </ol> <p>Even though this clock using approach wastes resource for counting times for each process I/O,  this method will successfully prevent process blocking during I/O by thread switch. </p>"},{"location":"Homeworks/h4/#exercise-2-race-condition-in-bash","title":"Exercise 2 Race condition in Bash","text":"<p>Write a Bash script which generates a file composed of one integer per line. The script should read the last number in the file, add one to it, and append the result to the file. </p>"},{"location":"Homeworks/h4/#1-run-the-script-in-both-background-and-foreground-at-the-same-time-how-long-does-it-take-before-observing-a-race-condition","title":"1. Run the script in both background and foreground at the same time. How long does it take before observing a race condition?","text":"<p>Code implemented at <code>h4/ex2.sh</code>. Foreground on front line and background on back line. </p> <pre><code># If file does not exist create starting with 0\nif [ ! -f counter.txt ]; then\n    echo 0 &gt; counter.txt\nfi\n\n# Read the last number from the file\nlast_num=$(tail -n 1 counter.txt)\n\n# Create new number incremented one from last number\nnew_num=$((last_num + 1))\n\n# Append new number to result\necho $new_num &gt;&gt; counter.txt\n</code></pre> <p>Foreground Terminal </p> <pre><code>chmod +x ex2.sh\n./ex2.sh\n</code></pre> <p>Background Terminal  </p> <pre><code>while true; do ./ex2.sh &amp; sleep 0.1; done\n</code></pre> <p>The background terminal will iterate to execute <code>ex2.sh</code> forever until it is interrupted. </p>"},{"location":"Homeworks/h4/#2-modify-the-script-such-as-to-prevent-the-race-condition","title":"2. Modify the script such as to prevent the race condition.","text":"<p>Code implementation to lock infinite loop is required. </p> <pre><code># Flock usage, only one process write to file at same time \nexec 200&gt;counter.txt.lock      # Create or open lock file \nflock -n 200 || exit 1         # Get lock, exit if locked \n</code></pre> <p>Added the following lines of code to implement lock.  </p>"},{"location":"Homeworks/h4/#exercise-3-programming-with-semaphores","title":"Exercise 3 Programming with semaphores","text":"<p>The following C code creates two threads which increment a common global variable. When run it  generates a random and inaccurate output. In order to solve this problem we want to use semaphores. </p> <ol> <li>On Linux, find the file semaphore.h. </li> <li>Read the documentation to understand how to use the functions described in the file <code>semaphore.h</code>. </li> <li>Using semaphores adjust the program such as to always return the correct answer. </li> </ol> <pre><code>find /usr/include -name semaphore.h\n/usr/include/semaphore.h \ncat /usr/include/semaphore.h \n</code></pre> <p>Semaphore file attached as <code>semaphore.h</code> in folder.</p> <p>The GNU C Library (glibc) manual Semaphore </p> <p>Linux shell manual check by following command </p> <pre><code>man sem_init\nman sem_wait\n</code></pre> <p>Semaphore code to always return the correct answer is in <code>semaphore.c</code> file.  </p> <pre><code>clang-18 -std=gnu17 -O2 -Wall -Wextra -Werror -pedantic -Wno-unused-result -Wconversion -Wvla code.c -o code\n</code></pre>"},{"location":"Homeworks/h5/","title":"Index","text":""},{"location":"Homeworks/h5/#assignment-5","title":"Assignment 5","text":"<p>ECE4820 FA2024 Introduction to Operating Systems 518370990004 Jae Heung Park</p>"},{"location":"Homeworks/h5/#ex-1-simple-questions","title":"Ex. 1 \u2014 Simple questions","text":"<p>1. A system has two processes and three identical resources. Each process needs a maximum of two resources. Can a deadlock occur? Explain. </p> <p>Deadlock can occur in the following circumstances. </p> <ol> <li>Mutual Exclusion  </li> <li>Hold and Wait </li> <li>No Preemption </li> <li>Circular Wait </li> </ol> <p>System has two processes and one process can handle maximum 2 resources, meaning that  the entire system can handle maximum 4 resources. Each process require maximum 2 resources. However, only 3 resources exist in current circumstance.  Thus, since process capability of system is not full, deadlock is NOT going to occur. </p> <p>2. A computer has six tape drives, with n processes competing for them. Each process may need two drives. For which values of n is the system deadlock free? </p> <p>Similar to the answer made at previous problem,  System might potentially have deadlock at least $n \\geq 6$.  Thus, if $n \\in {1,2,3,4,5}$, then deadlock is not likely to happen. </p> <p>3. A real-time system has four periodic events with periods of 50, 100, 200, and 250 msec each.    Suppose the four events require 35, 20, 10, and x msec of CPU time, respectively. What is the    largest value x for which the system is schedulable? </p> <p>$\\frac{35}{50} + \\frac{20}{100} + \\frac{10}{200} + \\frac{x}{250} &lt; 1$ </p> <p>$0.95 + \\frac{x}{250} &lt; 1 \\implies \\frac{x}{250} &lt; 0.05 \\implies x &lt; 12.5$ </p> <p>Thus, 12.5 will be maximum. </p> <p>4. Round-robin schedulers normally maintain a list of all runnable processes, with each process occurring    exactly once in the list. What would happen if a process occurred more than once in the    list? Would there be any reason for allowing this? </p> <p>If same process occurred more than once, then CPU Time will be allocated more to that process. </p> <p>5. Can a measure of whether a process is likely to be CPU bound or I/O bound be detected by    analyzing the source code. How to determine it at runtime? </p> <p>CPU bound process is heavily composed of computation. </p> <p>Input Output bound is literally handling reading input and writing output of files. </p>"},{"location":"Homeworks/h5/#exercise-2-deadlocks","title":"Exercise 2 \u2014 Deadlocks","text":"<p>Assuming three resources consider the following snapshot of a system. </p> Process Allocated Maximum Available P1 010 753 332 P2 200 322 P3 302 902 P4 211 222 P5 002 433 <p>1. Determine the content of the Request matrix.</p> <p>$ \\begin{bmatrix} 7 &amp; 4 &amp; 3 \\ 1 &amp; 2 &amp; 2 \\ 6 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 1 \\ 4 &amp; 3 &amp; 1 \\ \\end{bmatrix} $ </p> <p>2. Is the system in a safe state?</p> <p>Banker's algorithm should be used to check system status safety.  Available resources are $[3,3,2]$. </p> <p>$P4=(0,1,1) \\rightarrow (3 + 2, 3 + 1, 2 + 1) = (5, 4, 3)$</p> <p>$P2=(1,2,2) \\rightarrow (5 + 2, 4 + 0, 3 + 0) = (7, 4, 3)$</p> <p>$P1=(7,4,3) \\rightarrow  (7 + 0, 4 + 1, 3 + 0) = (7, 5, 3)$</p> <p>$P3=(6,0,0) \\rightarrow (7 + 3, 5 + 0, 3 + 2) = (10, 5, 5)$</p> <p>$P5=(10, 5, 5) \\rightarrow (10 + 0, 5 + 0, 5 + 2) = (10, 5, 5)$</p> <p>3. Can all the processes be completed without the system being in an unsafe state at any stage?</p> <p>Yes. Sequence will be  $P4 \\rightarrow P2 \\rightarrow P1 \\rightarrow P3 \\rightarrow P5$ with no safety vulnerable part. </p>"},{"location":"Homeworks/h5/#ex-3-the-reader-writer-problem","title":"Ex. 3 \u2014 The reader-writer problem","text":"<p>In the reader-writer problem, some data could be accessed for reading but also sometimes for writing. When processes want to read the data they get a read lock and a write lock for writing. Multiple processes could get a read lock at the same time while a write lock should prevent anybody else from reading or writing the data until the write lock is released.</p> <p>To solve the problem we decide to use a global variable count together with two semaphores: count_lock for locking the count variable, and db_lock for locking the database. To get a write lock we can proceed as follows: </p> <pre><code>void write_lock() {\n    down(db_lock);\n}\n\nvoid write_unlock() {\n    up(db_lock);\n}\n</code></pre> <p>1. Explain how to get a read lock, and write the corresponding pseudocode.</p> <p>Counter for counting active readers number is required.  When reader start, increase count.  For first reader, lock database.  If reader ends, decrease count.  If it is last reader, release db lock.  This is following pseudocode. </p> <pre><code>void read_lock(){\n    down(count_lock); \n    if(count == 0) down(db_lock); // First reader lock databas e\n    count++; \n    up(count_lock); \n}\n\nvoid read_unlock(){\n    down(count_lock); \n    count--; \n    if(count==0) up(db_lock); // Last reader unlocks the database\n    up(count_lock); \n}\n</code></pre> <p>2. Describe what is happening if many readers request a lock.</p> <p>When several lock request is made by several readers, then  each reader could increase count and only first reader will lock database.  Every following readers could skip database lock.  Block any new reader when a writer becomes available.</p> <p>3. Explain how to implement this idea using another semaphore called read_lock.</p> <p>Prevent writer to unclearly handle reader influx by using semaphore <code>read lock</code>.  This blocks new readers and allow readers to operate properly. </p> <pre><code>void read_lock() {\n    down(read_lock); // New reader prevention \n    down(count_lock);\n    if(count == 0) down(db_lock); \n    count++;\n    up(count_lock);\n    up(read_lock);            \n}\n\nvoid read_unlock() {\n    down(count_lock);\n    count--;\n    if(count==0) up(db_lock);\n    up(count_lock);\n}\n</code></pre> <p>4. Is this solution giving any unfair priority to the writer or the reader? Can the problem be considered as solved?</p> <p>Since this solution prohibits new readers to start, it will primarily process writer if resource gets available.  It will prevent writer starving, but it causes reader starving instead.  Thus, balancing resources for both read and write will be more applicable.  Queue or algorithm implementation will be required to give 'fair' priority for both writer and reader. </p>"},{"location":"Homeworks/h6/","title":"Index","text":""},{"location":"Homeworks/h6/#assignment-6","title":"Assignment 6","text":"<p>ECE4820 FA2024 Introduction to Operating Systems 518370990004 Jae Heung Park</p>"},{"location":"Homeworks/h6/#exercise-1","title":"Exercise 1","text":""},{"location":"Homeworks/h6/#11","title":"1.1","text":"<p>Consider a swapping system in which memory consists of the following hole sizes in memory order: 10 KB, 4 KB, 20 KB, 18 KB, 7 KB, 9 KB, 12 KB, and 15 KB. Assuming first fit is used, which hole is taken for successive segment requests of: (i) 12 KB, (ii) 10 KB and (iii) 9KB. Repeat for best fit and quick fit.</p> <p>Available hole sizes: 10 4 20 18 7 9 12 15 </p> <p>First Fit </p> <p>(i) 12KB TO 20KB (ii) 10KB TO 18KB (iii) 9KB TO 15KB</p> <p>Best Fit </p> <p>(i) 12KB TO 12KB (ii) 10KB TO 10KB (iii) 9KB TO 9KB </p> <p>Quick Fit </p> <p>(i) 12KB TO 12KB (ii) 10KB TO 10KB (iii) 9KB TO 9KB</p>"},{"location":"Homeworks/h6/#12","title":"1.2","text":"<p>If an instruction takes 10 nsec and a page fault takes an additional n nsec, give a formula for the effective instruction time if page faults occur every k instructions.</p> <p>Formula for Effective Instruction Time </p> <p>instruction time $t=10$ nanoseconds Page fault additional $n$ nanoseconds  Page fault occur every $k$ instructions </p> <p>Effective Time $= t + \\frac{n}{k}$</p>"},{"location":"Homeworks/h6/#13","title":"1.3","text":"<p>A small computer has four page frames. At the first clock tick, the R bits are 0111. At t subsequent clock tics, the values are 1011, 1010, 1101, 0010, 1010, 1100 and 0001. Assuming the aging algorithm is used with an 8-bit counter what is the value of the four counters after the last tick.</p> Page Counter Value Page 0 <code>01101110</code> Page 1 <code>01001001</code> Page 2 <code>00110111</code> Page 3 <code>10001011</code>"},{"location":"Homeworks/h6/#exercise-2-page-tables","title":"Exercise 2 Page tables","text":"<p>In the lecture it was mentioned that the translation from virtual address into physical address could be sped up using the TLB. Unfortunately this solution is not of much help in the case of large page tables. Investigate the two following alternative solutions: inverted page tables and multilevel page tables.</p> Feature Inverted Page Tables Multilevel Page Tables Description Single table for physical frames Hierarchical table structure Table Size Based on physical memory size Based on used virtual pages Benefits Saves memory for large virtual spaces Efficient for sparse address spaces Limitations Slower lookups due to table search Requires multiple memory accesses Implementation Uses a hash function or search mechanism Adds memory for hierarchical levels"},{"location":"Homeworks/h6/#ex-3-research","title":"Ex. 3 \u2014 Research","text":"<p>Write about half a page on the topic of codes bugs that lead to security holes; In particular illustrate the discussion using common examples. Do not forget to reference your sources of information.</p> <p>Generally subtle bugs inside code files are vulnerable against hacker attack.  It can allow external attack to compromise computer system.  Flaw logic and insufficient input validation are two core reasons that  might potentially cause vulnerabilities. </p> <p>SQL user input query sanitization failure made SQL query execution that are not actually input. This attack is named as <code>SQL injection</code>. Wikipedia: SQL injection</p> <p>Multi Threading environment has <code>race condition</code> if process result in unexpected behavior.  Dirty Cow is one good example using write access to read only files.  Red Hat: Dirty COW Race Condition. Dirty COW Vulnerability</p> <p>When program access beyond allocated memory, then adjacent memory not allocated  will be overwritten. This part can have attack code, named as <code>Buffer overflow</code>. Wikipedia: Morris Worm</p> <p>When validation of user input in file path is not correct,  attacker can access inside system, navigating directories. Even access to the  <code>etc/passwd</code> might be possible. This is <code>Directory Traversal</code>.  Fortinet Security Advisory</p> <p>Attackers use bug in <code>Privilege Escalation</code> aiming higher access privilege  than programming system. For instance, Microsoft OpenSSL was attacked by Heartbleed bug.  OpenSSL Heartbleed Bug</p> <p>When validation failure or user input encoding error occurs,  <code>XSS (Cross Side Scripting)</code> became vulnerable against attacks. Then, other user's web browser can be injected  with attack codes that might save tokens and cookies required for login. Wikipedia: Samy (computer worm)</p> <p>When memory is accessed after free, <code>UAF (Use After Free)</code> bug appears. Internet Explorer  had this, so had a lot of security issues. CVE Details. Database of Software Vulnerabilities.</p> <p>Applications that have deserialized data is good way for attackers, <code>Deserialization Vulnerabilities</code> inside code. Apache Struts had similar issue, leaking 147 million individual information!  Apache Strtus</p>"},{"location":"Homeworks/h6/#ex-4-linux","title":"Ex. 4 \u2014 Linux","text":"<p>Write a very short C program that leads to thrashing.</p> <p>Code in <code>main.c</code></p>"},{"location":"Homeworks/h7/","title":"Assignment 7","text":"<p>ECE4820 FA2024 Introduction to Operating Systems</p> <p>518370990004 Jae Heung Park</p>"},{"location":"Homeworks/h7/#ex-1-page-replacement-algorithm","title":"Ex. 1 \u2014 Page replacement algorithm","text":"<p>In this exercise we consider the WSClock page replacement algorithm with a \u03c4 value of two ticks.  The system state is given as follows.</p> Page Time Stamp Present Referenced Modified 0 6 1 0 1 1 9 1 1 0 2 9 1 1 1 3 7 1 0 0 4 4 0 0 0"},{"location":"Homeworks/h7/#ex-11-explain-the-content-of-the-new-table-entries-if-a-clock-interrupt-occurs-at-tick-10","title":"Ex. 1.1. Explain the content of the new table entries if a clock interrupt occurs at tick 10.","text":"<p>Page 0, <code>Time Stamp</code> $= 6 \\leq 8$, old,  <code>Referenced</code> $=0$, Replacement candidate,  <code>Modified</code> $=1$, Should be written in disk. </p> <p>Page 1, <code>Time Stamp</code> $= 9 \\geq 8$, Not old, No change </p> <p>Page 2, <code>Time Stamp</code> $= 9 \\geq 8$, Not old, No change </p> <p>Page 3, <code>Time Stamp</code> $= 7 \\leq 8$, old,  Replacement candidate, with no need to write back to disk </p> <p>Page 4, <code>Present</code>$=0$, so not in memory, not considered for replacement </p> <p>Table after Tick 10 interrupt is following. </p> Page Time Stamp Present Referenced Modified 0 6 1 0 0 1 9 1 1 0 2 9 1 1 1 3 7 1 0 0 4 4 0 0 0"},{"location":"Homeworks/h7/#ex-12-due-to-a-read-request-to-page-4-a-page-fault-occurs-at-tick-10-describe-the-new-table-entry","title":"Ex. 1.2. Due to a read request to page 4 a page fault occurs at tick 10. Describe the new table entry.","text":"<p>Suppose read request for page 4 is made.  Since <code>Present</code> = 0, page is not in memory. Page Fault. </p> <p>WSLock Algorithm </p> <p>First, select victim page. For page 3,  <code>Time Stamp</code> $= 7 \\leq 8$, old, <code>Referenced</code>$=0$, <code>Modified</code>$=0$, No need to write back in disk. </p> <p>Now remove page 3 and load page 4.  Update <code>Present</code> $=1$, <code>Referenced</code>$=0$, <code>Modified</code>$=0$.  Result table will be following. </p> Page Time Stamp Present Referenced Modified 0 6 1 0 0 1 9 1 1 0 2 9 1 1 1 3 7 0 0 0 4 10 1 0 0"},{"location":"Homeworks/h7/#ex-2-minix-3","title":"Ex. 2 \u2014 Minix 3","text":"<p>The goal of this exercise is to understand and implement system calls. </p>"},{"location":"Homeworks/h7/#ex-21-in-which-files-are","title":"Ex. 2.1. In which files are:","text":""},{"location":"Homeworks/h7/#a-the-constants-with-number-and-name-for-the-system-calls","title":"a) the constants with number and name for the system calls?","text":"<p>Path is <code>/include/minix/callnr.h</code></p>"},{"location":"Homeworks/h7/#b-the-names-of-the-system-call-routines","title":"b) the names of the system call routines?","text":"<p><code>/servers/*/table.c</code></p>"},{"location":"Homeworks/h7/#c-the-prototypes-of-the-system-call-routines","title":"c) the prototypes of the system call routines?","text":"<p><code>/servers/*/proto.h</code></p>"},{"location":"Homeworks/h7/#d-the-system-calls-of-type-signal-coded","title":"d) the system calls of type \u201csignal\u201d coded?","text":"<p><code>/servers/pm/signal.c</code></p>"},{"location":"Homeworks/h7/#ex-22-what-problems-arise-when-trying-to-implement-a-system-call-int-getchpidsint-n-pid_t-childpid","title":"Ex. 2.2. What problems arise when trying to implement a system call int getchpids(int n, pid_t *childpid)","text":""},{"location":"Homeworks/h7/#which-writes-the-pids-of-up-to-n-children-of-the-current-process-into-childpid","title":"which \u201cwrites\u201d the pids of up to n children of the current process into *childpid?","text":"<ul> <li>Since <code>*childpid</code> is located in user space, kernel code will not directly access to user space pointers </li> <li>Secure copy mechanism (<code>sys_datacopy</code>) is required.</li> <li>Validate Buffer size sufficiency to handle <code>n</code> child PIDs.</li> <li>Concurrent issue appears when process create or remove children during execution. </li> </ul>"},{"location":"Homeworks/h7/#ex-23-write-a-sub-system-call-int-getnchpidint-n-pid_t-childpid-which-retrieves-the-n-th-child-process","title":"Ex. 2.3. Write a \u201csub-system call\u201d int getnchpid(int n, pid_t childpid) which retrieves the n-th child process.","text":"<pre><code>#include \"pm.h\"\n#include \"mproc.h\"\n\nint getnchpid(int n, pid_t *childpid) {\n    if (childpid == NULL) return -1;             \n    if (n &gt;= NR_PROCS) return -1;                \n\n    struct mproc *child = &amp;mproc[n]; \n    if (child-&gt;mp_parent != who_p) return -1;    // Ensure the process is a child of caller\n\n    *childpid = child-&gt;mp_pid;                    // Retrieve PID of the child\n    return 0;                               \n}\n</code></pre>"},{"location":"Homeworks/h7/#ex-24-using-the-previous-sub-system-call-implement-the-original-getchpids-system-call","title":"Ex. 2.4. Using the previous sub-system call, implement the original getchpids system call.","text":""},{"location":"Homeworks/h7/#the-returned-int-value-corresponds-to-the-number-of-pids-in-childpid-or-1-on-an-error","title":"The returned int value corresponds to the number of pids in *childpid, or -1 on an error.","text":"<pre><code>#include \"pm.h\"\n#include \"mproc.h\"\n\nint do_getchpids(int n, pid_t *childpid) {\n    if (childpid == NULL) return -1;         \n    if (n &gt; NR_PROCS) return -1;            \n\n    int count = 0;\n    for (int i = 0; i &lt; n; i++) {\n        int result = getnchpid(i, &amp;childpid[i]);\n        if (result == -1) break;  // Stop if no more children\n        count++;\n    }\n    return count;                 // Return children retrieved count \n}\n</code></pre>"},{"location":"Homeworks/h7/#ex-25-write-a-short-program-that-demonstrate-the-previous-system-calls","title":"Ex. 2.5. Write a short program that demonstrate the previous system calls.","text":"<pre><code>#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/wait.h&gt;\n\n#define NUM 10  // Number of child processes to create\n\nint main() {\n    pid_t child_pids[NUM];\n    pid_t retrieved_pids[NUM];\n\n    // Create child processes\n    for (int i = 0; i &lt; NUM; i++) {\n        pid_t pid = fork();\n        if (pid == 0) { // Child process\n            printf(\"Child %d: PID = %d\\n\", i, getpid());\n            exit(0);\n        } else if (pid &gt; 0) { // Parent process\n            child_pids[i] = pid;\n        } else {\n            perror(\"fork failed\");\n            exit(1);\n        }\n    }\n\n    // Wait for all child processes to terminate\n    for (int i = 0; i &lt; NUM; i++) {\n        wait(NULL);\n    }\n\n    // Call `getchpids` to retrieve child PIDs\n    int result = getchpids(NUM, retrieved_pids);\n    if (result &lt; 0) {\n        fprintf(stderr, \"getchpids fail\\n\");\n        return -1;\n    }\n\n    // Validate and print results\n    for (int i = 0; i &lt; result; i++) {\n        printf(\"Retrieved PID: %d\\n\", retrieved_pids[i]);\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"Homeworks/h7/#ex-26-the-above-strategy-solves-the-initial-problem-through-the-introduction-of-a-sub-system-call","title":"Ex. 2.6. The above strategy solves the initial problem through the introduction of a sub-system call.","text":""},{"location":"Homeworks/h7/#a-what-are-the-drawbacks-and-benefits-of-this-solution","title":"a) What are the drawbacks and benefits of this solution?","text":"<p>Drawbacks:  - Additional overhead due to multiple calls to <code>getnchpid</code>. - Complexity in handling edge cases (e.g., invalid indices). - Higher potential for race conditions.</p> <p>Benefits: - Modular design makes debugging easier. - Reusability of the <code>getnchpid</code> function.</p>"},{"location":"Homeworks/h7/#b-without-implementing-it-describe-the-basic-details-of-an-alternative-approach","title":"b) Without implementing it, describe the basic details of an alternative approach.","text":"<p>Implement <code>getchpids</code> as single system call</p> <ul> <li>Iteration through the process table in one pass.</li> <li>Retrieval of all child PIDs directly into user-provided buffer.</li> </ul>"},{"location":"Homeworks/h7/#ex-3-research","title":"Ex. 3 \u2014 Research","text":""},{"location":"Homeworks/h7/#write-about-a-page-on-the-topic-of-the-ext2-filesystem-do-not-forget-to-reference-your-sources","title":"Write about a page on the topic of the ext2 filesystem. Do not forget to reference your sources.","text":"<p>Second Extended File System, or ext2 file system is a non-journaling filesystem  introduced in 1993 for Linux. It was designed to overcome the limit of  the ext filesystem by improving performance, flexibility, and scalability. due to its simplicity and efficiency, ext2 is still used for certain applications.  Key components of ext2 are followings. </p> <ul> <li>Superblock contains filesystem metadata, its size, block num, inodes, etc </li> <li>Inode Table represent file or directory and contain information like size, owner, timestamp, etc </li> <li>Data Blocks save file contents. Large files are supported by indirect, double indirect, etc. </li> <li>Block Group divide filesystem to block group, each containing inode table, data block, etc.  </li> </ul> <p>Since ext2 does not use journaling, overhead is reduced and writing speed is faster  than later generation filesystems like ext3 or ext4 sometimes.  This make it appropriate for devices with limited resources like USB or embedded systems.  Its flexible inode allocation system allow optimized work performance with  large quantity of volumes, even up to 2TB in size on 4KB block systems at maximum. </p> <p>However, absence of journaling represents crash or system power fail will  require <code>fsck</code> check to restart. It might compromise data, and much slower.  Also, its workload is not enough to handle huge quantity of volumes nowadays.</p> <p>References </p> <ul> <li>\"The Linux Kernel Archives\" - https://www.kernel.org</li> <li>\"Understanding Linux Filesystems\" - https://tldp.org</li> <li>Linux terminal man pages (man ext2, man fsck).</li> </ul>"},{"location":"Homeworks/h7/#ex-4-simple-questions","title":"Ex. 4 \u2014 Simple questions","text":""},{"location":"Homeworks/h7/#ex-41-if-a-page-is-shared-between-two-processes","title":"Ex. 4.1. If a page is shared between two processes,","text":""},{"location":"Homeworks/h7/#is-it-possible-that-the-page-is-read-only-for-one-process-and-read-write-for-the-other-why-or-why-not","title":"is it possible that the page is read-only for one process and read-write for the other? Why or why not?","text":"<p>Yes. Memory Management Unit (MMU) will enforce access permission based on page table of each process.  One process will map page for read only, and other process will map as read and write. </p>"},{"location":"Homeworks/h7/#ex-42-when-both-paging-and-segmentation-are-being-used","title":"Ex. 4.2. When both paging and segmentation are being used,","text":""},{"location":"Homeworks/h7/#first-the-segment-descriptor-is-found-and-then-the-page-descriptor-does-the-tlb-also-need-a-two-levels-lookup","title":"first the segment descriptor is found and then the page descriptor. Does the TLB also need a two-levels lookup?","text":"<p>No. TLB will not need two process layers. TLB acquire virtual to physical transition  after page lookup and full segment. TLB will miss trigger two level lookup to update TLB. </p>"},{"location":"Homeworks/h8/","title":"Assignment VIII","text":"<p>ECE4820 FA2024 Introduction to Operating Systems 518370990004 Jae Heung Park</p>"},{"location":"Homeworks/h8/#exercise-1-inputoutput","title":"Exercise 1 - Input/Output","text":""},{"location":"Homeworks/h8/#1-is-it-possible-to-scan-a-document-and-send-it-through-a-wireless-network-at-full-speed-explain-why-why-not","title":"1. Is it possible to scan a document and send it through a wireless network at full speed? Explain why, why not.","text":"<p>It is theoretically possible depends on system bottleneck.  Factors are scan resolution, scanner scan speed, and bandwidth of wireless network.  If network speed is faster than scanner output rate, scan time will be fine.  However, delays like image compression will prevent to send data to full speed of wireless network. </p>"},{"location":"Homeworks/h8/#2-how-can-an-os-facilitate-the-installation-of-a-new-device-without-any-need-to-recompile-the-os-or-even-to-reboot-it","title":"2. How can an OS facilitate the installation of a new device without any need to recompile the OS or even to reboot it?","text":"<p>OS can use modular designs to dynamically load device drivers.  When new device is connected, OS will detect device by plug and play mechanism.  Then, load the appropriate driver without requiring any reboot or recompile. </p>"},{"location":"Homeworks/h8/#3-in-the-slides-four-io-software-layers-are-listed-in-which-layers-are-the-following-operations-done","title":"3. In the slides four I/O software layers are listed; in which layers are the following operations done:","text":"<ul> <li>a) Computing the track, sector, and head for a disk read -&gt; Device Driver Layer </li> <li>b) Writing command to the device registers -&gt; Hardware Layer </li> <li>c) Checking if the user is allowed to use the device -&gt; User Level Software Layer or OS Layer </li> <li>d) Converting binary integers to ASCII for printing -&gt; User Level Software Layer</li> </ul>"},{"location":"Homeworks/h8/#a-dma-controller-has-four-channels-the-controller-is-able-to-request-a-32bit-word-every-100-nsec","title":"A DMA controller has four channels. The controller is able to request a 32bit word every 100 <code>nsec</code>.","text":"<p>A response takes equally long. How fats should the bus be in order to avoid being a bottleneck? </p> <p>DMA controller request and response per 100<code>ns</code> for 32-bit words. Bus support speed $\\frac{32 <code>bits</code>}{100 <code>ns</code>} = 320$MB/<code>sec</code> = 40 MB/<code>sec</code>  to avoid bottleneck. </p>"},{"location":"Homeworks/h8/#5-briefly-explain-what-a-thin-client-is","title":"5. Briefly explain what a thin client is.","text":"<p>Thin client is lightweight computer system.  It mostly relies on server to process and store data.  It is primarily used for application access, data, or remote desktop. </p>"},{"location":"Homeworks/h8/#6-describe-how-a-hard-disk-is-working-and-give-a-few-details-regarding-its-geometry","title":"6. Describe how a hard disk is working and give a few details regarding its geometry.","text":"<p>Hard disk can store a large quantity of data in a huge scale by platters.  Each platter is divided by tracks, and each track is divided by sectors.  The read/write head </p>"},{"location":"Homeworks/h8/#7-what-are-differences-between-raid-0-1-5-6-and-10","title":"7. What are differences between RAID 0, 1, 5, 6, and 10?","text":"<ul> <li>RAID 0 - Stripe without redundancy, fast, no fault tolerance </li> <li>RAID 1 - Stripe with redundancy, mirroring </li> <li>RAID 5 - Stripe with distributed parity, need at minimum 3 disks. </li> <li>RAID 6 - Stripe with distributed dual parity, can handle 2 disk failures </li> <li>RAID 10  Combine RAID 0 and 1, high performance by mirroring and stripe without redundancy </li> </ul>"},{"location":"Homeworks/h8/#exercise-2-multiprocessors","title":"Exercise 2 - Multiprocessors","text":""},{"location":"Homeworks/h8/#1-suppose-that-the-tsl-instruction-was-not-available-for-synchronizing-a-multiprocessor","title":"1. Suppose that the TSL instruction was not available for synchronizing a multiprocessor.","text":"<p>Instead, another instruction, SWP was provided that atomically swapped the contents of a register with a  word in memory. How could that be used to provide multiprocessor synchronisation? </p> <p>The <code>SWP</code> instruction could swap register by lock with memory allocation easily.  If lock is free, SWAP will lock variable to ensure mutual exclusion. </p>"},{"location":"Homeworks/h8/#2-briefly-describe-virtualization-and-the-main-challenges-that-need-to-be-overcome","title":"2. Briefly describe virtualization and the main challenges that need to be overcome.","text":"<p>Virtualization make several operating systems to run in one physical PC.  However, resource allocation and isolation would be key technological challenges.  Specifically, CPU scheduling, I/O virtualization, and security isolation will be important. </p>"},{"location":"Homeworks/h8/#exercise-3-file-systems","title":"Exercise 3 - File systems","text":""},{"location":"Homeworks/h8/#1-assuming-the-current-working-directory-is-usrsharedocmuttexamples","title":"1. Assuming the current working directory is <code>/usr/share/doc/mutt/examples</code>","text":"<p>what is the absolute path of <code>../../../doc/../../lib/mutt</code>?</p> <p><code>/usr/share/doc/mutt/examples</code> to <code>../../../doc</code> is <code>/usr/share/doc</code>. <code>/usr/share/doc</code> to <code>../../lib/mutt</code> is <code>/usr/lib/mutt</code>  Thus, absolute path will be <code>/usr/lib/mutt</code>.</p>"},{"location":"Homeworks/h8/#2-a-unix-system-has-1kb-blocks-and-4b-disk-addresses","title":"2. A Unix system has 1KB blocks and 4B disk addresses.","text":"<p>What is the maximum file size if i-nodes contain 13 direct entries,  and one single, double , and triple indirect entry each? </p> <p>Each block can hold $\\frac{1KB}{4KB}=256$ addresses. </p> <ul> <li>Direct entries are $13 \\times 1KB = 13KB$</li> <li>Single Indirect Entry $256 \\times 1KB = 256KB$ </li> <li>Double Indirect Entry $256 \\times 256 \\times 1KB = 65536KB = 64MB$</li> <li>Triple Indirect Entry $256 \\times 256 \\times 256 \\times 1KB = 16777216MB = 16384MB = 16GB$ </li> <li>Maximum File Size $13KB + 256KB + 64MB + 16GB = 16448.2627 MB = 16.06GB$</li> </ul>"},{"location":"Homeworks/h8/#3-the-time-required-to-read-a-certain-number-of-bytes-can-be-approximated-by-summing-the-seek-rotation-delay-and-transfer-times","title":"3. The time required to read a certain number of bytes can be approximated by summing the seek, rotation delay, and transfer times.","text":"<p>Given a disk with mean seek time of 8 msec, a rotation rate of 15,000 rpm and 262,144 bytes per track what are the data rates for block sizes of </p> <ul> <li>(i) 1 KB,</li> <li>(ii) 2 KB, and </li> <li>(iii) 4 KB?</li> </ul> <p>Parameters Provided </p> <ul> <li>Mean seek time = $ 8 \\, \\text{ms} $</li> <li>Rotation time per revolution = $ \\frac{1}{15,000} \\times 60,000 = 4 \\, \\text{ms} $</li> <li>Bytes per track = $ 262,144 \\, \\text{bytes} $</li> </ul> <p>Transfer Time Formula: $ \\text{Transfer Time} = \\frac{\\text{Block Size}}{\\text{Bytes per Track}} \\times 4 \\, \\text{ms} $ </p>"},{"location":"Homeworks/h8/#i-block-size-1-kb-1024-textbytes","title":"(i) Block Size = 1 KB ($ 1,024 \\, \\text{bytes} $)","text":"<ul> <li>Transfer Time = $ \\frac{1,024}{262,144} \\times 4 \\approx 0.0156 \\, \\text{ms} $</li> <li>Total Time = $ 8 + 4 + 0.0156 = 12.0156 \\, \\text{ms} $</li> <li>Data Rate = $ \\frac{1,024 \\, \\text{bytes}}{12.0156 \\, \\text{ms}} \\approx 85.2 \\, \\text{KB/s} $.</li> </ul>"},{"location":"Homeworks/h8/#ii-block-size-2-kb-2048-textbytes","title":"(ii) Block Size = 2 KB ($ 2,048 \\, \\text{bytes} $)","text":"<ul> <li>Transfer Time = $ \\frac{2,048}{262,144} \\times 4 \\approx 0.0312 \\, \\text{ms} $</li> <li>Total Time = $ 8 + 4 + 0.0312 = 12.0312 \\, \\text{ms} $</li> <li>Data Rate = $ \\frac{2,048 \\, \\text{bytes}}{12.0312 \\, \\text{ms}} \\approx 170.3 \\, \\text{KB/s} $.</li> </ul>"},{"location":"Homeworks/h8/#iii-block-size-4-kb-4096-textbytes","title":"(iii) Block Size = 4 KB ($ 4,096 \\, \\text{bytes} $)","text":"<ul> <li>Transfer Time = $ \\frac{4,096}{262,144} \\times 4 \\approx 0.0624 \\, \\text{ms} $</li> <li>Total Time = $ 8 + 4 + 0.0624 = 12.0624 \\, \\text{ms} $</li> <li>Data Rate = $ \\frac{4,096 \\, \\text{bytes}}{12.0624 \\, \\text{ms}} \\approx 339.7 \\, \\text{KB/s} $.</li> </ul>"},{"location":"Homeworks/h8/#exercise-4-security","title":"Exercise 4 - Security","text":""},{"location":"Homeworks/h8/#1-if-using-only-lowercase-letters-how-many-possible-8-letter-words-can-be-chosen","title":"1. If using only lowercase letters how many possible 8 letter words can be chosen?","text":"<p>Explain why a password should always contain lower and uppercase letters, numbers and symbols. </p> <p>8 Character Word, use only lowercase letters, 26 probabilities per each character. Possible combination likelihood will be $26^8 = 208827064576$ cases. </p> <p>It is important to contain lower case, upper case letter, number, and symbols because  it will increment probability of password search space exponentially. Entropy of password increases, so brute Force attack will be more resource unlikely. For instance, uppercase multiplies twice probability per character, $2^8=256$ times for 8 characters. </p>"},{"location":"Homeworks/h8/#2-explain-why-memory-dynamically-allocated-using-malloc-is-sometimes-random-and-some-other-times-set-to-0","title":"2. Explain why memory dynamically allocated using malloc is sometimes random and some other times set to 0.","text":"<p>Memory allocation by <code>malloc</code> does not initialize memory.  It reserves size but may return memory with no leftover values from previous use, while <code>calloc</code> explicitly initialize to 0. If <code>calloc</code> is called, or memory is initialized explicitly, checking whether memory start is 0 or not is crucial.  </p>"},{"location":"Homeworks/h8/#3-a-computer-system-is-made-of-several-components-each-featuring-a-different-level-of-security-how-secure-is-this-system","title":"3. A computer system is made of several components each featuring a different level of security. How secure is this system?","text":"<p>Computer system security is same as the most vulnerable part of the computer system.  Attackers might detect and exploit the least secure component so that entire system is under attack.  For instance, old firmware security vulnerability might be a trigger to compromise the entire OS,  that has no security problem in the OS.  Defense in depth strategies are minor ways to support weakest vulnerabilities.</p>"},{"location":"Homeworks/h8/#4-can-security-be-achieved-explain-your-answer","title":"4. Can security be achieved? Explain your answer.","text":"<p>Even theoretically, accomplishment of computer system to secure 100% perfect security is not achievable considering the complexity of computer system and its continuous technological progress.  In some perspective, some super computer that does not exist in real world might make  all computer systems insecure by brute force.  In reality, it is even harder, due to several updates, conflicts, computer external problems like  electricity supply or network, human mistakes, etc. So, people generally compromise by  implementation of defence layer, regular updates, access controls, and continuous monitor. </p>"},{"location":"Homeworks/h8/#exercise-5-research","title":"Exercise 5 - Research","text":"<p>Write about half a page on the topic of firewalls on Linux systems; include information on iptables.  Do not forget to reference your sources of information. </p> <p>In Linux Operating System, Firewalls manage and secure network traffic by controlling incoming and  outgoing traffic based on predefined rules. It could protect against not authorized access and attacks.  Firewall acts as barrier located between trusted networks and untrusted networks.  It protects system access from unauthorized access, so that attacks and data breaches are prevented. </p> <p>Firework analyze packets and decide whether they are allowed by defined rules including: </p> <ul> <li>IP Address   : allow or block traffic from specific source or destination </li> <li>Port Numbers : Filter by services (Block SSH by block port 22)</li> <li>Protocols    : Protocol type based filtering like TCP or UDP   </li> </ul> <p>There are several types of firewalls available. </p> <ul> <li>Packet Filtering Firewall work at network layer to inspect each individual packet, regardless of connection status. </li> <li>Stateful Firewall could work and track connection status to make more context aware decisions  </li> <li>Application Firewall inspect packet contents in application layer </li> <li>Proxy Firewalls act between server and client to mask internal network </li> </ul> <p>One of the most commonly applied tool on Linux firewall is <code>iptables</code>.  It is a part of the <code>netfilter</code> framework inside Linux OS kernel.  It could operate on chains including <code>INPUT</code>, <code>OUTPUT</code>, and <code>FORWARD</code> so that  traffic filtering is possible through IO address, ports, or protocols. </p> <p>Administrator access could allow and block network traffic by making <code>iptables</code> rules.  For example, following command can be used to prevent any SSH traffic on part 22. </p> <pre><code>sudo iptables -A INPUT -p tcp --dport 22 -j DROP\n</code></pre> <p>Even though <code>nftables</code>, more recent version that provide higher performance and better usability,  <code>iptables</code> are still used in some modern distributions due to its stability and reliability.  Additional tools like Uncomplicated Firewall (UFU) and firewalld support interfaces that are  friendly for users to manage firewall rules, sot that complexity of iptables is in abstract.</p> <p>Although firewalls are powerful and have several functionalities,  their limitation would be due to its subordinate part of layered security approach as  some framework or tool than could be part of consistent update and intrusion detection systems (IDS). </p>"},{"location":"Homeworks/h8/#references","title":"References","text":"<ul> <li>Linux Foundation. \"iptables Documentation.\"</li> <li>Red Hat. \"Introduction to Firewalld and iptables.\"</li> <li>Ubuntu Documentation. \"Uncomplicated Firewall (UFW).\"</li> <li>Netfilter Project. \"nftables Overview.\" </li> <li>Iptables HowTo. </li> <li>Introduction to nftables </li> </ul>"}]}